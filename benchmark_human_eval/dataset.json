[
    {
        "task_id": "0",
        "entry_point": "has_close_elements",
        "stress_test": "[{\"input\": \"[[(-1)**i * i for i in range(5000)], 0.01]\", \"output\": null}, {\"input\": \"[[i * 0.0001 for i in range(5000)], 0.00005]\", \"output\": null}, {\"input\": \"[[i / 3.0 for i in range(3000)], 0.1]\", \"output\": null}, {\"input\": \"[[i * 0.001 for i in range(2000)], 0.0005]\", \"output\": null}, {\"input\": \"[[float(i) / 2 for i in range(2000)], 0.001]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<vector>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool has_close_elements(vector<float> numbers, float threshold){\nint i,j;\n    \n    for (i=0;i<numbers.size();i++)\n    for (j=i+1;j<numbers.size();j++)\n    if (abs(numbers[i]-numbers[j])<threshold)\n    return true;\n\n    return false;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    vector<float> a={1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    assert (has_close_elements(a, 0.3)==true);\n    assert (has_close_elements(a, 0.05) == false);\n\n    assert (has_close_elements({1.0, 2.0, 5.9, 4.0, 5.0}, 0.95) == true);\n    assert (has_close_elements({1.0, 2.0, 5.9, 4.0, 5.0}, 0.8) ==false);\n    assert (has_close_elements({1.0, 2.0, 3.0, 4.0, 5.0}, 2.0) == true);\n    assert (has_close_elements({1.1, 2.2, 3.1, 4.1, 5.1}, 1.0) == true);\n    assert (has_close_elements({1.1, 2.2, 3.1, 4.1, 5.1}, 0.5) == false);\n    \n}\n",
        "cpp_stress_test": "#include <vector>\nusing namespace std;\nint main() {\nvector<float> a1; for (int i = 0; i < 5000; ++i) a1.push_back((i % 2 ? -i : i) * 1.0f); has_close_elements(a1, 0.01f);\nvector<float> a2; for (int i = 0; i < 5000; ++i) a2.push_back(i * 0.0001f); has_close_elements(a2, 0.00005f);\nvector<float> a3; for (int i = 0; i < 3000; ++i) a3.push_back(i / 3.0f); has_close_elements(a3, 0.1f);\nvector<float> a4; for (int i = 0; i < 2000; ++i) a4.push_back(i * 0.001f); has_close_elements(a4, 0.0005f);\nvector<float> a5; for (int i = 0; i < 2000; ++i) a5.push_back(i / 2.0f); has_close_elements(a5, 0.001f);\nreturn 0;\n}"
    },
    {
        "task_id": "1",
        "entry_point": "separate_paren_groups",
        "stress_test": "[{\"input\": \"['((())(()()(())))' * 2500]\", \"output\": null}, {\"input\": \"['()' * 5000 + ' ' + '()' * 5000]\", \"output\": null}, {\"input\": \"['()' * 10000]\", \"output\": null}, {\"input\": \"['((()()))' * 1000 + ' ' + '((()()))' * 1000 + ' ' + '((()()))' * 1000]\", \"output\": null}, {\"input\": \"['((()))' * 3000]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> separate_paren_groups(string paren_string){\nvector<string> all_parens;\n    string current_paren;\n    int level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_parens.push_back(current_paren);\n                current_paren=\"\";\n            }\n        }\n    }\n    return all_parens;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){  \n    assert (issame(separate_paren_groups(\"(()()) ((())) () ((())()())\"),{\"(()())\", \"((()))\", \"()\", \"((())()())\"}));\n    assert (issame(separate_paren_groups(\"() (()) ((())) (((())))\"), {\"()\", \"(())\", \"((()))\", \"(((())))\" }));\n    assert (issame(separate_paren_groups(\"(()(())((())))\") ,{ \"(()(())((())))\" }));\n    assert (issame(separate_paren_groups(\"( ) (( )) (( )( ))\") ,{\"()\", \"(())\", \"(()())\"}));\n}",
        "cpp_stress_test": "#include <vector>\n#include <string>\nusing namespace std;\nint main() {\nstring s1; for (int i = 0; i < 2500; ++i) s1 += \"((())(()()(())))\"; separate_paren_groups(s1);\nstring s2; for (int i = 0; i < 5000; ++i) s2 += \"()\"; s2 += \" \"; for (int i = 0; i < 5000; ++i) s2 += \"()\"; separate_paren_groups(s2);\nstring s3; for (int i = 0; i < 10000; ++i) s3 += \"()\"; separate_paren_groups(s3);\nstring s4; for (int i = 0; i < 1000; ++i) s4 += \"((()()))\"; s4 += \" \"; for (int i = 0; i < 1000; ++i) s4 += \"((()()))\"; s4 += \" \"; for (int i = 0; i < 1000; ++i) s4 += \"((()()))\"; separate_paren_groups(s4);\nstring s5; for (int i = 0; i < 3000; ++i) s5 += \"((()))\"; separate_paren_groups(s5);\nreturn 0;\n}"
    },
    {
        "task_id": "2",
        "entry_point": "truncate_number",
        "stress_test": "[{\"input\": \"[1.7976931348623157e+308]\", \"output\": null}, {\"input\": \"[999.000000000001]\", \"output\": null}, {\"input\": \"[123.00000000001]\", \"output\": null}, {\"input\": \"[1.0000000000001]\", \"output\": null}, {\"input\": \"[10.0000000001]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat truncate_number(float number){\nreturn number-int(number);\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n assert (truncate_number(3.5) == 0.5); \n assert (abs(truncate_number(1.33) - 0.33) < 1e-4);\n  assert (abs(truncate_number(123.456) - 0.456) < 1e-4);\n}",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n truncate_number(1.7976931348623157e+308); \n truncate_number(999.000000000001); \n truncate_number(123.00000000001); \n truncate_number(1.0000000000001); \n truncate_number(10.0000000001);\n}"
    },
    {
        "task_id": "3",
        "entry_point": "below_zero",
        "stress_test": "[{\"input\": \"[[1000, -1] + [-1, 1] * 4999 + [-1000]]\", \"output\": null}, {\"input\": \"[[1] * 5000 + [-1] * 5000]\", \"output\": null}, {\"input\": \"[[1, -1] * 5000 + [0]]\", \"output\": null}, {\"input\": \"[[2, -2] * 4999 + [2, -10001]]\", \"output\": null}, {\"input\": \"[[5000] * 2000 + [-5000] * 2000]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nbool below_zero(vector<int> operations){\nint num=0;\n    for (int i=0;i<operations.size();i++)\n    {\n        num+=operations[i];\n        if (num<0) return true;\n    }\n    return false;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (below_zero({}) == false);\n    assert (below_zero({1, 2, -3, 1, 2, -3}) == false);\n    assert (below_zero({1, 2, -4, 5, 6}) == true);\n    assert (below_zero({1, -1, 2, -2, 5, -5, 4, -4}) == false);\n    assert (below_zero({1, -1, 2, -2, 5, -5, 4, -5}) == true);\n    assert (below_zero({1, -2, 2, -2, 5, -5, 4, -4}) == true);\n}",
        "cpp_stress_test": "#include<vector>\nusing namespace std;\nint main() {\n    vector<int> v1 = {1000, -1};\n    for (int i = 0; i < 4999; ++i) { v1.push_back(-1); v1.push_back(1); }\n    v1.push_back(-1000);\n    below_zero(v1);\n\n    vector<int> v2(5000, 1);\n    v2.insert(v2.end(), 5000, -1);\n    below_zero(v2);\n\n    vector<int> v3;\n    for (int i = 0; i < 5000; ++i) { v3.push_back(1); v3.push_back(-1); }\n    v3.push_back(0);\n    below_zero(v3);\n\n    vector<int> v4;\n    for (int i = 0; i < 4999; ++i) { v4.push_back(2); v4.push_back(-2); }\n    v4.push_back(2);\n    v4.push_back(-10001);\n    below_zero(v4);\n\n    vector<int> v5(2000, 5000);\n    v5.insert(v5.end(), 2000, -5000);\n    below_zero(v5);\n\n    return 0;\n}"
    },
    {
        "task_id": "4",
        "entry_point": "mean_absolute_deviation",
        "stress_test": "[{\"input\": \"[[x * 0.1 for x in range(-10000, 10000)]]\", \"output\": null}, {\"input\": \"[[(-1)**i * i * 0.1 for i in range(10000)]]\", \"output\": null}, {\"input\": \"[[1.0 / (i + 1) for i in range(1, 10001)]]\", \"output\": null}, {\"input\": \"[[float(i) for i in range(-5000, 5000)]]\", \"output\": null}, {\"input\": \"[[float(i) / 3 for i in range(1, 10001)]]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat mean_absolute_deviation(vector<float> numbers){\nfloat sum=0;\n    float avg,msum,mavg;\n    int i=0;\n    for (i=0;i<numbers.size();i++)\n        sum+=numbers[i];\n    avg=sum/numbers.size();\n    msum=0;\n    for (i=0;i<numbers.size();i++)\n        msum+=abs(numbers[i]-avg);\n    return msum/numbers.size();\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (abs(mean_absolute_deviation({1.0, 2.0, 3.0}) - 2.0/3.0) < 1e-4);\n    assert (abs(mean_absolute_deviation({1.0, 2.0, 3.0, 4.0}) - 1.0) < 1e-4);\n    assert (abs(mean_absolute_deviation({1.0, 2.0, 3.0, 4.0, 5.0}) - 6.0/5.0) < 1e-4);\n}",
        "cpp_stress_test": "#include <vector>\nusing namespace std;\nint main() {\n    vector<float> v1;\n    for (int i = -10000; i < 10000; ++i) v1.push_back(i * 0.1f);\n    mean_absolute_deviation(v1);\n\n    vector<float> v2;\n    for (int i = 0; i < 10000; ++i) v2.push_back((i % 2 == 0 ? i : -i) * 0.1f);\n    mean_absolute_deviation(v2);\n\n    vector<float> v3;\n    for (int i = 1; i <= 10000; ++i) v3.push_back(1.0f / i);\n    mean_absolute_deviation(v3);\n\n    vector<float> v4;\n    for (int i = -5000; i < 5000; ++i) v4.push_back(static_cast<float>(i));\n    mean_absolute_deviation(v4);\n\n    vector<float> v5;\n    for (int i = 1; i <= 10000; ++i) v5.push_back(i / 3.0f);\n    mean_absolute_deviation(v5);\n\n    return 0;\n}"
    },
    {
        "task_id": "5",
        "entry_point": "intersperse",
        "stress_test": "[{\"input\": \"[list(range(10000)), 1]\", \"output\": null}, {\"input\": \"[list(range(10000, 0, -1)), 0]\", \"output\": null}, {\"input\": \"[[0] * 10000, 999]\", \"output\": null}, {\"input\": \"[[9] * 9999 + [8], 0]\", \"output\": null}, {\"input\": \"[[1, 2, 3, 4, 5] * 2000, -1]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> intersperse(vector<int> numbers, int delimeter){\nvector<int> out={};\n    if (numbers.size()>0) out.push_back(numbers[0]);\n    for (int i=1;i<numbers.size();i++)\n    {\n        out.push_back(delimeter);\n        out.push_back(numbers[i]);\n\n    }\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(intersperse({}, 7), {}));\n    \n    assert (issame(intersperse({5, 6, 3, 2}, 8),{5, 8, 6, 8, 3, 8, 2}));\n    assert (issame(intersperse({2, 2, 2}, 2),{2, 2, 2, 2, 2}));\n}",
        "cpp_stress_test": "#include<vector>\nusing namespace std;\nint main() {\n    vector<int> v1(10000); for(int i = 0; i < 10000; ++i) v1[i] = i;\n    intersperse(v1, 1);\n\n    vector<int> v2(10000); for(int i = 0; i < 10000; ++i) v2[i] = 10000 - i;\n    intersperse(v2, 0);\n\n    vector<int> v3(10000, 0);\n    intersperse(v3, 999);\n\n    vector<int> v4(9999, 9); v4.push_back(8);\n    intersperse(v4, 0);\n\n    vector<int> v5; for(int i = 0; i < 2000; ++i) { v5.insert(v5.end(), {1,2,3,4,5}); }\n    intersperse(v5, -1);\n    return 0;\n}"
    },
    {
        "task_id": "6",
        "entry_point": "parse_nested_parens",
        "stress_test": "[{\"input\": \"[''.join(['(' * i + ')' * i + ' ' for i in range(1, 1000)])]\", \"output\": null}, {\"input\": \"[''.join(['(' * i + ')' * i + ' ' for i in range(1, 500)])]\", \"output\": null}, {\"input\": \"[''.join(['(' * 20 + ')' * 20 + ' ' for i in range(1, 250)])]\", \"output\": null}, {\"input\": \"['(()()()()()()()()()) ((()()()()()()()()())) ((((()()()()()()()()())))) ((((((()()()()()()()()())))))) ((((((()()()()()()()()()))))))']\", \"output\": null}, {\"input\": \"['((())(())) ((())(())) ((())(())) ((())(())) ((())(())) ((())(())) ((())(())) ((())(())) ((())(())) ((())(()))']\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> parse_nested_parens(string paren_string){\nvector<int> all_levels;\n    string current_paren;\n    int level=0,max_level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        if (level>max_level) max_level=level;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_levels.push_back(max_level);\n                current_paren=\"\";\n                max_level=0;\n            }\n        }\n    }\n    return all_levels;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(parse_nested_parens(\"(()()) ((())) () ((())()())\"),{2, 3, 1, 3}));\n     assert (issame(parse_nested_parens(\"() (()) ((())) (((())))\") , {1, 2, 3, 4}));\n    assert (issame(parse_nested_parens(\"(()(())((())))\") ,{4}));\n}",
        "cpp_stress_test": "#undef NDEBUG\n#include <cassert>\n#include <vector>\n#include <string>\nusing namespace std;\nbool issame(vector<int> a, vector<int> b) { if (a.size() != b.size()) return false; for (int i = 0; i < a.size(); i++) { if (a[i] != b[i]) return false; } return true; }\nint main() { \n    parse_nested_parens(string([]() { string s; for (int i = 1; i < 1000; i++) { s += string(i, '(') + string(i, ')') + ' '; } return s; }())); \n    parse_nested_parens(string([]() { string s; for (int i = 1; i < 500; i++) { s += string(i, '(') + string(i, ')') + ' '; } return s; }())); \n    parse_nested_parens(string([]() { string s; for (int i = 1; i < 250; i++) { s += string(20, '(') + string(20, ')') + ' '; } return s; }())); \n    parse_nested_parens(\"(()()()()()()()()()) ((()()()()()()()()())) ((((()()()()()()()()())))) ((((((()()()()()()()()())))))) ((((((()()()()()()()()()))))))\"); \n    parse_nested_parens(\"((())(())) ((())(())) ((())(())) ((())(())) ((())(())) ((())(())) ((())(())) ((())(())) ((())(())) ((())(()))\");\n}"
    },
    {
        "task_id": "7",
        "entry_point": "filter_by_substring",
        "stress_test": "[{\"input\": \"[[str(i) for i in range(10000)], '9999']\", \"output\": null}, {\"input\": \"[['qwerty', 'asdfgh', 'zxcvbn', 'qazwsx', 'edcrfv', 'tgb'] * 1000, 'q']\", \"output\": null}, {\"input\": \"[[''] * 5000 + ['a'], 'a']\", \"output\": null}, {\"input\": \"[['prefix' + str(i) + 'suffix' for i in range(1000)], 'prefix']\", \"output\": null}, {\"input\": \"[['substring'] * 1000, 'sub']\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> filter_by_substring(vector<string> strings, string substring){\nvector<string> out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].find(substring)!=strings[i].npos)\n        out.push_back(strings[i]);\n    }\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(filter_by_substring({}, \"john\"),{}));\n     assert (issame(filter_by_substring({\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"}, \"xxx\"), {\"xxx\", \"xxxAAA\", \"xxx\"}));\n    assert (issame(filter_by_substring({\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"}, \"xx\"),{\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"}));\n     assert (issame(filter_by_substring({\"grunt\", \"trumpet\", \"prune\", \"gruesome\"}, \"run\") ,{\"grunt\", \"prune\"}));\n}\n",
        "cpp_stress_test": "#include <vector>\n#include <string>\nusing namespace std;\n\nint main() {\n    vector<string> v1;\n    for (int i = 0; i < 10000; ++i) v1.push_back(to_string(i));\n    filter_by_substring(v1, \"9999\");\n\n    vector<string> v2;\n    for (int i = 0; i < 1000; ++i) {\n        v2.push_back(\"qwerty\"); v2.push_back(\"asdfgh\"); v2.push_back(\"zxcvbn\");\n        v2.push_back(\"qazwsx\"); v2.push_back(\"edcrfv\"); v2.push_back(\"tgb\");\n    }\n    filter_by_substring(v2, \"q\");\n\n    vector<string> v3(5000, \"\");\n    v3.push_back(\"a\");\n    filter_by_substring(v3, \"a\");\n\n    vector<string> v4;\n    for (int i = 0; i < 1000; ++i) v4.push_back(\"prefix\" + to_string(i) + \"suffix\");\n    filter_by_substring(v4, \"prefix\");\n\n    vector<string> v5(1000, \"substring\");\n    filter_by_substring(v5, \"sub\");\n\n    return 0;\n}"
    },
    {
        "task_id": "8",
        "entry_point": "sum_product",
        "stress_test": "[{\"input\": \"[[i for i in range(1, 10001)]]\", \"output\": null}, {\"input\": \"[list(range(1, 5001)) + list(range(5000, 0, -1))]\", \"output\": null}, {\"input\": \"[[-10**3, 10**3] * 5000]\", \"output\": null}, {\"input\": \"[[i for i in range(-5000, 5000)]]\", \"output\": null}, {\"input\": \"[[2, 3, 5] * 3333 + [2]]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> sum_product(vector<int> numbers){\nint sum=0,product=1;\n    for (int i=0;i<numbers.size();i++)\n    {\n        sum+=numbers[i];\n        product*=numbers[i];\n    }\n    return {sum,product};\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sum_product({}) ,{0, 1}));\n    assert (issame(sum_product({1, 1, 1}), {3, 1}));\n    assert (issame(sum_product({100, 0}),{100, 0}));\n     assert (issame(sum_product({3, 5, 7}) , {3 + 5 + 7, 3 * 5 * 7}));\n      assert (issame(sum_product({10}) ,{10, 10}));\n}\n\n\n",
        "cpp_stress_test": "#include<vector>\nusing namespace std;\n\nint main(){\n    vector<int> temp0(10000); for (int i = 0; i < 10000; i++) temp0[i] = i + 1;\n    sum_product(temp0);\n\n    vector<int> temp1(5000); for (int i = 0; i < 5000; i++) temp1[i] = i + 1;\n    vector<int> temp2(5000); for (int i = 0; i < 5000; i++) temp2[i] = 5000 - i;\n    temp1.insert(temp1.end(), temp2.begin(), temp2.end());\n    sum_product(temp1);\n\n    vector<int> temp3(10000);\n    for (int i = 0; i < 5000; i++) {\n        temp3[i * 2] = -1000;\n        temp3[i * 2 + 1] = 1000;\n    }\n    sum_product(temp3);\n\n    vector<int> temp4(10000); for (int i = 0; i < 10000; i++) temp4[i] = -5000 + i;\n    sum_product(temp4);\n\n    vector<int> temp5(9999); for (int i = 0; i < 9999; i++) temp5[i] = (i % 3 == 0) ? 2 : (i % 3 == 1) ? 3 : 5;\n    sum_product(temp5);\n\n    return 0;\n}"
    },
    {
        "task_id": "9",
        "entry_point": "rolling_max",
        "stress_test": "[{\"input\": \"[[i for i in range(10000)]]\", \"output\": null}, {\"input\": \"[[i**2 for i in range(10000)]]\", \"output\": null}, {\"input\": \"[list(range(5000)) + list(range(5000, 0, -1))]\", \"output\": null}, {\"input\": \"[[i % 500 for i in range(10000)]]\", \"output\": null}, {\"input\": \"[[10**4 - i for i in range(10000)]]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> rolling_max(vector<int> numbers){\nvector<int> out;\n    int max=0;\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (numbers[i]>max) max=numbers[i];\n        out.push_back(max);\n    }\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n     assert (issame(rolling_max({}),{}));\n    assert (issame(rolling_max({1, 2, 3, 4}) , {1, 2, 3, 4}));\n     assert (issame(rolling_max({4, 3, 2, 1}),{4, 4, 4, 4}));\n      assert (issame(rolling_max({3, 2, 3, 100, 3}) ,{3, 3, 3, 100, 100}));\n}",
        "cpp_stress_test": "#include <vector>\nusing namespace std;\nint main() {\n    vector<int> v1(10000);\n    for (int i = 0; i < 10000; ++i) v1[i] = i;\n    rolling_max(v1);\n\n    vector<int> v2(10000);\n    for (int i = 0; i < 10000; ++i) v2[i] = i * i;\n    rolling_max(v2);\n\n    vector<int> v3;\n    for (int i = 0; i < 5000; ++i) v3.push_back(i);\n    for (int i = 5000; i > 0; --i) v3.push_back(i);\n    rolling_max(v3);\n\n    vector<int> v4(10000);\n    for (int i = 0; i < 10000; ++i) v4[i] = i % 500;\n    rolling_max(v4);\n\n    vector<int> v5(10000);\n    for (int i = 0; i < 10000; ++i) v5[i] = 10000 - i;\n    rolling_max(v5);\n\n    return 0;\n}"
    },
    {
        "task_id": "10",
        "entry_point": "make_palindrome",
        "stress_test": "[{\"input\": \"['abcdefghijklmnopqrstuvwxyz' * 384 + 'abcdefghijklmnopqrstuvwx']\", \"output\": null}, {\"input\": \"['abcdefghij' * 1000]\", \"output\": null}, {\"input\": \"['abc' * 3333 + 'a']\", \"output\": null}, {\"input\": \"['x' * 9999 + 'y']\", \"output\": null}, {\"input\": \"['a' * 9999 + 'b']\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nbool is_palindrome(string str){\n    string s(str.rbegin(),str.rend());\n    return s==str;\n}\nstring make_palindrome(string str){\nint i;\n   for (i=0;i<str.length();i++)\n   {\n        string rstr=str.substr(i);\n        if (is_palindrome(rstr))\n        {\n            string nstr;\n            nstr=str.substr(0,i);\n            string n2str(nstr.rbegin(),nstr.rend());\n            return str+n2str;\n        }\n   }\n   string n2str(str.rbegin(),str.rend());\n   return str+n2str;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (make_palindrome(\"\") == \"\");\n    assert (make_palindrome(\"x\") == \"x\");\n     assert (make_palindrome(\"xyz\") == \"xyzyx\");\n     assert (make_palindrome(\"xyx\") == \"xyx\") ;\n     assert (make_palindrome(\"jerry\") == \"jerryrrej\");\n}\n\n\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\n#include<string>\n#include<vector>\n\nint main(){\n    std::vector<std::pair<std::string, std::string>> test_cases = {\n        {\"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwx\", {}},\n        {\"abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij\", {}},\n        {\"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc\", {}},\n        {\"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\", {}},\n        {\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\", {}}\n    };\n}"
    },
    {
        "task_id": "11",
        "entry_point": "string_xor",
        "stress_test": "[{\"input\": \"['101' * 3333 + '1', '010' * 3333 + '0']\", \"output\": null}, {\"input\": \"['1' * 10000, '0' * 10000]\", \"output\": null}, {\"input\": \"['0101010101' * 1000, '1010101010' * 1000]\", \"output\": null}, {\"input\": \"['1100' * 2500, '0011' * 2500]\", \"output\": null}, {\"input\": \"['1111' + '0000' * 2499, '0000' + '1111' * 2499]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_xor(string a,string b){\nstring output=\"\";\n    for (int i=0;(i<a.length() and i<b.length());i++)\n    {\n        if (i<a.length() and i<b.length())\n        {\n            if (a[i]== b[i]) \n            {\n                output+='0';\n            }  \n            else output+='1';\n        }\n        else\n        {\n            if (i>=a.length()) \n            {\n            output+=b[i];\n            }\n            else output+=a[i];\n        }\n    }\n    return output;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (string_xor(\"111000\", \"101010\") == \"010010\");\n     assert (string_xor(\"1\", \"1\") == \"0\");\n    assert (string_xor(\"0101\", \"0000\") == \"0101\");\n\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\nint main(){string_xor(\"101101101101...\" /* '101' * 3333 + '1' */, \"010010010010...\" /* '010' * 3333 + '0' */); string_xor(\"1111...\" /* '1' * 10000 */, \"0000...\" /* '0' * 10000 */); string_xor(\"010101010101...\" /* '0101010101' * 1000 */, \"101010101010...\" /* '1010101010' * 1000 */); string_xor(\"11001100...\" /* '1100' * 2500 */, \"00110011...\" /* '0011' * 2500 */); string_xor(\"11110000...\" /* '1111' + '0000' * 2499 */, \"00001111...\" /* '0000' + '1111' * 2499 */);}"
    },
    {
        "task_id": "12",
        "entry_point": "longest",
        "stress_test": "[{\"input\": \"[['a' * i for i in range(1, 10001)]]\", \"output\": null}, {\"input\": \"[['a' * i for i in range(1, 5000)] + ['b' * j for j in range(5000, 10001)]]\", \"output\": null}, {\"input\": \"[['a' * 10000] * 10000]\", \"output\": null}, {\"input\": \"[['a' * i + 'b' * (10000 - i) for i in range(1, 10001)]]\", \"output\": null}, {\"input\": \"[['a' * (i % 100) for i in range(10000)]]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring longest(vector<string> strings){\nstring out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].length()>out.length()) out=strings[i];\n    }\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (longest({}) == \"\");\n    assert (longest({\"x\", \"y\", \"z\"}) == \"x\");\n    assert (longest({\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"}) == \"zzzz\");\n}\n",
        "cpp_stress_test": "#include <vector>\n#include <string>\nint main() { \n    std::vector<std::string> test1; for (int i = 1; i <= 10000; ++i) test1.push_back(std::string(i, 'a')); \n    std::vector<std::string> test2; for (int i = 1; i < 5000; ++i) test2.push_back(std::string(i, 'a')); for (int j = 5000; j <= 10000; ++j) test2.push_back(std::string(j, 'b')); \n    std::vector<std::string> test3(10000, std::string(10000, 'a'));\n    std::vector<std::string> test4; for (int i = 1; i <= 10000; ++i) test4.push_back(std::string(i, 'a') + std::string(10000 - i, 'b')); \n    std::vector<std::string> test5; for (int i = 0; i < 10000; ++i) test5.push_back(std::string(i % 100, 'a')); \n}"
    },
    {
        "task_id": "13",
        "entry_point": "greatest_common_divisor",
        "stress_test": "[{\"input\": \"[123456, 789012]\", \"output\": null}, {\"input\": \"[29929, 39939]\", \"output\": null}, {\"input\": \"[1234, 5678]\", \"output\": null}, {\"input\": \"[1234, 4321]\", \"output\": null}, {\"input\": \"[9876, 54321]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint greatest_common_divisor(int a, int b){\nint out,m;\n    while (true){\n        if (a<b) \n        {\n            m=a;a=b;b=m;\n        }\n        a=a%b;\n        if (a==0) return b;\n    }\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (greatest_common_divisor(3, 7) == 1);\n     assert (greatest_common_divisor(10, 15) == 5);\n      assert (greatest_common_divisor(49, 14) == 7);\n     assert (greatest_common_divisor(144, 60) == 12);\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    greatest_common_divisor(123456, 789012);\n    greatest_common_divisor(29929, 39939);\n    greatest_common_divisor(1234, 5678);\n    greatest_common_divisor(1234, 4321);\n    greatest_common_divisor(9876, 54321);\n}"
    },
    {
        "task_id": "14",
        "entry_point": "all_prefixes",
        "stress_test": "[{\"input\": \"[''.join(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'] * 385)]\", \"output\": null}, {\"input\": \"['abc' * 3333 + 'def']\", \"output\": null}, {\"input\": \"['x' * 5000 + 'y' * 5000]\", \"output\": null}, {\"input\": \"['1234567890' * 1000]\", \"output\": null}, {\"input\": \"['b' * 9999 + 'c']\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> all_prefixes(string str){\nvector<string> out;\n    string current=\"\";\n    for (int i=0;i<str.length();i++)\n    {\n        current=current+str[i];\n        out.push_back(current);\n    }\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(all_prefixes(\"\"),{}));\n    assert (issame(all_prefixes(\"asdfgh\") ,{\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"}));\n     assert (issame(all_prefixes(\"WWW\") ,{\"W\", \"WW\", \"WWW\"}));\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include <assert.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nbool issame(vector<string> a, vector<string> b) {\n    if (a.size() != b.size()) return false;\n    for (int i = 0; i < a.size(); i++) {\n        if (a[i] != b[i]) return false;\n    }\n    return true;\n}\n\nint main() {\n    issame(all_prefixes(string(385, 'a') + string(385, 'b') + string(385, 'c') + string(385, 'd') + string(385, 'e') + string(385, 'f') + string(385, 'g') + string(385, 'h') + string(385, 'i') + string(385, 'j') + string(385, 'k') + string(385, 'l') + string(385, 'm') + string(385, 'n') + string(385, 'o') + string(385, 'p') + string(385, 'q') + string(385, 'r') + string(385, 's') + string(385, 't') + string(385, 'u') + string(385, 'v') + string(385, 'w') + string(385, 'x') + string(385, 'y') + string(385, 'z')), {});\n    issame(all_prefixes(string(3333, 'a') + string(3333, 'b') + string(3333, 'c') + \"def\"), {});\n    issame(all_prefixes(string(5000, 'x') + string(5000, 'y')), {});\n    issame(all_prefixes(string(1000, '1') + string(1000, '2') + string(1000, '3') + string(1000, '4') + string(1000, '5') + string(1000, '6') + string(1000, '7') + string(1000, '8') + string(1000, '9') + string(1000, '0')), {});\n    issame(all_prefixes(string(9999, 'b') + 'c'), {});\n}"
    },
    {
        "task_id": "15",
        "entry_point": "string_sequence",
        "stress_test": "[{\"input\": \"[10000]\", \"output\": null}, {\"input\": \"[9999]\", \"output\": null}, {\"input\": \"[9876]\", \"output\": null}, {\"input\": \"[8765]\", \"output\": null}, {\"input\": \"[7890]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring string_sequence(int n){\nstring out=\"0\";\n    for (int i=1;i<=n;i++)\n    out=out+\" \"+to_string(i);\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (string_sequence(0) == \"0\");\n    assert (string_sequence(3) == \"0 1 2 3\");\n     assert (string_sequence(10) == \"0 1 2 3 4 5 6 7 8 9 10\");\n}\n",
        "cpp_stress_test": "int main(){ string_sequence(10000); string_sequence(9999); string_sequence(9876); string_sequence(8765); string_sequence(7890); }"
    },
    {
        "task_id": "16",
        "entry_point": "count_distinct_characters",
        "stress_test": "[{\"input\": \"['a' * 10000 + 'A' * 10000 + 'b' * 9999 + 'B' * 9999]\", \"output\": null}, {\"input\": \"['a' * 5000 + 'B' * 5000 + 'c' * 5000 + 'D' * 5000]\", \"output\": null}, {\"input\": \"['a' * 5000 + 'A' * 5000 + 'b' * 5000 + 'B' * 5000]\", \"output\": null}, {\"input\": \"['a' * 5000 + 'A' * 5000 + 'b' * 4999 + 'B' * 4999]\", \"output\": null}, {\"input\": \"['AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz' * 333]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_distinct_characters(string str){\nvector<char> distinct={};\n    transform(str.begin(),str.end(),str.begin(),::tolower);\n    for (int i=0;i<str.size();i++)\n    {\n        bool isin=false;\n        for (int j=0;j<distinct.size();j++)\n            if (distinct[j]==str[i])\n                isin=true;\n        if (isin==false) distinct.push_back(str[i]);\n\n    }\n    return distinct.size();\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (count_distinct_characters(\"\") == 0);\n    assert (count_distinct_characters(\"abcde\") == 5);\n    assert (count_distinct_characters(\"abcdecadeCADE\") == 5);\n    assert (count_distinct_characters(\"aaaaAAAAaaaa\") == 1);\n    assert (count_distinct_characters(\"Jerry jERRY JeRRRY\") == 5);\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include <assert.h>\n#include <string>\nusing namespace std;\n\nint main() {\n    count_distinct_characters(string(10000, 'a') + string(10000, 'A') + string(9999, 'b') + string(9999, 'B'));\n    count_distinct_characters(string(5000, 'a') + string(5000, 'B') + string(5000, 'c') + string(5000, 'D'));\n    count_distinct_characters(string(5000, 'a') + string(5000, 'A') + string(5000, 'b') + string(5000, 'B'));\n    count_distinct_characters(string(5000, 'a') + string(5000, 'A') + string(4999, 'b') + string(4999, 'B'));\n    string s;\n    for (int i = 0; i < 333; ++i) s += \"AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz\";\n    count_distinct_characters(s);\n}"
    },
    {
        "task_id": "17",
        "entry_point": "parse_music",
        "stress_test": "[{\"input\": \"['.| o| o| ' * 3333 + 'o' * 1]\", \"output\": null}, {\"input\": \"['o| .| .| ' * 3333 + 'o|']\", \"output\": null}, {\"input\": \"['o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o']\", \"output\": null}, {\"input\": \"['o| .| o| .| o| .| o| .| o| .| o| .| o| .| o| .| o| .| o| .| o| .| o| .| o| .| o| .| o| .| o|']\", \"output\": null}, {\"input\": \"['o o o .| .| .| o| o| o| .| .| o| o| o o| o o| o o o o| o| .| .| .| o| o| o o| o| o o| o .|']\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> parse_music(string music_string){\nstring current=\"\";\n    vector<int> out={};\n    if (music_string.length()>0)\n        music_string=music_string+' ';\n    for (int i=0;i<music_string.length();i++)\n    {\n        if (music_string[i]==' ')\n        {\n            if (current==\"o\") out.push_back(4);\n            if (current==\"o|\") out.push_back(2);\n            if (current==\".|\") out.push_back(1);\n            current=\"\";\n        }\n        else current+=music_string[i];\n    }\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(parse_music(\"\") , {}));\n     assert (issame(parse_music(\"o o o o\") ,{4, 4, 4, 4}));\n      assert (issame(parse_music(\".| .| .| .|\") , {1, 1, 1, 1}));\n assert (issame(parse_music(\"o| o| .| .| o o o o\") , {2, 2, 1, 1, 4, 4, 4, 4}));\n  assert (issame(parse_music(\"o| .| o| .| o o| o o|\") , {2, 1, 2, 1, 4, 2, 4, 2}));\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include <assert.h>\n#include <string>\n#include <vector>\nusing namespace std;\nint main() {\n    // Test 1: Repeat pattern \".| o| o| \" 3333 times and add a single 'o'\n    string music1;\n    for (int i = 0; i < 3333; ++i) music1 += \".| o| o| \";\n    music1 += \"o\";\n    parse_music(music1);\n\n    // Test 2: Repeat pattern \"o| .| .| \" 3333 times and add \"o|\"\n    string music2;\n    for (int i = 0; i < 3333; ++i) music2 += \"o| .| .| \";\n    music2 += \"o|\";\n    parse_music(music2);\n\n    // Test 3: Long sequence of \"o \"\n    string music3;\n    for (int i = 0; i < 1000; ++i) music3 += \"o \";\n    parse_music(music3);\n\n    // Test 4: Medium repeated pattern\n    parse_music(\"o| .| o| .| o| .| o| .| o| .| o| .| o| .| o| .| o| .| o| .| o| .| o| .| o| .| o| .| o| .| o|\");\n\n    // Test 5: Mixed complex string\n    parse_music(\"o o o .| .| .| o| o| o| .| .| o| o| o o| o o| o o o o| o| .| .| .| o| o| o o| o| o o| o .|\");\n}"
    },
    {
        "task_id": "18",
        "entry_point": "how_many_times",
        "stress_test": "[{\"input\": \"['a'*9999 + 'b', 'a'*500]\", \"output\": null}, {\"input\": \"['a' * 10000, 'aa']\", \"output\": null}, {\"input\": \"['' + 'c'*9999, 'cc']\", \"output\": null}, {\"input\": \"['a'*5000 + 'b'*5000, 'a'*100]\", \"output\": null}, {\"input\": \"['abababab'*1250, 'abab']\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint how_many_times(string str,string substring){\nint out=0;\n    if (str.length()==0) return 0;\n    for (int i=0;i<=str.length()-substring.length();i++)\n    if (str.substr(i,substring.length())==substring)\n        out+=1;\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (how_many_times(\"\", \"x\") == 0);\n    assert (how_many_times(\"xyxyxyx\", \"x\") == 4);\n     assert (how_many_times(\"cacacacac\", \"cac\") == 4);\n    assert (how_many_times(\"john doe\", \"john\") == 1);\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\n#include<string>\nusing namespace std;\nint main(){\n    how_many_times(string(9999, 'a') + \"b\", string(500, 'a'));\n    how_many_times(string(10000, 'a'), \"aa\");\n    how_many_times(string(9999, 'c'), \"cc\");\n    how_many_times(string(5000, 'a') + string(5000, 'b'), string(100, 'a'));\n    how_many_times(string(1250 * 4, ' '), \"abab\");\n    {\n        string repeated;\n        for (int i = 0; i < 1250; ++i) repeated += \"abab\";\n        how_many_times(repeated, \"abab\");\n    }\n}"
    },
    {
        "task_id": "19",
        "entry_point": "sort_numbers",
        "stress_test": "[{\"input\": \"[' '.join(['three']*10000)]\", \"output\": null}, {\"input\": \"['one two three four five six seven eight nine zero one two three four five six seven eight nine zero one two three four five six seven eight nine zero one two three four five six seven eight nine zero one two three four five six seven eight nine zero one two three four five six seven eight nine zero one two three four five six seven eight nine zero']\", \"output\": null}, {\"input\": \"['one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one']\", \"output\": null}, {\"input\": \"['zero one two three four five six seven eight nine zero one two three four five six seven eight nine zero one two three four five six seven eight nine zero one two three four five six seven eight nine zero one two three four five six seven eight nine zero one two three four five six seven eight nine']\", \"output\": null}, {\"input\": \"['six seven six seven six seven six seven six seven six seven six seven six seven six seven six seven six seven six seven six seven six seven six seven six seven']\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring sort_numbers(string numbers){\nmap<string,int> tonum={{\"zero\",0},{\"one\",1},{\"two\",2},{\"three\",3},{\"four\",4},{\"five\",5},{\"six\",6},{\"seven\",7},{\"eight\",8},{\"nine\",9}};\n    map<int,string> numto={{0,\"zero\"},{1,\"one\"},{2,\"two\"},{3,\"three\"},{4,\"four\"},{5,\"five\"},{6,\"six\"},{7,\"seven\"},{8,\"eight\"},{9,\"nine\"}};\n    int count[10];\n    for (int i=0;i<10;i++)\n        count[i]=0;\n    string out=\"\",current=\"\";\n    if (numbers.length()>0) numbers=numbers+' ';\n    for (int i=0;i<numbers.length();i++)\n        if (numbers[i]==' ')\n        {\n            count[tonum[current]]+=1;\n            current=\"\";\n        }\n        else current+=numbers[i];\n    for (int i=0;i<10;i++)\n        for (int j=0;j<count[i];j++)\n            out=out+numto[i]+' ';\n    if (out.length()>0) out.pop_back();\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (sort_numbers(\"\") == \"\");\n    assert (sort_numbers(\"three\") == \"three\");\n    assert (sort_numbers(\"three five nine\") == \"three five nine\");\n     assert (sort_numbers(\"five zero four seven nine eight\") == \"zero four five seven eight nine\");\n      assert (sort_numbers(\"six five four three two one zero\") == \"zero one two three four five six\");\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    sort_numbers(std::string(10000, 'three'));\n    sort_numbers(\"one two three four five six seven eight nine zero one two three four five six seven eight nine zero one two three four five six seven eight nine zero one two three four five six seven eight nine zero one two three four five six seven eight nine zero one two three four five six seven eight nine zero one two three four five six seven eight nine zero\");\n    sort_numbers(\"one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one one\");\n    sort_numbers(\"zero one two three four five six seven eight nine zero one two three four five six seven eight nine zero one two three four five six seven eight nine zero one two three four five six seven eight nine zero one two three four five six seven eight nine zero one two three four five six seven eight nine\");\n    sort_numbers(\"six seven six seven six seven six seven six seven six seven six seven six seven six seven six seven six seven six seven six seven six seven six seven six seven\");\n}"
    },
    {
        "task_id": "20",
        "entry_point": "find_closest_elements",
        "stress_test": "[{\"input\": \"[list(range(1, 5001)) + [5000.1, 5000.2, 5000.3]]\", \"output\": null}, {\"input\": \"[[2.0] * 5000 + [2.0001]]\", \"output\": null}, {\"input\": \"[[1.0] * 5000 + [1.00001]]\", \"output\": null}, {\"input\": \"[[1.1] * 2500 + [1.2] * 2500 + [1.15]]\", \"output\": null}, {\"input\": \"[[2.0] * 4999 + [2.0001, 2.0002]]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> find_closest_elements(vector<float> numbers){\nvector<float> out={};\n    for (int i=0;i<numbers.size();i++)\n    for (int j=i+1;j<numbers.size();j++)\n        if (out.size()==0 or abs(numbers[i]-numbers[j])<abs(out[0]-out[1]))\n            out={numbers[i],numbers[j]};\n    if (out[0]>out[1])\n        out={out[1],out[0]};\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(find_closest_elements({1.0, 2.0, 3.9, 4.0, 5.0, 2.2}) , {3.9, 4.0}));\n    assert (issame(find_closest_elements({1.0, 2.0, 5.9, 4.0, 5.0}) , {5.0, 5.9} ));\n    assert (issame(find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.2}) ,{2.0, 2.2}));\n     assert (issame(find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.0}) ,{2.0, 2.0}));\n      assert (issame(find_closest_elements({1.1, 2.2, 3.1, 4.1, 5.1}) , {2.2, 3.1}));\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include <assert.h>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nbool issame(vector<float> a, vector<float> b) {\n    if (a.size() != b.size()) return false;\n    for (int i = 0; i < a.size(); ++i) {\n        if (abs(a[i] - b[i]) > 1e-4) return false;\n    }\n    return true;\n}\n\nint main() {\n    vector<float> v1;\n    for (int i = 1; i <= 5000; ++i) v1.push_back(i);\n    v1.push_back(5000.1f);\n    v1.push_back(5000.2f);\n    v1.push_back(5000.3f);\n    find_closest_elements(v1);\n\n    vector<float> v2(5000, 2.0f);\n    v2.push_back(2.0001f);\n    find_closest_elements(v2);\n\n    vector<float> v3(5000, 1.0f);\n    v3.push_back(1.00001f);\n    find_closest_elements(v3);\n\n    vector<float> v4(2500, 1.1f);\n    v4.insert(v4.end(), 2500, 1.2f);\n    v4.push_back(1.15f);\n    find_closest_elements(v4);\n\n    vector<float> v5(4999, 2.0f);\n    v5.push_back(2.0001f);\n    v5.push_back(2.0002f);\n    find_closest_elements(v5);\n}"
    },
    {
        "task_id": "21",
        "entry_point": "rescale_to_unit",
        "stress_test": "[{\"input\": \"[[-0.1 * i for i in range(1, 10001)] + [0.1 * i for i in range(1, 10001)]]\", \"output\": null}, {\"input\": \"[list(range(1, 10001))]\", \"output\": null}, {\"input\": \"[[i for i in range(10000)]]\", \"output\": null}, {\"input\": \"[[(-1.0) ** i * i for i in range(2, 10002)]]\", \"output\": null}, {\"input\": \"[[0.1 * i for i in range(1, 10001)]]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> rescale_to_unit(vector<float> numbers){\nfloat min=100000,max=-100000;\n    for (int i=0;i<numbers.size();i++)\n        {\n            if (numbers[i]<min) min=numbers[i];\n            if (numbers[i]>max) max=numbers[i];\n        }\n    for (int i=0;i<numbers.size();i++)\n        numbers[i]=(numbers[i]-min)/(max-min);\n    return numbers;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(rescale_to_unit({2.0, 49.9}) , {0.0, 1.0}));\n     assert (issame(rescale_to_unit({100.0, 49.9}) ,{1.0, 0.0})); \n     assert (issame(rescale_to_unit({1.0, 2.0, 3.0, 4.0, 5.0}) , {0.0, 0.25, 0.5, 0.75, 1.0}));\n    assert (issame(rescale_to_unit({2.0, 1.0, 5.0, 3.0, 4.0}) , {0.25, 0.0, 1.0, 0.5, 0.75}));\n     assert (issame(rescale_to_unit({12.0, 11.0, 15.0, 13.0, 14.0}) ,{0.25, 0.0, 1.0, 0.5, 0.75}));\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nbool issame(vector<float> a, vector<float> b) {\n    if (a.size() != b.size()) return false;\n    for (int i = 0; i < a.size(); ++i) {\n        if (abs(a[i] - b[i]) > 1e-4) return false;\n    }\n    return true;\n}\n\nint main() {\n    // [-0.1 * i for i in 1..10000] + [0.1 * i for i in 1..10000]\n    vector<float> v1;\n    for (int i = 1; i <= 10000; ++i) v1.push_back(-0.1f * i);\n    for (int i = 1; i <= 10000; ++i) v1.push_back(0.1f * i);\n    rescale_to_unit(v1);\n\n    // [1, 2, ..., 10000]\n    vector<float> v2;\n    for (int i = 1; i <= 10000; ++i) v2.push_back(static_cast<float>(i));\n    rescale_to_unit(v2);\n\n    // [0, 1, ..., 9999]\n    vector<float> v3;\n    for (int i = 0; i < 10000; ++i) v3.push_back(static_cast<float>(i));\n    rescale_to_unit(v3);\n\n    // [(-1)^i * i for i in 2..10001]\n    vector<float> v4;\n    for (int i = 2; i <= 10001; ++i) v4.push_back((i % 2 == 0 ? 1 : -1) * static_cast<float>(i));\n    rescale_to_unit(v4);\n\n    // [0.1 * i for i in 1..10000]\n    vector<float> v5;\n    for (int i = 1; i <= 10000; ++i) v5.push_back(0.1f * i);\n    rescale_to_unit(v5);\n}"
    },
    {
        "task_id": "22",
        "entry_point": "filter_integers",
        "stress_test": "[{\"input\": \"[[str(i) for i in range(5000)] + [i for i in range(5000)]]\", \"output\": null}, {\"input\": \"[['a'] * 5000 + [x for x in range(5000)]]\", \"output\": null}, {\"input\": \"[[i if i % 2 == 0 else str(i) for i in range(9999)]]\", \"output\": null}, {\"input\": \"[[i if i % 3 != 0 else str(i) for i in range(10000)]]\", \"output\": null}, {\"input\": \"[[1, 2, 3] * 3333 + [None, True, False]]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<boost/any.hpp>\n#include<list>\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> filter_integers(list_any values){\nlist_any::iterator it;\n    boost::any anyone;\n    vector<int> out;\n    for (it=values.begin();it!=values.end();it++)\n    {\n         anyone=*it;\n        if( anyone.type() == typeid(int) )\n           out.push_back(boost::any_cast<int>(*it));\n    }\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(filter_integers({}),{}));\n\n    assert (issame(filter_integers({4,  {},23.2, 9, string(\"adasd\")}) ,{4, 9}));\n    assert (issame(filter_integers({3, 'c', 3, 3, 'a', 'b'}) ,{3, 3, 3}));\n}",
        "cpp_stress_test": "#include <boost/any.hpp>\n#include <list>\n#include <vector>\n#include <string>\nusing namespace std;\ntypedef list<boost::any> list_any;\nint main() {\n    list_any v1;\n    for (int i = 0; i < 5000; ++i) v1.push_back(to_string(i));\n    for (int i = 0; i < 5000; ++i) v1.push_back(i);\n    filter_integers(v1);\n\n    list_any v2;\n    for (int i = 0; i < 5000; ++i) v2.push_back(string(\"a\"));\n    for (int i = 0; i < 5000; ++i) v2.push_back(i);\n    filter_integers(v2);\n\n    list_any v3;\n    for (int i = 0; i < 9999; ++i)\n        v3.push_back((i % 2 == 0) ? boost::any(i) : boost::any(to_string(i)));\n    filter_integers(v3);\n\n    list_any v4;\n    for (int i = 0; i < 10000; ++i)\n        v4.push_back((i % 3 != 0) ? boost::any(i) : boost::any(to_string(i)));\n    filter_integers(v4);\n\n    list_any v5;\n    for (int i = 0; i < 3333; ++i) { v5.push_back(1); v5.push_back(2); v5.push_back(3); }\n    v5.push_back(boost::any());\n    v5.push_back(true);\n    v5.push_back(false);\n    filter_integers(v5);\n    return 0;\n}"
    },
    {
        "task_id": "23",
        "entry_point": "strlen",
        "stress_test": "[{\"input\": \"['abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890' * 100]\", \"output\": null}, {\"input\": \"['\\ud83d\\ude00' * 1000]\", \"output\": null}, {\"input\": \"['\\\\n'*1000]\", \"output\": null}, {\"input\": \"[' '*10000]\", \"output\": null}, {\"input\": \"['a' * 5000 + 'b' * 5000]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint strlen(string str){\nreturn str.length();\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (strlen(\"\") == 0);\n    assert (strlen(\"x\") == 1);\n     assert (strlen(\"asdasnakj\") == 9);\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\n#include<string>\nint main(){\n    std::string test1(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890\");\n    std::string longInput1 = \"\";\n    for (int i = 0; i < 100; i++) longInput1 += test1;\n    std::string emojiInput;\n    for (int i = 0; i < 1000; i++) emojiInput += \"\\xF0\\x9F\\x98\\x80\";\n    std::string newlineInput;\n    for (int i = 0; i < 1000; i++) newlineInput += \"\\n\";\n    std::string spaceInput;\n    for (int i = 0; i < 10000; i++) spaceInput += \" \";\n    std::string mixedInput;\n    for (int i = 0; i < 5000; i++) mixedInput += \"a\";\n    for (int i = 0; i < 5000; i++) mixedInput += \"b\";\n}"
    },
    {
        "task_id": "24",
        "entry_point": "largest_divisor",
        "stress_test": "[{\"input\": \"[10007]\", \"output\": null}, {\"input\": \"[9973]\", \"output\": null}, {\"input\": \"[9991]\", \"output\": null}, {\"input\": \"[8887]\", \"output\": null}, {\"input\": \"[7927]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_divisor(int n){\nfor (int i=2;i*i<=n;i++)\n        if (n%i==0) return  n/i;\n    return 1;\n\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (largest_divisor(3) == 1);\n    assert (largest_divisor(7) == 1);\n    assert (largest_divisor(10) == 5);\n    assert (largest_divisor(100) == 50);\n    assert (largest_divisor(49) == 7);\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\nint main(){largest_divisor(10007);largest_divisor(9973);largest_divisor(9991);largest_divisor(8887);largest_divisor(7927);}"
    },
    {
        "task_id": "25",
        "entry_point": "factorize",
        "stress_test": "[{\"input\": \"[7919 * 7873]\", \"output\": null}, {\"input\": \"[6700417]\", \"output\": null}, {\"input\": \"[999983]\", \"output\": null}, {\"input\": \"[997 * 991]\", \"output\": null}, {\"input\": \"[31337]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\nvector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(factorize(2) , {2}));\n    assert (issame(factorize(4) , {2, 2}));\n    assert (issame(factorize(8) , {2, 2, 2}));\n     assert (issame(factorize(3 * 19) , {3, 19}));\n    assert (issame(factorize(3 * 19 * 3 * 19) , {3, 3, 19, 19})); \n    assert (issame(factorize(3 * 19 * 3 * 19 * 3 * 19) , {3, 3, 3, 19, 19, 19})); \n    assert (issame(factorize(3 * 19 * 19 * 19) , {3, 19, 19, 19})); \n    assert (issame(factorize(3 * 2 * 3) , {2, 3, 3}));\n}\n",
        "cpp_stress_test": "int main() { factorize(7919 * 7873); factorize(6700417); factorize(999983); factorize(997 * 991); factorize(31337); }"
    },
    {
        "task_id": "26",
        "entry_point": "remove_duplicates",
        "stress_test": "[{\"input\": \"[[i for i in range(10000)] + [i for i in range(9999, 5000, -1)]]\", \"output\": null}, {\"input\": \"[[0, 1] * 5000 + [2, 3] * 2500]\", \"output\": null}, {\"input\": \"[[i % 1000 for i in range(10000)]]\", \"output\": null}, {\"input\": \"[[i for i in range(5000)] + [i for i in range(2500, 7500)]]\", \"output\": null}, {\"input\": \"[list(range(1, 5000)) + list(range(2500, 7500))]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> remove_duplicates(vector<int> numbers){\nvector<int> out={};\n    vector<int> has1={};\n    vector<int> has2={};\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (find(has2.begin(),has2.end(),numbers[i])!=has2.end()) continue;\n        if (find(has1.begin(),has1.end(),numbers[i])!=has1.end())\n        {\n\n            has2.push_back(numbers[i]);\n        }\n        else has1.push_back(numbers[i]);\n    }\n    for (int i=0;i<numbers.size();i++)\n    if (find(has2.begin(),has2.end(),numbers[i])==has2.end())\n        out.push_back(numbers[i]);\n    return out;\n\n\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(remove_duplicates({}) , {}));\n     assert (issame(remove_duplicates({1, 2, 3, 4}) , {1, 2, 3, 4}));\n      assert (issame(remove_duplicates({1, 2, 3, 2, 4, 3, 5}) , {1, 4, 5}));\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include <vector>\nusing namespace std;\n\nint main() {\n    // [i for i in range(10000)] + [i for i in range(9999, 5000, -1)]\n    vector<int> v1;\n    for (int i = 0; i < 10000; ++i) v1.push_back(i);\n    for (int i = 9999; i > 5000; --i) v1.push_back(i);\n    remove_duplicates(v1);\n\n    // [0, 1] * 5000 + [2, 3] * 2500\n    vector<int> v2;\n    for (int i = 0; i < 5000; ++i) { v2.push_back(0); v2.push_back(1); }\n    for (int i = 0; i < 2500; ++i) { v2.push_back(2); v2.push_back(3); }\n    remove_duplicates(v2);\n\n    // [i % 1000 for i in range(10000)]\n    vector<int> v3;\n    for (int i = 0; i < 10000; ++i) v3.push_back(i % 1000);\n    remove_duplicates(v3);\n\n    // [i for i in range(5000)] + [i for i in range(2500, 7500)]\n    vector<int> v4;\n    for (int i = 0; i < 5000; ++i) v4.push_back(i);\n    for (int i = 2500; i < 7500; ++i) v4.push_back(i);\n    remove_duplicates(v4);\n\n    // list(range(1, 5000)) + list(range(2500, 7500))\n    vector<int> v5;\n    for (int i = 1; i < 5000; ++i) v5.push_back(i);\n    for (int i = 2500; i < 7500; ++i) v5.push_back(i);\n    remove_duplicates(v5);\n}"
    },
    {
        "task_id": "27",
        "entry_point": "flip_case",
        "stress_test": "[{\"input\": \"['!@#$%^&*()_+-=[]{}|;:,.<>?`~' * 500]\", \"output\": null}, {\"input\": \"['a' * 10000]\", \"output\": null}, {\"input\": \"['abcdefghijklmnopqrstuvwxyz' * 384]\", \"output\": null}, {\"input\": \"[' '.join(['aBcDeFgHiJkL' for _ in range(833)])]\", \"output\": null}, {\"input\": \"['Aa' * 5000]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring filp_case(string str){\nstring out=\"\";\n    for (int i=0;i<str.length();i++)\n    {\n        char w=str[i];\n        if (w>=97 and w<=122) {w-=32;}\n        else\n            if (w>=65 and w<=90){ w+=32;}\n        out=out+w;\n    }\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (filp_case(\"\") == \"\");\n    assert (filp_case(\"Hello!\") == \"hELLO!\");\n    assert (filp_case(\"These violent delights have violent ends\") == \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\");\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include <string>\nusing namespace std;\n\nint main() {\n    // '!@#$%^&*()_+-=[]{}|;:,.<>?`~' * 500\n    string symbols;\n    for (int i = 0; i < 500; ++i) symbols += \"!@#$%^&*()_+-=[]{}|;:,.<>?`~\";\n    filp_case(symbols);\n\n    // 'a' * 10000\n    string all_a(10000, 'a');\n    filp_case(all_a);\n\n    // 'abcdefghijklmnopqrstuvwxyz' * 384\n    string alphabet;\n    for (int i = 0; i < 384; ++i) alphabet += \"abcdefghijklmnopqrstuvwxyz\";\n    filp_case(alphabet);\n\n    // ' '.join(['aBcDeFgHiJkL' for _ in range(833)])\n    string mixed;\n    for (int i = 0; i < 833; ++i) {\n        mixed += \"aBcDeFgHiJkL\";\n        if (i != 832) mixed += ' ';\n    }\n    filp_case(mixed);\n\n    // 'Aa' * 5000\n    string alternating;\n    for (int i = 0; i < 5000; ++i) alternating += \"Aa\";\n    filp_case(alternating);\n}"
    },
    {
        "task_id": "28",
        "entry_point": "concatenate",
        "stress_test": "[{\"input\": \"[['a', 'bb', 'ccc', 'dddd'] * 2500]\", \"output\": null}, {\"input\": \"[['a', 'b', 'c'] * 3333 + ['d']]\", \"output\": null}, {\"input\": \"[['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'] * 1000]\", \"output\": null}, {\"input\": \"[['a', 'b'] * 4999 + ['c']]\", \"output\": null}, {\"input\": \"[[''.join(['a', 'b'])] * 5000]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring concatenate(vector<string> strings){\nstring out=\"\";\n    for (int i=0;i<strings.size();i++)\n        out=out+strings[i];\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (concatenate({}) == \"\");\n     assert (concatenate({\"x\", \"y\", \"z\"}) == \"xyz\");\n    assert (concatenate({\"x\", \"y\", \"z\", \"w\", \"k\"}) == \"xyzwk\");\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include <string>\n#include <vector>\nusing namespace std;\n\nint main() {\n    // ['a', 'bb', 'ccc', 'dddd'] * 2500\n    vector<string> v1;\n    for (int i = 0; i < 2500; ++i) {\n        v1.push_back(\"a\");\n        v1.push_back(\"bb\");\n        v1.push_back(\"ccc\");\n        v1.push_back(\"dddd\");\n    }\n    concatenate(v1);\n\n    // ['a', 'b', 'c'] * 3333 + ['d']\n    vector<string> v2;\n    for (int i = 0; i < 3333; ++i) {\n        v2.push_back(\"a\");\n        v2.push_back(\"b\");\n        v2.push_back(\"c\");\n    }\n    v2.push_back(\"d\");\n    concatenate(v2);\n\n    // ['a'..'j'] * 1000\n    vector<string> v3;\n    for (int i = 0; i < 1000; ++i) {\n        v3.push_back(\"a\"); v3.push_back(\"b\"); v3.push_back(\"c\"); v3.push_back(\"d\");\n        v3.push_back(\"e\"); v3.push_back(\"f\"); v3.push_back(\"g\"); v3.push_back(\"h\");\n        v3.push_back(\"i\"); v3.push_back(\"j\");\n    }\n    concatenate(v3);\n\n    // ['a', 'b'] * 4999 + ['c']\n    vector<string> v4;\n    for (int i = 0; i < 4999; ++i) {\n        v4.push_back(\"a\");\n        v4.push_back(\"b\");\n    }\n    v4.push_back(\"c\");\n    concatenate(v4);\n\n    // ['ab'] * 5000\n    vector<string> v5(5000, \"ab\");\n    concatenate(v5);\n}"
    },
    {
        "task_id": "29",
        "entry_point": "filter_by_prefix",
        "stress_test": "[{\"input\": \"[['a'*i + 'b'*(9999-i) for i in range(10000)], 'a'*5000 + 'b'*4999]\", \"output\": null}, {\"input\": \"[['prefix_' + str(i) for i in range(10000)], 'prefix_']\", \"output\": null}, {\"input\": \"[['' for _ in range(5000)] + ['a' for _ in range(5000)], '']\", \"output\": null}, {\"input\": \"[['' for _ in range(10000)], '']\", \"output\": null}, {\"input\": \"[['prefix_' + str(i) for i in range(5000)] + ['abc_' + str(i) for i in range(5000)], 'abc_']\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> filter_by_prefix(vector<string> strings, string prefix){\nvector<string> out={};\n    for (int i=0;i<strings.size();i++)\n        if (strings[i].substr(0,prefix.length())==prefix) out.push_back(strings[i]);\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(filter_by_prefix({}, \"john\") , {}));\n    assert (issame(filter_by_prefix({\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"}, \"xxx\") , {\"xxx\", \"xxxAAA\", \"xxx\"}));\n\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include <vector>\n#include <string>\nusing namespace std;\n\nint main() {\n    // [['a'*i + 'b'*(9999-i) for i in range(10000)], 'a'*5000 + 'b'*4999]\n    vector<string> v1;\n    for (int i = 0; i < 10000; ++i) {\n        v1.push_back(string(i, 'a') + string(9999 - i, 'b'));\n    }\n    filter_by_prefix(v1, string(5000, 'a') + string(4999, 'b'));\n\n    // [['prefix_' + str(i) for i in range(10000)], 'prefix_']\n    vector<string> v2;\n    for (int i = 0; i < 10000; ++i) {\n        v2.push_back(\"prefix_\" + to_string(i));\n    }\n    filter_by_prefix(v2, \"prefix_\");\n\n    // [['' for _ in range(5000)] + ['a' for _ in range(5000)], '']\n    vector<string> v3(5000, \"\");\n    v3.insert(v3.end(), 5000, \"a\");\n    filter_by_prefix(v3, \"\");\n\n    // [['' for _ in range(10000)], '']\n    vector<string> v4(10000, \"\");\n    filter_by_prefix(v4, \"\");\n\n    // [['prefix_' + str(i) for i in range(5000)] + ['abc_' + str(i) for i in range(5000)], 'abc_']\n    vector<string> v5;\n    for (int i = 0; i < 5000; ++i) v5.push_back(\"prefix_\" + to_string(i));\n    for (int i = 0; i < 5000; ++i) v5.push_back(\"abc_\" + to_string(i));\n    filter_by_prefix(v5, \"abc_\");\n}"
    },
    {
        "task_id": "30",
        "entry_point": "get_positive",
        "stress_test": "[{\"input\": \"[[i if i % 5 != 0 else -i for i in range(1, 10001)]]\", \"output\": null}, {\"input\": \"[[i if (i % 7 != 0 and i % 11 != 0) else -i for i in range(1, 10001)]]\", \"output\": null}, {\"input\": \"[[5]*5000 + [-3]*5000]\", \"output\": null}, {\"input\": \"[[(-1)**i * i for i in range(1, 10001)]]\", \"output\": null}, {\"input\": \"[[i if i % 2 == 0 else -i for i in range(1, 10001)]]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> get_positive(vector<float> l){\nvector<float> out={};\n    for (int i=0;i<l.size();i++)\n        if (l[i]>0) out.push_back(l[i]);\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(get_positive({-1, -2, 4, 5, 6}) , {4, 5, 6} ));\n    assert (issame(get_positive({5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10}) , {5, 3, 2, 3, 3, 9, 123, 1}));\n     assert (issame(get_positive({-1, -2}) , {} ));\n     assert (issame(get_positive({}) , {}));\n}\n",
        "cpp_stress_test": "#include <vector>\nusing namespace std;\n\nint main() {\n    // [i if i % 5 != 0 else -i for i in range(1, 10001)]\n    vector<float> v1;\n    for (int i = 1; i <= 10000; ++i)\n        v1.push_back((i % 5 != 0) ? i : -i);\n    get_positive(v1);\n\n    // [i if (i % 7 != 0 and i % 11 != 0) else -i for i in range(1, 10001)]\n    vector<float> v2;\n    for (int i = 1; i <= 10000; ++i)\n        v2.push_back((i % 7 != 0 && i % 11 != 0) ? i : -i);\n    get_positive(v2);\n\n    // [5]*5000 + [-3]*5000\n    vector<float> v3(5000, 5);\n    v3.insert(v3.end(), 5000, -3);\n    get_positive(v3);\n\n    // [(-1)^i * i for i in range(1, 10001)]\n    vector<float> v4;\n    for (int i = 1; i <= 10000; ++i)\n        v4.push_back((i % 2 == 0 ? 1 : -1) * i);\n    get_positive(v4);\n\n    // [i if i % 2 == 0 else -i for i in range(1, 10001)]\n    vector<float> v5;\n    for (int i = 1; i <= 10000; ++i)\n        v5.push_back((i % 2 == 0) ? i : -i);\n    get_positive(v5);\n}"
    },
    {
        "task_id": "31",
        "entry_point": "is_prime",
        "stress_test": "[{\"input\": \"[999983]\", \"output\": null}, {\"input\": \"[999979]\", \"output\": null}, {\"input\": \"[100003]\", \"output\": null}, {\"input\": \"[99991]\", \"output\": null}, {\"input\": \"[10111]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_prime(long long n){\nif (n<2) return false;\n    for (long long i=2;i*i<=n;i++)\n        if (n%i==0) return false;\n    return true;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_prime(6) == false);\n    assert (is_prime(101) == true);\n    assert (is_prime(11) == true);\n    assert (is_prime(13441) == true);\n    assert (is_prime(61) == true);\n    assert (is_prime(4) == false);\n    assert (is_prime(1) == false);\n    assert (is_prime(5) == true);\n    assert (is_prime(11) == true);\n    assert (is_prime(17) == true);\n    assert (is_prime(5 * 17) == false);\n    assert (is_prime(11 * 7) == false);\n    assert (is_prime(13441 * 19) == false);\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\nint main(){is_prime(999983);is_prime(999979);is_prime(100003);is_prime(99991);is_prime(10111);}"
    },
    {
        "task_id": "32",
        "entry_point": "find_zero",
        "stress_test": "[{\"input\": \"[[i * (-1) ** i for i in range(10000)]]\", \"output\": null}, {\"input\": \"[[0] * 9998 + [1, -1]]\", \"output\": null}, {\"input\": \"[[1] * 10000]\", \"output\": null}, {\"input\": \"[[1, -1] * 5000]\", \"output\": null}, {\"input\": \"[list(range(0, 10000, 2))]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\ndouble poly(vector<double> xs, double x){\n    double sum=0;\n    int i;\n    for (i=0;i<xs.size();i++)\n    {\n        sum+=xs[i]*pow(x,i);\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs){\ndouble ans=0;\n    double value;\n    value=poly(xs,ans);\n    while (abs(value)>1e-6)\n    {\n        double driv=0;\n        for (int i=1;i<xs.size();i++)\n        {\n            driv+=xs[i]*pow(ans,i-1)*i;\n        }\n        ans=ans-value/driv;\n        value=poly(xs,ans);\n    }\n    return ans;\n\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n   \n    double solution;\n    int ncoeff;\n    for (int i=0;i<100;i++)\n    {\n        ncoeff = 2 * (1+rand()%4);\n        vector<double> coeffs = {};\n        for (int j=0;j<ncoeff;j++)\n        {\n            double coeff = -10+rand()%21;\n            if (coeff == 0) coeff = 1;\n            coeffs.push_back(coeff);\n        }\n        \n        solution = find_zero(coeffs);\n        assert (abs(poly(coeffs, solution))< 1e-3);\n    }\n}\n",
        "cpp_stress_test": "#include<vector>\nusing namespace std;\nint main(){vector<double> v1;for(int i=0;i<10000;++i)v1.push_back(i*((i%2==0)?1:-1));find_zero(v1);vector<double> v2(9998,0);v2.push_back(1);v2.push_back(-1);find_zero(v2);vector<double> v3(10000,1);find_zero(v3);vector<double> v4;for(int i=0;i<5000;++i){v4.push_back(1);v4.push_back(-1);}find_zero(v4);vector<double> v5;for(int i=0;i<10000;i+=2)v5.push_back(i);find_zero(v5);return 0;}"
    },
    {
        "task_id": "33",
        "entry_point": "sort_third",
        "stress_test": "[{\"input\": \"[[random.randint(-1000, 1000) for _ in range(10000)]]\", \"output\": null}, {\"input\": \"[[j for i in range(100) for j in range(100)]]\", \"output\": null}, {\"input\": \"[[2, 3, 5, 7, 11, 13, 17, 19, 23, 29] * (10**3)]\", \"output\": null}, {\"input\": \"[[random.choice([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) for _ in range(9999)]]\", \"output\": null}, {\"input\": \"[[i % 7 for i in range(10**4)]]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_third(vector<int> l){\nvector<int> third={};\n    int i;\n    for (i=0;i*3<l.size();i++)\n        third.push_back(l[i*3]);\n    \n    sort(third.begin(),third.end());\n\n    vector<int> out={};\n    for (i=0;i<l.size();i++)\n    {\n        if (i%3==0) {out.push_back(third[i/3]);}\n        else out.push_back(l[i]);\n    }\n    return out;\n\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sort_third({1, 2, 3}) , sort_third({1, 2, 3})));\n    assert (issame(sort_third({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}) , sort_third({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})));\n    assert (issame(sort_third({5, 8, -12, 4, 23, 2, 3, 11, 12, -10}) , sort_third({5, 8, -12, 4, 23, 2, 3, 11, 12, -10})));\n    assert (issame(sort_third({5, 6, 3, 4, 8, 9, 2}) , {2, 6, 3, 4, 8, 9, 5}));\n    assert (issame(sort_third({5, 8, 3, 4, 6, 9, 2}) , {2, 8, 3, 4, 6, 9, 5}));\n    assert (issame(sort_third({5, 6, 9, 4, 8, 3, 2}) , {2, 6, 9, 4, 8, 3, 5}));\n    assert (issame(sort_third({5, 6, 3, 4, 8, 9, 2, 1}) , {2, 6, 3, 4, 8, 9, 5, 1}));\n}\n",
        "cpp_stress_test": "#include <vector>\n#include <cstdlib>\n#include <ctime>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    srand(time(0));\n\n    // [random.randint(-1000, 1000) for _ in range(10000)]\n    vector<int> v1;\n    for (int i = 0; i < 10000; ++i) v1.push_back(rand() % 2001 - 1000);\n    sort_third(v1);\n\n    // [j for i in range(100) for j in range(100)]\n    vector<int> v2;\n    for (int i = 0; i < 100; ++i)\n        for (int j = 0; j < 100; ++j)\n            v2.push_back(j);\n    sort_third(v2);\n\n    // [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] * 1000\n    vector<int> primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\n    vector<int> v3;\n    for (int i = 0; i < 1000; ++i)\n        v3.insert(v3.end(), primes.begin(), primes.end());\n    sort_third(v3);\n\n    // [random.choice([09]) for _ in range(9999)]\n    vector<int> v4;\n    for (int i = 0; i < 9999; ++i)\n        v4.push_back(rand() % 10);\n    sort_third(v4);\n\n    // [i % 7 for i in range(10000)]\n    vector<int> v5;\n    for (int i = 0; i < 10000; ++i)\n        v5.push_back(i % 7);\n    sort_third(v5);\n}"
    },
    {
        "task_id": "34",
        "entry_point": "unique",
        "stress_test": "[{\"input\": \"[list(range(10000, 0, -1)) + list(range(10000))]\", \"output\": null}, {\"input\": \"[list(range(10000)) + list(range(9999, -1, -1))]\", \"output\": null}, {\"input\": \"[[-10000, 10000] + [i for i in range(-5000, 5000)]]\", \"output\": null}, {\"input\": \"[[i for i in range(-5000, 5000) if i % 2 == 0] + [i for i in range(-5000, 5000) if i % 2 != 0]]\", \"output\": null}, {\"input\": \"[[2**i % 10007 for i in range(10000)]]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> unique(vector<int> l){\nvector<int> out={};\n    for (int i=0;i<l.size();i++)\n        if (find(out.begin(),out.end(),l[i])==out.end())\n            out.push_back(l[i]);\n    sort(out.begin(),out.end());\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(unique({5, 3, 5, 2, 3, 3, 9, 0, 123}) , {0, 2, 3, 5, 9, 123}));\n}\n",
        "cpp_stress_test": "#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    // list(range(10000, 0, -1)) + list(range(10000))\n    vector<int> v1;\n    for (int i = 10000; i > 0; --i) v1.push_back(i);\n    for (int i = 0; i < 10000; ++i) v1.push_back(i);\n    unique(v1);\n\n    // list(range(10000)) + list(range(9999, -1, -1))\n    vector<int> v2;\n    for (int i = 0; i < 10000; ++i) v2.push_back(i);\n    for (int i = 9999; i >= 0; --i) v2.push_back(i);\n    unique(v2);\n\n    // [-10000, 10000] + [i for i in range(-5000, 5000)]\n    vector<int> v3 = {-10000, 10000};\n    for (int i = -5000; i < 5000; ++i) v3.push_back(i);\n    unique(v3);\n\n    // [even from -5000 to 4998] + [odd from -4999 to 4999]\n    vector<int> v4;\n    for (int i = -5000; i < 5000; ++i)\n        if (i % 2 == 0) v4.push_back(i);\n    for (int i = -5000; i < 5000; ++i)\n        if (i % 2 != 0) v4.push_back(i);\n    unique(v4);\n\n    // [2^i % 10007 for i in range(10000)]\n    vector<int> v5;\n    for (int i = 0; i < 10000; ++i)\n        v5.push_back((int)pow(2, i) % 10007);\n    unique(v5);\n}"
    },
    {
        "task_id": "35",
        "entry_point": "max_element",
        "stress_test": "[{\"input\": \"[[i * 0.5 for i in range(-10**4, 10**4)]]\", \"output\": null}, {\"input\": \"[[float(i) for i in range(10**4)]]\", \"output\": null}, {\"input\": \"[[0.1 * i for i in range(1, 10**4)]]\", \"output\": null}, {\"input\": \"[[i / (i+1) for i in range(1, 10**4)]]\", \"output\": null}, {\"input\": \"[[i**2 for i in range(1, 10**4)]]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat max_element(vector<float> l){\nfloat max=-10000;\n  for (int i=0;i<l.size();i++)\n  if (max<l[i]) max=l[i];\n  return max;\n\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (abs(max_element({1, 2, 3})- 3)<1e-4);\n    assert (abs(max_element({5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10})- 124)<1e-4);\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include <vector>\nint main() {\n    std::vector<std::vector<double>> stress_tests = {\n        std::vector<double>(20000), std::vector<double>(10000), std::vector<double>(9999), std::vector<double>(9999), std::vector<double>(9999)\n    };\n    for (int i = 0; i < 20000; ++i) { stress_tests[0][i] = (i - 10000) * 0.5; }\n    for (int i = 0; i < 10000; ++i) { stress_tests[1][i] = static_cast<double>(i); }\n    for (int i = 0; i < 9999; ++i) { stress_tests[2][i] = 0.1 * (i + 1); }\n    for (int i = 0; i < 9999; ++i) { stress_tests[3][i] = static_cast<double>(i + 1) / (i + 2); }\n    for (int i = 0; i < 9999; ++i) { stress_tests[4][i] = (i + 1) * (i + 1); }\n}"
    },
    {
        "task_id": "36",
        "entry_point": "fizz_buzz",
        "stress_test": "[{\"input\": \"[13579]\", \"output\": null}, {\"input\": \"[10001]\", \"output\": null}, {\"input\": \"[9999]\", \"output\": null}, {\"input\": \"[9998]\", \"output\": null}, {\"input\": \"[9898]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\nint count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q=i;\n        while (q>0)\n        {\n            if (q%10==7) count+=1;\n            q=q/10;\n        }\n    } \n    return count;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (fizz_buzz(50) == 0);\n    assert (fizz_buzz(78) == 2);\n    assert (fizz_buzz(79) == 3);\n    assert (fizz_buzz(100) == 3);\n    assert (fizz_buzz(200) == 6);\n    assert (fizz_buzz(4000) == 192);\n    assert (fizz_buzz(10000) == 639);\n    assert (fizz_buzz(100000) == 8026);\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include <assert.h>\nint main() { fizz_buzz(13579); fizz_buzz(10001); fizz_buzz(9999); fizz_buzz(9998); fizz_buzz(9898); }"
    },
    {
        "task_id": "37",
        "entry_point": "sort_even",
        "stress_test": "[{\"input\": \"[[9999 - i if i % 3 == 0 else i ** 0.5 for i in range(10000)]]\", \"output\": null}, {\"input\": \"[[2**i % 10000 for i in range(10000)]]\", \"output\": null}, {\"input\": \"[[i * (-1)**i for i in range(10000)]]\", \"output\": null}, {\"input\": \"[[(-1)**i * i for i in range(10000)]]\", \"output\": null}, {\"input\": \"[[(-1000)**(i % 2) for i in range(9999)]]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<float> sort_even(vector<float> l){\nvector<float> out={};\n    vector<float> even={};\n    for (int i=0;i*2<l.size();i++)\n        even.push_back(l[i*2]);\n    sort(even.begin(),even.end());\n    for (int i=0;i<l.size();i++)\n    {\n        if (i%2==0) out.push_back(even[i/2]);\n        if (i%2==1) out.push_back(l[i]);\n    }\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sort_even({1, 2, 3}), {1, 2, 3}));\n    assert (issame(sort_even({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}) , {-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123}));\n    assert (issame(sort_even({5, 8, -12, 4, 23, 2, 3, 11, 12, -10}) , {-12, 8, 3, 4, 5, 2, 12, 11, 23, -10}));\n}\n",
        "cpp_stress_test": "#include <vector>\n#include <cmath>\nint main() {\n    std::vector<double> test1(10000); for (int i = 0; i < 10000; ++i) test1[i] = (i % 3 == 0) ? 9999 - i : std::sqrt(i);\n    std::vector<int> test2(10000); for (int i = 0; i < 10000; ++i) test2[i] = (int)std::pow(2, i) % 10000;\n    std::vector<int> test3(10000); for (int i = 0; i < 10000; ++i) test3[i] = i * (i % 2 == 0 ? 1 : -1);\n    std::vector<int> test4(10000); for (int i = 0; i < 10000; ++i) test4[i] = (i % 2 == 0 ? 1 : -1) * i;\n    std::vector<int> test5(9999); for (int i = 0; i < 9999; ++i) test5[i] = (i % 2 == 0) ? 1 : -1000;\n}"
    },
    {
        "task_id": "38",
        "entry_point": "decode_cyclic",
        "stress_test": "[{\"input\": \"[''.join(['xyz' for _ in range(3333)])]\", \"output\": null}, {\"input\": \"[''.join(['1234567890' for _ in range(1000)]) + '12345']\", \"output\": null}, {\"input\": \"[''.join(['hello' for _ in range(2000)]) + 'hel']\", \"output\": null}, {\"input\": \"[''.join([''.join(['a' if j%2==0 else 'b' for j in range(4)]) for i in range(2500)])]\", \"output\": null}, {\"input\": \"[''.join(['abc' for _ in range(3333)]) + 'de']\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encode_cyclic(string s){ \n    int l=s.length();\n    int num=(l+2)/3;\n    string x,output;\n    int i;\n    for (i=0;i*3<l;i++)\n    {\n        x=s.substr(i*3,3);\n        if (x.length()==3) x=x.substr(1)+x[0];\n        output=output+x;\n    }\n    return output;\n}\n\n\nstring decode_cyclic(string s){ \n int l=s.length();\n    int num=(l+2)/3;\n    string x,output;\n    int i;\n    for (i=0;i*3<l;i++)\n    {\n        x=s.substr(i*3,3);\n        if (x.length()==3) x=x[2]+x.substr(0,2);\n        output=output+x;\n    }\n    return output;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    \n    for (int i=0;i<100;i++)\n    {\n        int l=10+rand()%11;\n        string str=\"\";\n        for (int j=0;j<l;j++)\n        {\n            char chr=97+rand()%26;\n            str+=chr;\n        }\n\n        string encoded_str = encode_cyclic(str);\n        assert (decode_cyclic(encoded_str) == str);\n    }\n}\n",
        "cpp_stress_test": "#include<string>\nusing namespace std;\nint main(){string s1;for(int i=0;i<3333;++i)s1+=\"xyz\";decode_cyclic(s1);string s2;for(int i=0;i<1000;++i)s2+=\"1234567890\";s2+=\"12345\";decode_cyclic(s2);string s3;for(int i=0;i<2000;++i)s3+=\"hello\";s3+=\"hel\";decode_cyclic(s3);string s4;for(int i=0;i<2500;++i)for(int j=0;j<4;++j)s4+=((j%2==0)?'a':'b');decode_cyclic(s4);string s5;for(int i=0;i<3333;++i)s5+=\"abc\";s5+=\"de\";decode_cyclic(s5);return 0;}"
    },
    {
        "task_id": "39",
        "entry_point": "prime_fib",
        "stress_test": "[{\"input\": \"[11]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\nint f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (prime_fib(1) == 2);\n    assert (prime_fib(2) == 3);\n    assert (prime_fib(3) == 5);\n    assert (prime_fib(4) == 13);\n    assert (prime_fib(5) == 89);\n    assert (prime_fib(6) == 233);\n    assert (prime_fib(7) == 1597);\n    assert (prime_fib(8) == 28657);\n    assert (prime_fib(9) == 514229);\n    assert (prime_fib(10) == 433494437);\n}\n",
        "cpp_stress_test": "#include <cassert>\nint main() {\n int result = prime_fib(11);\n    // Optionally verify the known result (next after 433494437)\n    // assert(result == 2971215073); // Uncomment if verification is desired\n    (void)result; // suppress unused warning if assert is off\n}"
    },
    {
        "task_id": "40",
        "entry_point": "triples_sum_to_zero",
        "stress_test": "[{\"input\": \"[list(range(-5000, 5000))]\", \"output\": null}, {\"input\": \"[list(range(-100, 100)) * 50]\", \"output\": null}, {\"input\": \"[list(range(-500, 500)) + [1000, -500, -500]]\", \"output\": null}, {\"input\": \"[list(range(-499, 500)) + [1000, -501, 1]]\", \"output\": null}, {\"input\": \"[list(range(-1000, 1000, 3))]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool triples_sum_to_zero(vector<int> l){\nfor (int i=0;i<l.size();i++)\n    for (int j=i+1;j<l.size();j++)\n    for (int k=j+1;k<l.size();k++)\n        if (l[i]+l[j]+l[k]==0) return true;\n    return false;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (triples_sum_to_zero({1, 3, 5, 0}) == false);\n    assert (triples_sum_to_zero({1, 3, 5, -1}) == false);\n    assert (triples_sum_to_zero({1, 3, -2, 1}) == true);\n    assert (triples_sum_to_zero({1, 2, 3, 7}) == false);\n    assert (triples_sum_to_zero({1, 2, 5, 7}) == false);\n    assert (triples_sum_to_zero({2, 4, -5, 3, 9, 7}) == true);\n    assert (triples_sum_to_zero({1}) == false);\n    assert (triples_sum_to_zero({1, 3, 5, -100}) == false);\n    assert (triples_sum_to_zero({100, 3, 5, -100}) == false);\n}\n",
        "cpp_stress_test": "#include <vector>\nusing namespace std;\n\nint main() {\n    // list(range(-5000, 5000))\n    vector<int> v1;\n    for (int i = -5000; i < 5000; ++i) v1.push_back(i);\n    triples_sum_to_zero(v1);\n\n    // list(range(-100, 100)) * 50\n    vector<int> v2;\n    for (int i = 0; i < 50; ++i)\n        for (int j = -100; j < 100; ++j)\n            v2.push_back(j);\n    triples_sum_to_zero(v2);\n\n    // list(range(-500, 500)) + [1000, -500, -500]\n    vector<int> v3;\n    for (int i = -500; i < 500; ++i) v3.push_back(i);\n    v3.push_back(1000);\n    v3.push_back(-500);\n    v3.push_back(-500);\n    triples_sum_to_zero(v3);\n\n    // list(range(-499, 500)) + [1000, -501, 1]\n    vector<int> v4;\n    for (int i = -499; i < 500; ++i) v4.push_back(i);\n    v4.push_back(1000);\n    v4.push_back(-501);\n    v4.push_back(1);\n    triples_sum_to_zero(v4);\n\n    // list(range(-1000, 1000, 3))\n    vector<int> v5;\n    for (int i = -1000; i < 1000; i += 3) v5.push_back(i);\n    triples_sum_to_zero(v5);\n}"
    },
    {
        "task_id": "41",
        "entry_point": "car_race_collision",
        "stress_test": "[{\"input\": \"[9999]\", \"output\": null}, {\"input\": \"[5000]\", \"output\": null}, {\"input\": \"[1234]\", \"output\": null}, {\"input\": \"[8765]\", \"output\": null}, {\"input\": \"[10000]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint car_race_collision(int n){\nreturn n*n;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (car_race_collision(2) == 4);\n    assert (car_race_collision(3) == 9);\n    assert (car_race_collision(4) == 16);\n    assert (car_race_collision(8) == 64);\n    assert (car_race_collision(10) == 100);\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    car_race_collision(9999);\n    car_race_collision(5000);\n    car_race_collision(1234);\n    car_race_collision(8765);\n    car_race_collision(10000);\n}"
    },
    {
        "task_id": "42",
        "entry_point": "incr_list",
        "stress_test": "[{\"input\": \"[[i * i for i in range(10000)]]\", \"output\": null}, {\"input\": \"[[10000 - i for i in range(10000)]]\", \"output\": null}, {\"input\": \"[[i for i in range(9999, -1, -1)]]\", \"output\": null}, {\"input\": \"[[i for i in range(10000)]]\", \"output\": null}, {\"input\": \"[[1000] * 10000]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> incr_list(vector<int> l){\nfor (int i=0;i<l.size();i++)\n        l[i]+=1;\n    return l;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(incr_list({}) , {}));\n    assert (issame(incr_list({3, 2, 1}) , {4, 3, 2}));\n    assert (issame(incr_list({5, 2, 5, 2, 3, 3, 9, 0, 123}) , {6, 3, 6, 3, 4, 4, 10, 1, 124}));\n}\n",
        "cpp_stress_test": "#include<vector>\nusing namespace std;\nint main(){vector<int> v1;for(int i=0;i<10000;++i)v1.push_back(i*i);incr_list(v1);vector<int> v2;for(int i=0;i<10000;++i)v2.push_back(10000-i);incr_list(v2);vector<int> v3;for(int i=9999;i>=0;--i)v3.push_back(i);incr_list(v3);vector<int> v4;for(int i=0;i<10000;++i)v4.push_back(i);incr_list(v4);vector<int> v5(10000,1000);incr_list(v5);return 0;}"
    },
    {
        "task_id": "43",
        "entry_point": "pairs_sum_to_zero",
        "stress_test": "[{\"input\": \"[[i if i % 2 == 0 else -i for i in range(1, 10001)]]\", \"output\": null}, {\"input\": \"[[i for i in range(-5000, 5000)]]\", \"output\": null}, {\"input\": \"[[0, -1, 1] + [i for i in range(2, 5000)] + [-i for i in range(2, 5000)]]\", \"output\": null}, {\"input\": \"[[i for i in range(10000, 20000)] + [-i for i in range(10000, 20000)]]\", \"output\": null}, {\"input\": \"[list(range(5000)) + list(range(-4999, 1))]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool pairs_sum_to_zero(vector<int> l){\nfor (int i=0;i<l.size();i++)\n    for (int j=i+1;j<l.size();j++)\n    if (l[i]+l[j]==0) return true;\n    return false;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (pairs_sum_to_zero({1, 3, 5, 0}) == false);\n    assert (pairs_sum_to_zero({1, 3, -2, 1}) == false);\n    assert (pairs_sum_to_zero({1, 2, 3, 7}) == false);\n    assert (pairs_sum_to_zero({2, 4, -5, 3, 5, 7}) == true);\n    assert (pairs_sum_to_zero({1}) == false);\n    assert (pairs_sum_to_zero({-3, 9, -1, 3, 2, 30}) == true);\n    assert (pairs_sum_to_zero({-3, 9, -1, 3, 2, 31}) == true);\n    assert (pairs_sum_to_zero({-3, 9, -1, 4, 2, 30}) == false);\n    assert (pairs_sum_to_zero({-3, 9, -1, 4, 2, 31}) == false);\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\n#include<vector>\n#include<algorithm>\nint main(){ std::vector<int> input1; for(int i = 1; i < 10001; ++i) input1.push_back(i % 2 == 0 ? i : -i); pairs_sum_to_zero(input1); std::vector<int> input2; for(int i = -5000; i < 5000; ++i) input2.push_back(i); pairs_sum_to_zero(input2); std::vector<int> input3 = {0, -1, 1}; for(int i = 2; i < 5000; ++i) input3.push_back(i); for(int i = 2; i < 5000; ++i) input3.push_back(-i); pairs_sum_to_zero(input3); std::vector<int> input4; for(int i = 10000; i < 20000; ++i) input4.push_back(i); for(int i = 10000; i < 20000; ++i) input4.push_back(-i); pairs_sum_to_zero(input4); std::vector<int> input5; for(int i = 0; i < 5000; ++i) input5.push_back(i); for(int i = -4999; i < 1; ++i) input5.push_back(i); pairs_sum_to_zero(input5); }"
    },
    {
        "task_id": "44",
        "entry_point": "change_base",
        "stress_test": "[{\"input\": \"[8888, 2]\", \"output\": null}, {\"input\": \"[8191, 2]\", \"output\": null}, {\"input\": \"[1024, 2]\", \"output\": null}, {\"input\": \"[9876, 3]\", \"output\": null}, {\"input\": \"[10000, 3]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring change_base(int x,int base){\nstring out=\"\";\n    while (x>0)\n    {\n        out=to_string(x%base)+out;\n        x=x/base;\n    }\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (change_base(8, 3) == \"22\");\n    assert (change_base(9, 3) == \"100\");\n    assert (change_base(234, 2) == \"11101010\");\n    assert (change_base(16, 2) == \"10000\");\n    assert (change_base(8, 2) == \"1000\");\n    assert (change_base(7, 2) == \"111\");\n    for (int x=2;x<8;x++)\n        assert (change_base(x, x + 1) == to_string(x));\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\nint main(){ change_base(8888, 2); change_base(8191, 2); change_base(1024, 2); change_base(9876, 3); change_base(10000, 3); }"
    },
    {
        "task_id": "45",
        "entry_point": "triangle_area",
        "stress_test": "[{\"input\": \"[9999, 9999]\", \"output\": null}, {\"input\": \"[10**4 - 1, 10**4 - 1]\", \"output\": null}, {\"input\": \"[10**3, 10**3]\", \"output\": null}, {\"input\": \"[9999, 1]\", \"output\": null}, {\"input\": \"[1, 9999]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float h){\nreturn (a*h)*0.5;\n\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (abs(triangle_area(5, 3) - 7.5)<1e-4);\n    assert (abs(triangle_area(2, 2) - 2.0)<1e-4);\n    assert (abs(triangle_area(10, 8) - 40.0)<1e-4);\n}\n",
        "cpp_stress_test": "#include<cmath>\n#include<iostream>\nusing namespace std;\nint main(){\n    cout << triangle_area(9999, 9999) << endl;\n    cout << triangle_area(9999, 9999) << endl;\n    cout << triangle_area(1000, 1000) << endl;\n    cout << triangle_area(9999, 1) << endl;\n    cout << triangle_area(1, 9999) << endl;\n}"
    },
    {
        "task_id": "46",
        "entry_point": "fib4",
        "stress_test": "[{\"input\": \"[10000]\", \"output\": null}, {\"input\": \"[9999]\", \"output\": null}, {\"input\": \"[9998]\", \"output\": null}, {\"input\": \"[9876]\", \"output\": null}, {\"input\": \"[8943]\", \"output\": null}]",
        "function_code": "#include <vector>\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib4(int n){\nvector<int> f(n + 1, 0);\n    f[0]=0;\n    f[1]=0;\n    f[2]=2;\n    f[3]=0;\n    for (int i=4;i<=n;i++)\n    {\n        f[i]=f[i-1]+f[i-2]+f[i-3]+f[i-4];\n    }\n    return f[n];\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (fib4(5) == 4);\n    assert (fib4(8) == 28);\n    assert (fib4(10) == 104);\n    assert (fib4(12) == 386);\n}\n",
        "cpp_stress_test": "#undef NDEBUG\nint main() {\n    fib4(10000);\n    fib4(9999);\n    fib4(9998);\n    fib4(9876);\n    fib4(8943);return 0;\n}"
    },
    {
        "task_id": "47",
        "entry_point": "median",
        "stress_test": "[{\"input\": \"[[i/2 if i % 2 == 0 else i**2 for i in range(10000)]]\", \"output\": null}, {\"input\": \"[[(i % 4 - 2) * 10**2 + (i % 5 - 2) * 10 + (i % 6 - 3) for i in range(9999)]]\", \"output\": null}, {\"input\": \"[[(2**i % 1000) / 3.0 for i in range(10000)]]\", \"output\": null}, {\"input\": \"[[i / (i % 7 + 1) for i in range(1, 10001)]]\", \"output\": null}, {\"input\": \"[[(i % 3) * (i - 10000) for i in range(10000)]]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat median(vector<float> l){\nsort(l.begin(),l.end());\n    if (l.size()%2==1) return l[l.size()/2];\n    return 0.5*(l[l.size()/2]+l[l.size()/2-1]);\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (abs(median({3, 1, 2, 4, 5}) - 3)<1e-4);\n    assert (abs(median({-10, 4, 6, 1000, 10, 20}) -8.0)<1e-4);\n    assert (abs(median({5}) - 5)<1e-4);\n    assert (abs(median({6, 5}) - 5.5)<1e-4);\n    assert (abs(median({8, 1, 3, 9, 9, 2, 7}) - 7)<1e-4 );\n}\n",
        "cpp_stress_test": "#include <vector>\nint main(){std::vector<double> v1;for(int i=0;i<10000;++i){v1.push_back(i%2==0?i/2.0:i*i);}std::vector<int> v2;for(int i=0;i<9999;++i){v2.push_back((i%4-2)*100+(i%5-2)*10+(i%6-3));}std::vector<double> v3;for(int i=0;i<10000;++i){v3.push_back((static_cast<int>(pow(2,i))%1000)/3.0);}std::vector<double> v4;for(int i=1;i<=10000;++i){v4.push_back(i/(i%7+1.0));}std::vector<int> v5;for(int i=0;i<10000;++i){v5.push_back((i%3)*(i-10000));}}"
    },
    {
        "task_id": "48",
        "entry_point": "is_palindrome",
        "stress_test": "[{\"input\": \"['a' * (10**4 // 2) + 'b' + 'a' * (10**4 // 2)]\", \"output\": null}, {\"input\": \"['noon'*2500]\", \"output\": null}, {\"input\": \"['a' * 10**4]\", \"output\": null}, {\"input\": \"[''.join('madam' for i in range(2000))]\", \"output\": null}, {\"input\": \"[''.join(chr(97 + (i % 26)) for i in range(5000)) + ''.join(chr(97 + (i % 26)) for i in range(5000)[::-1])]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_palindrome(string text){\nstring pr(text.rbegin(),text.rend());\n    return pr==text;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_palindrome(\"\") == true);\n    assert (is_palindrome(\"aba\") == true);\n    assert (is_palindrome(\"aaaaa\") == true);\n    assert (is_palindrome(\"zbcd\") == false);\n    assert (is_palindrome(\"xywyx\") == true);\n    assert (is_palindrome(\"xywyz\") == false);\n    assert (is_palindrome(\"xywzx\") == false);\n}\n",
        "cpp_stress_test": "#include <string>\nusing namespace std;\n\nint main() {\n    // 'a' * 5000 + 'b' + 'a' * 5000\n    is_palindrome(string(5000, 'a') + 'b' + string(5000, 'a'));\n\n    // 'noon' * 2500\n    string s2;\n    for (int i = 0; i < 2500; ++i) s2 += \"noon\";\n    is_palindrome(s2);\n\n    // 'a' * 10000\n    is_palindrome(string(10000, 'a'));\n\n    // 'madam' * 2000\n    string s4;\n    for (int i = 0; i < 2000; ++i) s4 += \"madam\";\n    is_palindrome(s4);\n\n    // ''.join(chr(97 + (i % 26)) for i in range(5000)) + reverse of same\n    string s5;\n    for (int i = 0; i < 5000; ++i) s5 += char(97 + (i % 26));\n    for (int i = 4999; i >= 0; --i) s5 += char(97 + (i % 26));\n    is_palindrome(s5);\n}"
    },
    {
        "task_id": "49",
        "entry_point": "modp",
        "stress_test": "[{\"input\": \"[9998, 10007]\", \"output\": null}, {\"input\": \"[9999, 10009]\", \"output\": null}, {\"input\": \"[9999, 9973]\", \"output\": null}, {\"input\": \"[10000, 7919]\", \"output\": null}, {\"input\": \"[9999, 4999]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint modp(int n,int p){\nint out=1;\n    for (int i=0;i<n;i++)\n        out=(out*2)%p;\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (modp(3, 5) == 3);\n    assert (modp(1101, 101) == 2);\n    assert (modp(0, 101) == 1);\n    assert (modp(3, 11) == 8);\n    assert (modp(100, 101) == 1);\n    assert (modp(30, 5) == 4);\n    assert (modp(31, 5) == 3);\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\nint main(){modp(9998, 10007);modp(9999, 10009);modp(9999, 9973);modp(10000, 7919);modp(9999, 4999);}"
    },
    {
        "task_id": "50",
        "entry_point": "decode_shift",
        "stress_test": "[{\"input\": \"['qwertyuiopasdfghjklzxcvbnm' * 385]\", \"output\": null}, {\"input\": \"['sphinxofblackquartzjudgemyvow' * 345]\", \"output\": null}, {\"input\": \"['abcdefghijklmnopqrstuvwxy' * 400]\", \"output\": null}, {\"input\": \"['abcdefghijklmnopqrstuvwxyz' * 384]\", \"output\": null}, {\"input\": \"['thequickbrownfoxjumpsoverthelazydog' * 285]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encode_shift(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+5-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\nstring decode_shift(string s){\nstring out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+21-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    \n    for (int i=0;i<100;i++)\n    {\n        int l=10+rand()%11;\n        string str=\"\";\n        for (int j=0;j<l;j++)\n        {\n            char chr=97+rand()%26;\n            str+=chr;\n        }\n\n        string encoded_str = encode_shift(str);\n        assert (decode_shift(encoded_str) == str);\n    }\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<string>\nint main(){string str1=\"qwertyuiopasdfghjklzxcvbnm\",str2=\"sphinxofblackquartzjudgemyvow\",str3=\"abcdefghijklmnopqrstuvwxy\",str4=\"abcdefghijklmnopqrstuvwxyz\",str5=\"thequickbrownfoxjumpsoverthelazydog\";str1+=str1+str1+str1+str1+str1+str1+str1+str1+str1+str1+str1+str1+str1+str1+str1;str2+=str2+str2+str2+str2+str2+str2+str2+str2+str2+str2+str2+str2+str2+str2+str2+str2;str3+=str3+str3+str3+str3+str3+str3+str3+str3+str3+str3+str3+str3+str3+str3+str3+str3;str4+=str4+str4+str4+str4+str4+str4+str4+str4+str4+str4+str4+str4+str4+str4+str4+str4;str5+=str5+str5+str5+str5+str5+str5+str5+str5+str5+str5+str5+str5+str5+str5+str5;return 0;}"
    },
    {
        "task_id": "51",
        "entry_point": "remove_vowels",
        "stress_test": "[{\"input\": \"[''.join(chr(i) for i in range(32, 127)) * 1000]\", \"output\": null}, {\"input\": \"['This is a long text with numbers 1234567890 and special characters !@#$%^&*()_+[];\\\\',./{}|:\\\"<>?' * 200]\", \"output\": null}, {\"input\": \"['Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.' * 150]\", \"output\": null}, {\"input\": \"[''.join(chr(i) for i in range(32, 91)) * 150 + ''.join(chr(i) for i in range(97, 127)) * 150]\", \"output\": null}, {\"input\": \"[''.join(chr(i) for i in range(32, 127)) * 125]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring remove_vowels(string text){\nstring out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=0;i<text.length();i++)\n        if (find(vowels.begin(),vowels.end(),text[i])==vowels.end())\n            out=out+text[i];\n    return out;\n\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (remove_vowels(\"\") == \"\");\n    assert (remove_vowels(\"abcdef\\nghijklm\") == \"bcdf\\nghjklm\");\n    assert (remove_vowels(\"fedcba\") == \"fdcb\");\n    assert (remove_vowels(\"eeeee\") == \"\");\n    assert (remove_vowels(\"acBAA\") == \"cB\");\n    assert (remove_vowels(\"EcBOO\") == \"cB\");\n    assert (remove_vowels(\"ybcd\") == \"ybcd\");\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include <assert.h>\n#include <string>\n#include <iostream>\n\nstd::string generate_string(const std::string& base_pattern, int repeat_count) {\n    std::string result;\n    for (int i = 0; i < repeat_count; ++i) {\n        result += base_pattern;\n    }\n    return result;\n}\n\nstd::string generate_range_string(int start, int end, int repeat_count) {\n    std::string result;\n    std::string pattern;\n    for (int i = start; i < end; ++i) {\n        pattern += static_cast<char>(i);\n    }\n    return generate_string(pattern, repeat_count);\n}\n\nint main() {\n    std::string input1 = generate_range_string(32, 127, 1000);\n    std::string input2 = generate_string(\"This is a long text with numbers 1234567890 and special characters !@#$%^&*()_+[];',./{}|:\\\"<>?\", 200);\n    std::string input3 = generate_string(\"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\", 150);\n    std::string input4 = generate_range_string(32, 91, 150) + generate_range_string(97, 127, 150);\n    std::string input5 = generate_range_string(32, 127, 125);\n    return 0;\n}"
    },
    {
        "task_id": "52",
        "entry_point": "below_threshold",
        "stress_test": "[{\"input\": \"[[1.1, 2.2, 3.3, 4.4, 5.5]*2000, 6]\", \"output\": null}, {\"input\": \"[[float(i) for i in range(10000)], 10000]\", \"output\": null}, {\"input\": \"[[0.1 * i for i in range(10000)], 1000]\", \"output\": null}, {\"input\": \"[[True, False] * 5000, 2]\", \"output\": null}, {\"input\": \"[[True]*5000 + [False]*4999 + [10001], 10000]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool below_threshold(vector<int>l, int t){\nfor (int i=0;i<l.size();i++)\n        if (l[i]>=t) return false;\n    return true;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (below_threshold({1, 2, 4, 10}, 100));\n    assert (not(below_threshold({1, 20, 4, 10}, 5)));\n    assert (below_threshold({1, 20, 4, 10}, 21));\n    assert (below_threshold({1, 20, 4, 10}, 22));\n    assert (below_threshold({1, 8, 4, 10}, 11));\n    assert (not(below_threshold({1, 8, 4, 10}, 10)));\n}\n",
        "cpp_stress_test": "#include <vector>\nusing namespace std;\n\nint main() {\n    // [1.1, 2.2, 3.3, 4.4, 5.5] * 2000  truncate to int\n    vector<int> v1;\n    for (int i = 0; i < 2000; ++i) {\n        v1.push_back(1);\n        v1.push_back(2);\n        v1.push_back(3);\n        v1.push_back(4);\n        v1.push_back(5);\n    }\n    below_threshold(v1, 6);\n\n    // [float(i) for i in range(10000)]  truncate to int\n    vector<int> v2;\n    for (int i = 0; i < 10000; ++i) v2.push_back(i);\n    below_threshold(v2, 10000);\n\n    // [0.1 * i for i in range(10000)]  truncate to int (0999)\n    vector<int> v3;\n    for (int i = 0; i < 10000; ++i) v3.push_back(static_cast<int>(0.1 * i));\n    below_threshold(v3, 1000);\n\n    // [True, False] * 5000  1, 0 alternating\n    vector<int> v4;\n    for (int i = 0; i < 5000; ++i) {\n        v4.push_back(1);\n        v4.push_back(0);\n    }\n    below_threshold(v4, 2);\n\n    // [True]*5000 + [False]*4999 + [10001]\n    vector<int> v5;\n    for (int i = 0; i < 5000; ++i) v5.push_back(1);\n    for (int i = 0; i < 4999; ++i) v5.push_back(0);\n    v5.push_back(10001);\n    below_threshold(v5, 10000);\n}"
    },
    {
        "task_id": "53",
        "entry_point": "add",
        "stress_test": "[{\"input\": \"[1234, 5678]\", \"output\": null}, {\"input\": \"[9999, 1]\", \"output\": null}, {\"input\": \"[8765, 4321]\", \"output\": null}, {\"input\": \"[2, 9998]\", \"output\": null}, {\"input\": \"[1024, 2048]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\nint add(int x,int y){\nreturn x+y;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (add(0, 1) == 1);\n    assert (add(1, 0) == 1);\n    assert (add(2, 3) == 5);\n    assert (add(5, 7) == 12);\n    assert (add(7, 5) == 12);\n    for (int i=0;i<100;i+=1)\n    {\n        int x=rand()%1000;\n        int y=rand()%1000;\n        assert (add(x, y) == x + y);\n    }\n}\n",
        "cpp_stress_test": "#include <vector>\nusing namespace std;\n\nint main() {\n    add(1234, 5678);\n    add(9999, 1);\n    add(8765, 4321);\n    add(2, 9998);\n    add(1024, 2048);\n}"
    },
    {
        "task_id": "54",
        "entry_point": "same_chars",
        "stress_test": "[{\"input\": \"['a'*2500 + 'b'*2500 + 'c'*2500 + 'd'*2500, 'd'*2500 + 'c'*2500 + 'b'*2500 + 'a'*2500]\", \"output\": null}, {\"input\": \"['x'*2500 + 'y'*2500 + 'z'*2500 + 'w'*2500, 'w'*2500 + 'z'*2500 + 'y'*2500 + 'x'*2500]\", \"output\": null}, {\"input\": \"['a'*5000 + 'b'*5000, 'a'*4999 + 'b'*5001]\", \"output\": null}, {\"input\": \"['a'*1234 + 'b'*8766, 'b'*8766 + 'a'*1234]\", \"output\": null}, {\"input\": \"['a'*5000 + 'b'*5000, 'ba'*5000]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool same_chars(string s0,string s1){\nfor (int i=0;i<s0.length();i++)\n    if (find(s1.begin(),s1.end(),s0[i])==s1.end())\n        return false;\n    for (int i=0;i<s1.length();i++)\n    if (find(s0.begin(),s0.end(),s1[i])==s0.end())\n        return false;\n    return true;   \n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\") == true);\n    assert (same_chars(\"abcd\", \"dddddddabc\") == true);\n    assert (same_chars(\"dddddddabc\", \"abcd\") == true);\n    assert (same_chars(\"eabcd\", \"dddddddabc\") == false);\n    assert (same_chars(\"abcd\", \"dddddddabcf\") == false);\n    assert (same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\") == false);\n    assert (same_chars(\"aabb\", \"aaccc\") == false);\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\nint main(){same_chars(std::string(2500, 'a') + std::string(2500, 'b') + std::string(2500, 'c') + std::string(2500, 'd'), std::string(2500, 'd') + std::string(2500, 'c') + std::string(2500, 'b') + std::string(2500, 'a')); same_chars(std::string(2500, 'x') + std::string(2500, 'y') + std::string(2500, 'z') + std::string(2500, 'w'), std::string(2500, 'w') + std::string(2500, 'z') + std::string(2500, 'y') + std::string(2500, 'x')); same_chars(std::string(5000, 'a') + std::string(5000, 'b'), std::string(4999, 'a') + std::string(5001, 'b')); same_chars(std::string(1234, 'a') + std::string(8766, 'b'), std::string(8766, 'b') + std::string(1234, 'a')); same_chars(std::string(5000, 'a') + std::string(5000, 'b'), std::string(5000, 'b') + std::string(5000, 'a'));}"
    },
    {
        "task_id": "55",
        "entry_point": "fib",
        "stress_test": "[{\"input\": \"[35]\", \"output\": null}, {\"input\": \"[34]\", \"output\": null}, {\"input\": \"[33]\", \"output\": null}, {\"input\": \"[32]\", \"output\": null}, {\"input\": \"[31]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib(int n){\nint f[1000];\n    f[0]=0;f[1]=1;\n    for (int i=2;i<=n; i++)\n    f[i]=f[i-1]+f[i-2];\n    return f[n];\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (fib(10) == 55);\n    assert (fib(1) == 1);\n    assert (fib(8) == 21);\n    assert (fib(11) == 89);\n    assert (fib(12) == 144);\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\nint main(){ fib(35); fib(34); fib(33); fib(32); fib(31); }"
    },
    {
        "task_id": "56",
        "entry_point": "correct_bracketing",
        "stress_test": "[{\"input\": \"['<' * 10000 + '>' * 10000]\", \"output\": null}, {\"input\": \"['<' * 9999 + '>' * 9999 + '>']\", \"output\": null}, {\"input\": \"['<><<>>' * 3333 + '<']\", \"output\": null}, {\"input\": \"['<><><>' * 3333 + '<>']\", \"output\": null}, {\"input\": \"['<><<><<>>><>' * 1250]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool correct_bracketing(string brackets){\nint level=0;\n    for (int i=0;i<brackets.length();i++)\n    {\n        if (brackets[i]=='<') level+=1;\n        if (brackets[i]=='>') level-=1;\n        if (level<0) return false;\n    }\n    if (level!=0) return false;\n    return true;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (correct_bracketing(\"<>\"));\n    assert (correct_bracketing(\"<<><>>\"));\n    assert (correct_bracketing(\"<><><<><>><>\"));\n    assert (correct_bracketing(\"<><><<<><><>><>><<><><<>>>\"));\n    assert (not (correct_bracketing(\"<<<><>>>>\")));\n    assert (not (correct_bracketing(\"><<>\")));\n    assert (not (correct_bracketing(\"<\")));\n    assert (not (correct_bracketing(\"<<<<\")));\n    assert (not (correct_bracketing(\">\")));\n    assert (not (correct_bracketing(\"<<>\")));\n    assert (not (correct_bracketing(\"<><><<><>><>><<>\")));\n    assert (not (correct_bracketing(\"<><><<><>><>>><>\")));\n}\n",
        "cpp_stress_test": "#include <string>\nusing namespace std;\n\nint main() {\n    // '<' * 10000 + '>' * 10000\n    string s1(10000, '<');\n    s1 += string(10000, '>');\n    correct_bracketing(s1);\n\n    // '<' * 9999 + '>' * 9999 + '>'\n    string s2(9999, '<');\n    s2 += string(9999, '>') + '>';\n    correct_bracketing(s2);\n\n    // '<><<>>' * 3333 + '<'\n    string s3;\n    for (int i = 0; i < 3333; ++i) s3 += \"<><<>>\";\n    s3 += '<';\n    correct_bracketing(s3);\n\n    // '<><><>' * 3333 + '<>'\n    string s4;\n    for (int i = 0; i < 3333; ++i) s4 += \"<><><>\";\n    s4 += \"<>\";\n    correct_bracketing(s4);\n\n    // '<><<><<>>><>' * 1250\n    string s5;\n    for (int i = 0; i < 1250; ++i) s5 += \"<><<><<>>><>\";\n    correct_bracketing(s5);\n}"
    },
    {
        "task_id": "57",
        "entry_point": "monotonic",
        "stress_test": "[{\"input\": \"[[(i % 2 == 0) for i in range(10**4)]]\", \"output\": null}, {\"input\": \"[[i * (-1)**i for i in range(10**4)]]\", \"output\": null}, {\"input\": \"[[(i * 0.1) if i % 2 == 0 else (i * -0.1) for i in range(10**4)]]\", \"output\": null}, {\"input\": \"[sorted([float('nan') if i == 5000 else i for i in range(10000)], reverse=True)]\", \"output\": null}, {\"input\": \"[list(range(5000)) + [5000] + list(range(5000, 0, -1))]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool monotonic(vector<float> l){\nint incr,decr;\n    incr=0;decr=0;\n    for (int i=1;i<l.size();i++)\n    {\n        if (l[i]>l[i-1]) incr=1;\n        if (l[i]<l[i-1]) decr=1;\n    }\n    if (incr+decr==2) return false;\n    return true;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (monotonic({1, 2, 4, 10}) == true);\n    assert (monotonic({1, 2, 4, 20}) == true);\n    assert (monotonic({1, 20, 4, 10}) == false);\n    assert (monotonic({4, 1, 0, -10}) == true);\n    assert (monotonic({4, 1, 1, 0}) == true);\n    assert (monotonic({1, 2, 3, 2, 5, 60}) == false);\n    assert (monotonic({1, 2, 3, 4, 5, 60}) == true);\n    assert (monotonic({9, 9, 9, 9}) == true);\n}\n",
        "cpp_stress_test": "#include <vector>\n#include <cmath>\n#include <limits>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    // [(i % 2 == 0) for i in range(10000)]\n    vector<float> case1;\n    for (int i = 0; i < 10000; ++i)\n        case1.push_back(i % 2 == 0 ? 1.0f : 0.0f);\n    monotonic(case1);\n\n    // [i * (-1)^i for i in range(10000)]\n    vector<float> case2;\n    for (int i = 0; i < 10000; ++i)\n        case2.push_back((i % 2 == 0 ? 1 : -1) * i);\n    monotonic(case2);\n\n    // [(i * 0.1) if i % 2 == 0 else (i * -0.1) for i in range(10000)]\n    vector<float> case3;\n    for (int i = 0; i < 10000; ++i)\n        case3.push_back(i % 2 == 0 ? i * 0.1f : -i * 0.1f);\n    monotonic(case3);\n\n    // [sorted([float('nan') if i == 5000 else i for i in range(10000)], reverse=True)]\n    vector<float> case4;\n    for (int i = 0; i < 10000; ++i)\n        case4.push_back(i == 5000 ? numeric_limits<float>::quiet_NaN() : static_cast<float>(i));\n    sort(case4.rbegin(), case4.rend());\n    monotonic(case4);\n\n    // list(range(5000)) + [5000] + list(range(5000, 0, -1))\n    vector<float> case5;\n    for (int i = 0; i < 5000; ++i) case5.push_back(i);\n    case5.push_back(5000);\n    for (int i = 5000; i > 0; --i) case5.push_back(i);\n    monotonic(case5);\n}"
    },
    {
        "task_id": "58",
        "entry_point": "common",
        "stress_test": "[{\"input\": \"[[1]*5000 + [i for i in range(5000)], [i for i in range(5000, 10000)] + [1]*5000]\", \"output\": null}, {\"input\": \"[[i for i in range(10000)], [9999 - i for i in range(10000)]]\", \"output\": null}, {\"input\": \"[list(range(10000, 20000)), list(range(15000, 25000))]\", \"output\": null}, {\"input\": \"[[i for i in range(10000)], [i for i in range(5000, 15000)]]\", \"output\": null}, {\"input\": \"[[i for i in range(9999, -1, -1)], [i for i in range(5000, 15000)]]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> common(vector<int> l1,vector<int> l2){\nvector<int> out={};\n    for (int i=0;i<l1.size();i++)\n        if (find(out.begin(),out.end(),l1[i])==out.end())\n            if (find(l2.begin(),l2.end(),l1[i])!=l2.end())\n                out.push_back(l1[i]);\n    sort(out.begin(),out.end());\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(common({1, 4, 3, 34, 653, 2, 5}, {5, 7, 1, 5, 9, 653, 121}) , {1, 5, 653}));\n    assert (issame(common({5, 3, 2, 8}, {3, 2}) , {2, 3}));\n    assert (issame(common({4, 3, 2, 8}, {3, 2, 4}) , {2, 3, 4}));\n    assert (issame(common({4, 3, 2, 8}, {}) , {}));\n}\n",
        "cpp_stress_test": "#include <vector>\n#include <numeric>\nusing namespace std;\nint main() {\n    vector<int> v1(5000, 1);\n    for (int i = 0; i < 5000; ++i) v1.push_back(i);\n    vector<int> v2;\n    for (int i = 5000; i < 10000; ++i) v2.push_back(i);\n    v2.insert(v2.end(), 5000, 1);\n    common(v1, v2);\n\n    vector<int> v3(10000);\n    iota(v3.begin(), v3.end(), 0);\n    vector<int> v4(10000);\n    for (int i = 0; i < 10000; ++i) v4[i] = 9999 - i;\n    common(v3, v4);\n\n    vector<int> v5(10000);\n    iota(v5.begin(), v5.end(), 10000);\n    vector<int> v6(10000);\n    iota(v6.begin(), v6.end(), 15000);\n    common(v5, v6);\n\n    vector<int> v7(10000);\n    iota(v7.begin(), v7.end(), 0);\n    vector<int> v8(10000);\n    iota(v8.begin(), v8.end(), 5000);\n    common(v7, v8);\n\n    vector<int> v9(10000);\n    for (int i = 0; i < 10000; ++i) v9[i] = 9999 - i;\n    vector<int> v10(10000);\n    iota(v10.begin(), v10.end(), 5000);\n    common(v9, v10);\n    return 0;\n}"
    },
    {
        "task_id": "59",
        "entry_point": "largest_prime_factor",
        "stress_test": "[{\"input\": \"[98765]\", \"output\": null}, {\"input\": \"[95000]\", \"output\": null}, {\"input\": \"[9901 * 3]\", \"output\": null}, {\"input\": \"[9973 * 2]\", \"output\": null}, {\"input\": \"[10403]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_prime_factor(int n){\nfor (int i=2;i*i<=n;i++)\n    while (n%i==0 and n>i)  n=n/i;\n    return n;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (largest_prime_factor(15) == 5);\n    assert (largest_prime_factor(27) == 3);\n    assert (largest_prime_factor(63) == 7);\n    assert (largest_prime_factor(330) == 11);\n    assert (largest_prime_factor(13195) == 29);\n}\n",
        "cpp_stress_test": "#include<iostream>\nint main(){largest_prime_factor(98765);largest_prime_factor(95000);largest_prime_factor(9901 * 3);largest_prime_factor(9973 * 2);largest_prime_factor(10403);}"
    },
    {
        "task_id": "60",
        "entry_point": "sum_to_n",
        "stress_test": "[{\"input\": \"[10000]\", \"output\": null}, {\"input\": \"[9999]\", \"output\": null}, {\"input\": \"[9998]\", \"output\": null}, {\"input\": \"[9876]\", \"output\": null}, {\"input\": \"[8888]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_to_n(int n){\nreturn n*(n+1)/2;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (sum_to_n(1) == 1);\n    assert (sum_to_n(6) == 21);\n    assert (sum_to_n(11) == 66);\n    assert (sum_to_n(30) == 465);\n    assert (sum_to_n(100) == 5050);\n}\n",
        "cpp_stress_test": "#include<iostream>\nusing namespace std;\nint main() {\n    sum_to_n(10000);\n    sum_to_n(9999);\n    sum_to_n(9998);\n    sum_to_n(9876);\n    sum_to_n(8888);\n    return 0;\n}"
    },
    {
        "task_id": "61",
        "entry_point": "correct_bracketing",
        "stress_test": "[{\"input\": \"['<' * 10000 + '>' * 10000]\", \"output\": null}, {\"input\": \"['<' * 9999 + '>' * 9999 + '>']\", \"output\": null}, {\"input\": \"['<><<>>' * 3333 + '<']\", \"output\": null}, {\"input\": \"['<><><>' * 3333 + '<>']\", \"output\": null}, {\"input\": \"['<><<><<>>><>' * 1250]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool correct_bracketing(string brackets){\nint level=0;\n    for (int i=0;i<brackets.length();i++)\n    {\n        if (brackets[i]=='(') level+=1;\n        if (brackets[i]==')') level-=1;\n        if (level<0) return false;\n    }\n    if (level!=0) return false;\n    return true;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (correct_bracketing(\"()\"));\n    assert (correct_bracketing(\"(()())\"));\n    assert (correct_bracketing(\"()()(()())()\"));\n    assert (correct_bracketing(\"()()((()()())())(()()(()))\"));\n    assert (not (correct_bracketing(\"((()())))\")));\n    assert (not (correct_bracketing(\")(()\")));\n    assert (not (correct_bracketing(\"(\")));\n    assert (not (correct_bracketing(\"((((\")));\n    assert (not (correct_bracketing(\")\")));\n    assert (not (correct_bracketing(\"(()\")));\n    assert (not (correct_bracketing(\"()()(()())())(()\")));\n    assert (not (correct_bracketing(\"()()(()())()))()\")));\n}\n",
        "cpp_stress_test": "#include<string>\nusing namespace std;\nint main() {\n    correct_bracketing(string(10000, '<') + string(10000, '>'));\n    correct_bracketing(string(9999, '<') + string(9999, '>') + \">\");\n    string s1 = \"\";\n    for (int i = 0; i < 3333; ++i) s1 += \"<><<>>\";\n    s1 += \"<\";\n    correct_bracketing(s1);\n    string s2 = \"\";\n    for (int i = 0; i < 3333; ++i) s2 += \"<><><>\";\n    s2 += \"<>\";\n    correct_bracketing(s2);\n    string s3 = \"\";\n    for (int i = 0; i < 1250; ++i) s3 += \"<><<><<>>><>\";\n    correct_bracketing(s3);\n    return 0;\n}"
    },
    {
        "task_id": "62",
        "entry_point": "derivative",
        "stress_test": "[{\"input\": \"[[0.001 * i for i in range(10000)]]\", \"output\": null}, {\"input\": \"[[(-10**3) * (i % 2) for i in range(1500)]]\", \"output\": null}, {\"input\": \"[[0.1 * i for i in range(1000)]]\", \"output\": null}, {\"input\": \"[[(i % 5 - 2) * 10**4 for i in range(1000)]]\", \"output\": null}, {\"input\": \"[[1] * 1000]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> derivative(vector<float> xs){\nvector<float> out={};\n    for (int i=1;i<xs.size();i++)\n        out.push_back(i*xs[i]);\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(derivative({3, 1, 2, 4, 5}) , {1, 4, 12, 20}));\n    assert (issame(derivative({1, 2, 3}) , {2, 6}));\n    assert (issame(derivative({3, 2, 1}) , {2, 2}));\n    assert (issame(derivative({3, 2, 1, 0, 4}) , {2, 2, 0, 16}));\n    assert (issame(derivative({1}) , {}));\n}\n",
        "cpp_stress_test": "#include<vector>\n#include<cmath>\nusing namespace std;\nint main() {\n    vector<float> v1;\n    for (int i = 0; i < 10000; ++i) v1.push_back(0.001f * i);\n    derivative(v1);\n\n    vector<float> v2;\n    for (int i = 0; i < 1500; ++i) v2.push_back(-1000.0f * (i % 2));\n    derivative(v2);\n\n    vector<float> v3;\n    for (int i = 0; i < 1000; ++i) v3.push_back(0.1f * i);\n    derivative(v3);\n\n    vector<float> v4;\n    for (int i = 0; i < 1000; ++i) v4.push_back((i % 5 - 2) * 10000.0f);\n    derivative(v4);\n\n    vector<float> v5(1000, 1.0f);\n    derivative(v5);\n\n    return 0;\n}"
    },
    {
        "task_id": "63",
        "entry_point": "fibfib",
        "stress_test": "[{\"input\": \"[28]\", \"output\": null}, {\"input\": \"[25]\", \"output\": null}, {\"input\": \"[22]\", \"output\": null}, {\"input\": \"[20]\", \"output\": null}, {\"input\": \"[18]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fibfib(int n){\nint ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff[i]=ff[i-1]+ff[i-2]+ff[i-3];\n    return ff[n];\n\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (fibfib(2) == 1);\n    assert (fibfib(1) == 0);\n    assert (fibfib(5) == 4);\n    assert (fibfib(8) == 24);\n    assert (fibfib(10) == 81);\n    assert (fibfib(12) == 274);\n    assert (fibfib(14) == 927);\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\nint main(){fibfib(28); fibfib(25); fibfib(22); fibfib(20); fibfib(18);}"
    },
    {
        "task_id": "64",
        "entry_point": "vowels_count",
        "stress_test": "[{\"input\": \"['aeiouY'*2000]\", \"output\": null}, {\"input\": \"['aeiouAEIOU'*1000 + 'y'*1000]\", \"output\": null}, {\"input\": \"['qwrtypsdfghjklzxcvbnm'*500]\", \"output\": null}, {\"input\": \"['b'*9999 + 'Y']\", \"output\": null}, {\"input\": \"['Y'*10000]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint vowels_count(string s){\nstring vowels=\"aeiouAEIOU\";\n    int count=0;\n    for (int i=0;i<s.length();i++)\n    if (find(vowels.begin(),vowels.end(),s[i])!=vowels.end())\n        count+=1;\n    if (s[s.length()-1]=='y' or s[s.length()-1]=='Y') count+=1;\n    return count;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (vowels_count(\"abcde\") == 2);\n    assert (vowels_count(\"Alone\") == 3);\n    assert (vowels_count(\"key\") == 2);\n    assert (vowels_count(\"bye\") == 1);\n    assert (vowels_count(\"keY\") == 2);\n    assert (vowels_count(\"bYe\") == 1);\n    assert (vowels_count(\"ACEDY\") == 3);\n   \n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    vowels_count(std::string(2000, 'a').append(2000, 'e').append(2000, 'i').append(2000, 'o').append(2000, 'u').append(2000, 'Y'));\n    vowels_count(std::string(1000, 'a').append(1000, 'e').append(1000, 'i').append(1000, 'o').append(1000, 'u').append(1000, 'A').append(1000, 'E').append(1000, 'I').append(1000, 'O').append(1000, 'U').append(1000, 'y'));\n    vowels_count(std::string(500, 'q').append(500, 'w').append(500, 'r').append(500, 't').append(500, 'y').append(500, 'p').append(500, 's').append(500, 'd').append(500, 'f').append(500, 'g').append(500, 'h').append(500, 'j').append(500, 'k').append(500, 'l').append(500, 'z').append(500, 'x').append(500, 'c').append(500, 'v').append(500, 'b').append(500, 'n').append(500, 'm'));\n    vowels_count(std::string(9999, 'b').append(1, 'Y'));\n    vowels_count(std::string(10000, 'Y'));\n}"
    },
    {
        "task_id": "65",
        "entry_point": "circular_shift",
        "stress_test": "[{\"input\": \"[12345678901234567890, 10]\", \"output\": null}, {\"input\": \"[1357924680, 5]\", \"output\": null}, {\"input\": \"[999999999999999, 1]\", \"output\": null}, {\"input\": \"[9999999999, 1]\", \"output\": null}, {\"input\": \"[1234567890123456, 16]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring circular_shift(int x,int shift){\nstring xs;\n    xs=to_string(x);\n    if (xs.length()<shift)\n    {\n        string s(xs.rbegin(),xs.rend());\n        return s;\n    }\n    xs=xs.substr(xs.length()-shift)+xs.substr(0,xs.length()-shift);\n    return xs;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (circular_shift(100, 2) == \"001\");\n    assert (circular_shift(12, 2) == \"12\");\n    assert (circular_shift(97, 8) == \"79\");\n    assert (circular_shift(12, 1) == \"21\");\n    assert (circular_shift(11, 101) == \"11\");\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    circular_shift(12345678901234567890, 10);\n    circular_shift(1357924680, 5);\n    circular_shift(999999999999999, 1);\n    circular_shift(9999999999, 1);\n    circular_shift(1234567890123456, 16);\n}"
    },
    {
        "task_id": "66",
        "entry_point": "digitSum",
        "stress_test": "[{\"input\": \"[''.join(chr(i) if i % 5 == 0 else chr(i).lower() for i in range(65, 123)) * 300 + 'B' * 500]\", \"output\": null}, {\"input\": \"[''.join(chr(i) if i % 3 == 0 else chr(i).lower() for i in range(65, 123)) * 250]\", \"output\": null}, {\"input\": \"[''.join(chr(i) for i in range(65, 91) if i % 2 == 0) * 500 + ''.join(chr(i).lower() for i in range(65, 91) if i % 2 != 0) * 500]\", \"output\": null}, {\"input\": \"[''.join(chr(i) if i % 2 == 0 else chr(i).lower() for i in range(65, 91)) * 400 + 'z' * 2000]\", \"output\": null}, {\"input\": \"[''.join(chr(i) for i in range(65, 91))*400]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint digitSum(string s){\nint sum=0;\n    for (int i=0;i<s.length();i++)\n        if (s[i]>=65 and s[i]<=90)\n            sum+=s[i];\n    return sum;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (digitSum(\"\") == 0);\n    assert (digitSum(\"abAB\") == 131);\n    assert (digitSum(\"abcCd\") == 67);\n    assert (digitSum(\"helloE\") == 69);\n    assert (digitSum(\"woArBld\") == 131);\n    assert (digitSum(\"aAaaaXa\") == 153);\n    assert (digitSum(\" How are yOu?\") == 151);\n    assert (digitSum(\"You arE Very Smart\") == 327);\n}\n",
        "cpp_stress_test": "#include <string>\n#include <cctype>\nint main() { std::string test1(300 * 58, '\\0'); for (int i = 65, j = 0; i < 123; ++i) { if (i % 5 == 0) test1.replace(j, 1, 1, char(i)); else test1.replace(j, 1, 1, tolower(i)); j += 1; } test1.append(500, 'B'); std::string test2(250 * 58, '\\0'); for (int i = 65, j = 0; i < 123; ++i) { if (i % 3 == 0) test2.replace(j, 1, 1, char(i)); else test2.replace(j, 1, 1, tolower(i)); j += 1; } std::string test3(500 * 13, '\\0'); for (int i = 65, j = 0; i < 91; ++i) { if (i % 2 == 0) test3.replace(j, 1, 1, char(i)); j += 1; } test3.append(500 * 13, '\\0'); for (int i = 65, j = 500 * 13; i < 91; ++i) { if (i % 2 != 0) test3.replace(j, 1, 1, tolower(i)); j += 1; } std::string test4(400 * 26, '\\0'); for (int i = 65, j = 0; i < 91; ++i) { if (i % 2 == 0) test4.replace(j, 1, 1, char(i)); else test4.replace(j, 1, 1, tolower(i)); j += 1; } test4.append(2000, 'z'); std::string test5(400 * 26, '\\0'); for (int i = 65, j = 0; i < 91; ++i) { test5.replace(j, 1, 1, char(i)); j += 1; } }"
    },
    {
        "task_id": "67",
        "entry_point": "fruit_distribution",
        "stress_test": "[{\"input\": \"['5000 apples and 4000 oranges', 15000]\", \"output\": null}, {\"input\": \"['1234 apples and 4321 oranges', 10000]\", \"output\": null}, {\"input\": \"['1000 apples and 2000 oranges', 5000]\", \"output\": null}, {\"input\": \"['9999 apples and 9999 oranges', 30000]\", \"output\": null}, {\"input\": \"['1234 apples and 5678 oranges', 10000]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fruit_distribution(string s,int n){\nstring num1=\"\",num2=\"\";\n    int is12;\n    is12=0;\n    for (int i=0;i<s.size();i++)\n        \n        if (s[i]>=48 and s[i]<=57)\n        {\n            if (is12==0) num1=num1+s[i];\n            if (is12==1) num2=num2+s[i];\n        }\n        else\n          if (is12==0 and num1.length()>0) is12=1;\n    return n-atoi(num1.c_str())-atoi(num2.c_str());\n\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (fruit_distribution(\"5 apples and 6 oranges\",19) == 8);\n    assert (fruit_distribution(\"5 apples and 6 oranges\",21) == 10);\n    assert (fruit_distribution(\"0 apples and 1 oranges\",3) == 2);\n    assert (fruit_distribution(\"1 apples and 0 oranges\",3) == 2);\n    assert (fruit_distribution(\"2 apples and 3 oranges\",100) == 95);\n    assert (fruit_distribution(\"2 apples and 3 oranges\",5) == 0);\n    assert (fruit_distribution(\"1 apples and 100 oranges\",120) == 19);\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include <assert.h>\nint main() {\n    fruit_distribution(\"5000 apples and 4000 oranges\", 15000);\n    fruit_distribution(\"1234 apples and 4321 oranges\", 10000);\n    fruit_distribution(\"1000 apples and 2000 oranges\", 5000);\n    fruit_distribution(\"9999 apples and 9999 oranges\", 30000);\n    fruit_distribution(\"1234 apples and 5678 oranges\", 10000);\n}"
    },
    {
        "task_id": "68",
        "entry_point": "pluck",
        "stress_test": "[{\"input\": \"[[2]*2500 + [4]*2500 + [8]*2500 + [16]*2500]\", \"output\": null}, {\"input\": \"[[10000] + [i for i in range(9999, 0, -1)]]\", \"output\": null}, {\"input\": \"[[0, 1]*5000]\", \"output\": null}, {\"input\": \"[[0]*5000 + [3]*5000]\", \"output\": null}, {\"input\": \"[[i for i in range(10000)]]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> pluck(vector<int> arr){\nvector<int> out={};\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]%2==0 and (out.size()==0 or arr[i]<out[0]))\n        out={arr[i],i};\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(pluck({4,2,3}) , {2, 1}));\n    assert (issame(pluck({1,2,3}) , {2, 1}));\n    assert (issame(pluck({}) , {}));\n    assert (issame(pluck({5, 0, 3, 0, 4, 2}) , {0, 1}));\n    assert (issame(pluck({1, 2, 3, 0, 5, 3}) , {0, 3}));\n    assert (issame(pluck({5, 4, 8, 4 ,8}) , {4, 1}));\n    assert (issame(pluck({7, 6, 7, 1}) , {6, 1}));\n    assert (issame(pluck({7, 9, 7, 1}) , {}));\n}\n",
        "cpp_stress_test": "#include<vector>\n#include<numeric>\nusing namespace std;\nint main() {\n    vector<int> v1;\n    v1.insert(v1.end(), 2500, 2);\n    v1.insert(v1.end(), 2500, 4);\n    v1.insert(v1.end(), 2500, 8);\n    v1.insert(v1.end(), 2500, 16);\n    pluck(v1);\n\n    vector<int> v2 = {10000};\n    for (int i = 9999; i > 0; --i) v2.push_back(i);\n    pluck(v2);\n\n    vector<int> v3;\n    for (int i = 0; i < 5000; ++i) { v3.push_back(0); v3.push_back(1); }\n    pluck(v3);\n\n    vector<int> v4(5000, 0);\n    v4.insert(v4.end(), 5000, 3);\n    pluck(v4);\n\n    vector<int> v5(10000);\n    iota(v5.begin(), v5.end(), 0);\n    pluck(v5);\n\n    return 0;\n}"
    },
    {
        "task_id": "69",
        "entry_point": "search",
        "stress_test": "[{\"input\": \"[[9999] * 9999]\", \"output\": null}, {\"input\": \"[[i for i in range(1, 10001)]]\", \"output\": null}, {\"input\": \"[[i for i in range(1, 5001)] + [i for i in range(1, 5001)]]\", \"output\": null}, {\"input\": \"[list(range(1, 5001)) + list(range(1, 5001))]\", \"output\": null}, {\"input\": \"[[50] * 5000 + [100] * 5000]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint search(vector<int> lst){\nvector<vector<int>> freq={};\n    int max=-1;\n    for (int i=0;i<lst.size();i++)\n    {\n        bool has=false;\n        for (int j=0;j<freq.size();j++)\n            if (lst[i]==freq[j][0]) \n            {\n            freq[j][1]+=1;\n            has=true;\n            if (freq[j][1]>=freq[j][0] and freq[j][0]>max) max=freq[j][0];\n            }\n        if (not(has)) \n        {\n        freq.push_back({lst[i],1});\n        if (max==-1 and lst[i]==1) max=1;\n        }\n    }\n    return max;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (search({5, 5, 5, 5, 1}) == 1);\n    assert (search({4, 1, 4, 1, 4, 4}) == 4);\n    assert (search({3, 3}) == -1);\n    assert (search({8, 8, 8, 8, 8, 8, 8, 8}) == 8);\n    assert (search({2, 3, 3, 2, 2}) == 2);\n    assert (search({2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1}) == 1);\n    assert (search({3, 2, 8, 2}) == 2);\n    assert (search({6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10}) == 1);\n    assert (search({8, 8, 3, 6, 5, 6, 4}) == -1);\n    assert (search({6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9}) == 1);\n    assert (search({1, 9, 10, 1, 3}) == 1);\n    assert (search({6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10}) == 5);\n    assert (search({1}) == 1);\n    assert (search({8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5}) == 4);\n    assert (search({2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10}) == 2);\n    assert (search({1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3}) == 1);\n    assert (search({9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4}) == 4);\n    assert (search({2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7}) == 4);\n    assert (search({9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1}) == 2);\n    assert (search({5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8}) == -1);\n    assert (search({10}) == -1);\n    assert (search({9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2}) == 2);\n    assert (search({5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8}) == 1);\n    assert (search({7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6}) == 1);\n    assert (search({3, 10, 10, 9, 2}) == -1);\n}\n",
        "cpp_stress_test": "#include<vector>\n#include<numeric>\nusing namespace std;\nint main() {\n    search(vector<int>(9999, 9999));\n\n    vector<int> v2(10000);\n    iota(v2.begin(), v2.end(), 1);\n    search(v2);\n\n    vector<int> v3(10000);\n    iota(v3.begin(), v3.begin() + 5000, 1);\n    iota(v3.begin() + 5000, v3.end(), 1);\n    search(v3);\n\n    vector<int> v4(10000);\n    iota(v4.begin(), v4.begin() + 5000, 1);\n    iota(v4.begin() + 5000, v4.end(), 1);\n    search(v4);\n\n    vector<int> v5(10000, 50);\n    fill(v5.begin() + 5000, v5.end(), 100);\n    search(v5);\n\n    return 0;\n}"
    },
    {
        "task_id": "70",
        "entry_point": "strange_sort_list",
        "stress_test": "[{\"input\": \"[[i * (-1)**i for i in range(1, 10001)]]\", \"output\": null}, {\"input\": \"[[i if i % 2 == 0 else -i for i in range(1, 10001)]]\", \"output\": null}, {\"input\": \"[[i if i % 3 == 0 else -i for i in range(1, 10001)]]\", \"output\": null}, {\"input\": \"[[i if i % 5 == 0 else -i for i in range(1, 10001)]]\", \"output\": null}, {\"input\": \"[list(range(1, 10001))]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\nvector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(strange_sort_list({1, 2, 3, 4}) , {1, 4, 2, 3}));\n    assert (issame(strange_sort_list({5, 6, 7, 8, 9}) , {5, 9, 6, 8, 7}));\n    assert (issame(strange_sort_list({1, 2, 3, 4, 5}) , {1, 5, 2, 4, 3}));\n    assert (issame(strange_sort_list({5, 6, 7, 8, 9, 1}) , {1, 9, 5, 8, 6, 7}));\n    assert (issame(strange_sort_list({5, 5, 5, 5}) , {5, 5, 5, 5}));\n    assert (issame(strange_sort_list({}) , {}));\n    assert (issame(strange_sort_list({1,2,3,4,5,6,7,8}) , {1, 8, 2, 7, 3, 6, 4, 5}));\n    assert (issame(strange_sort_list({0,2,2,2,5,5,-5,-5}) , {-5, 5, -5, 5, 0, 2, 2, 2}));\n    assert (issame(strange_sort_list({111111}) , {111111}));\n}\n",
        "cpp_stress_test": "#include<vector>\nusing namespace std;\nint main(){vector<int> v1;for(int i=1;i<=10000;++i)v1.push_back(i*((i%2==0)?-1:1));strange_sort_list(v1);vector<int> v2;for(int i=1;i<=10000;++i)v2.push_back(i%2==0?i:-i);strange_sort_list(v2);vector<int> v3;for(int i=1;i<=10000;++i)v3.push_back(i%3==0?i:-i);strange_sort_list(v3);vector<int> v4;for(int i=1;i<=10000;++i)v4.push_back(i%5==0?i:-i);strange_sort_list(v4);vector<int> v5;for(int i=1;i<=10000;++i)v5.push_back(i);strange_sort_list(v5);return 0;}"
    },
    {
        "task_id": "71",
        "entry_point": "triangle_area",
        "stress_test": "[{\"input\": \"[5000, 7000, 9000]\", \"output\": null}, {\"input\": \"[10000, 10000, 10000]\", \"output\": null}, {\"input\": \"[9999, 9999, 9999]\", \"output\": null}, {\"input\": \"[1000, 1000, 1000]\", \"output\": null}, {\"input\": \"[5000, 5000, 9999]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\nif (a+b<=c or a+c<=b or b+c<=a) return -1;\n    float h=(a+b+c)/2;\n    float area;\n    area=pow(h*(h-a)*(h-b)*(h-c),0.5);\n    return area;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (abs(triangle_area(3, 4, 5)-6.00)<0.01);\n    assert (abs(triangle_area(1, 2, 10) +1)<0.01);\n    assert (abs(triangle_area(4, 8, 5) -8.18)<0.01);\n    assert (abs(triangle_area(2, 2, 2) -1.73)<0.01);\n    assert (abs(triangle_area(1, 2, 3) +1)<0.01);\n    assert (abs(triangle_area(10, 5, 7) - 16.25)<0.01);\n    assert (abs(triangle_area(2, 6, 3) +1)<0.01);\n    assert (abs(triangle_area(1, 1, 1) -0.43)<0.01);\n    assert (abs(triangle_area(2, 2, 10) +1)<0.01);\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\nint main(){triangle_area(5000, 7000, 9000); triangle_area(10000, 10000, 10000); triangle_area(9999, 9999, 9999); triangle_area(1000, 1000, 1000); triangle_area(5000, 5000, 9999);}"
    },
    {
        "task_id": "72",
        "entry_point": "will_it_fly",
        "stress_test": "[{\"input\": \"[[0.1 for _ in range(10**4)] + [0.1 for _ in range(10**4-1, -1, -1)], 2 * 10**3]\", \"output\": null}, {\"input\": \"[[x%2 for x in range(4999)] + [x%2 for x in range(4999, -1, -1)], 5000]\", \"output\": null}, {\"input\": \"[[10**4 for _ in range(10**4)], 10**8]\", \"output\": null}, {\"input\": \"[[1]*5000 + [1]*5000, 10000]\", \"output\": null}, {\"input\": \"[[x for x in range(10**3)] + [x for x in range(10**3-1, -1, -1)] + [x for x in range(10**3)] + [x for x in range(10**3-1, -1, -1)], 4 * 10**6]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool will_it_fly(vector<int> q,int w){\nint sum=0;\n    for (int i=0;i<q.size();i++)\n    {\n        if (q[i]!=q[q.size()-1-i]) return false;\n        sum+=q[i];\n    }\n    if (sum>w) return false;\n    return true;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (will_it_fly({3, 2, 3}, 9)==true);\n    assert (will_it_fly({1, 2}, 5) == false);\n    assert (will_it_fly({3}, 5) == true);\n    assert (will_it_fly({3, 2, 3}, 1) == false);\n    assert (will_it_fly({1, 2, 3}, 6) ==false);\n    assert (will_it_fly({5}, 5) == true);\n}\n",
        "cpp_stress_test": "#include<vector>\nusing namespace std;\nint main(){vector<int> v1;for(int i=0;i<10000;++i)v1.push_back(1);for(int i=9999;i>=0;--i)v1.push_back(1);will_it_fly(v1,2000);vector<int> v2;for(int i=0;i<4999;++i)v2.push_back(i%2);for(int i=4999;i>=0;--i)v2.push_back(i%2);will_it_fly(v2,5000);vector<int> v3(10000,10000);will_it_fly(v3,100000000);vector<int> v4(10000,1);will_it_fly(v4,10000);vector<int> v5;for(int i=0;i<1000;++i)v5.push_back(i);for(int i=999;i>=0;--i)v5.push_back(i);for(int i=0;i<1000;++i)v5.push_back(i);for(int i=999;i>=0;--i)v5.push_back(i);will_it_fly(v5,4000000);return 0;}"
    },
    {
        "task_id": "73",
        "entry_point": "smallest_change",
        "stress_test": "[{\"input\": \"[[i for i in range(4999)] + [0] + [i for i in range(4999, 0, -1)]]\", \"output\": null}, {\"input\": \"[[i if i % 2 == 0 else 10**4 - i for i in range(10**4)]]\", \"output\": null}, {\"input\": \"[[j for i in range(5000) for j in (i, 10**4 - i)]]\", \"output\": null}, {\"input\": \"[[i for i in range(10**4)]]\", \"output\": null}, {\"input\": \"[[i for i in range(9999)] + [0]]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint smallest_change(vector<int> arr){\nint out=0;\n    for (int i=0;i<arr.size()-1-i;i++)\n        if (arr[i]!=arr[arr.size()-1-i])\n            out+=1;\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (smallest_change({1,2,3,5,4,7,9,6}) == 4);\n    assert (smallest_change({1, 2, 3, 4, 3, 2, 2}) == 1);\n    assert (smallest_change({1, 4, 2}) == 1);\n    assert (smallest_change({1, 4, 4, 2}) == 1);\n    assert (smallest_change({1, 2, 3, 2, 1}) == 0);\n    assert (smallest_change({3, 1, 1, 3}) == 0);\n    assert (smallest_change({1}) == 0);\n    assert (smallest_change({0, 1}) == 1);\n}\n",
        "cpp_stress_test": "int main(){smallest_change({[](){std::vector<int> v;for(int i=0;i<4999;++i)v.push_back(i);v.push_back(0);for(int i=4999;i>0;--i)v.push_back(i);return v;}()});smallest_change({[](){std::vector<int> v;for(int i=0;i<10000;++i)v.push_back(i%2==0?i:10000-i);return v;}()});smallest_change({[](){std::vector<int> v;for(int i=0;i<5000;++i){v.push_back(i);v.push_back(10000-i);}return v;}()});smallest_change({[](){std::vector<int> v;for(int i=0;i<10000;++i)v.push_back(i);return v;}()});smallest_change({[](){std::vector<int> v;for(int i=0;i<9999;++i)v.push_back(i);v.push_back(0);return v;}()});}"
    },
    {
        "task_id": "74",
        "entry_point": "total_match",
        "stress_test": "[{\"input\": \"[['x' * 500] * 10000, ['y' * 500] * 10000]\", \"output\": null}, {\"input\": \"[['a' * 1000] * 9999 + ['b'], ['c' * 1000] * 10000]\", \"output\": null}, {\"input\": \"[['longstring'] * 10000, ['short'] * 10000]\", \"output\": null}, {\"input\": \"[['a' * 1000] * 5000, ['b' * 500] * 10000]\", \"output\": null}, {\"input\": \"[['a' * 1000] * 5000, ['b' * 1000] * 5000]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector<string> lst2){\nint num1,num2,i;\n    num1=0;num2=0;\n    for (i=0;i<lst1.size();i++)\n        num1+=lst1[i].length();\n    for (i=0;i<lst2.size();i++)\n        num2+=lst2[i].length();\n    if (num1>num2) return lst2;\n    return lst1;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(total_match({}, {}) , {}));\n    assert (issame(total_match({\"hi\", \"admin\"}, {\"hi\", \"hi\"}) , {\"hi\", \"hi\"}));\n    assert (issame(total_match({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"}) , {\"hi\", \"admin\"}));\n    assert (issame(total_match({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"}) , {\"4\"}));\n    assert (issame(total_match({\"hi\", \"admin\"}, {\"hI\", \"Hi\"}) , {\"hI\", \"Hi\"}));\n    assert (issame(total_match({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"}) , {\"hI\", \"hi\", \"hi\"}));\n    assert (issame(total_match({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hii\"}) , {\"hi\", \"admin\"}));\n    assert (issame(total_match({}, {\"this\"}) , {}));\n    assert (issame(total_match({\"this\"}, {}) , {}));\n}\n",
        "cpp_stress_test": "#include<vector>\n#include<string>\nusing namespace std;\nint main() {\n    vector<string> lst1(10000, string(500, 'x'));\n    vector<string> lst2(10000, string(500, 'y'));\n    total_match(lst1, lst2);\n\n    vector<string> lst3(9999, string(1000, 'a'));\n    lst3.push_back(\"b\");\n    vector<string> lst4(10000, string(1000, 'c'));\n    total_match(lst3, lst4);\n\n    vector<string> lst5(10000, string(\"longstring\"));\n    vector<string> lst6(10000, string(\"short\"));\n    total_match(lst5, lst6);\n\n    vector<string> lst7(5000, string(1000, 'a'));\n    vector<string> lst8(10000, string(500, 'b'));\n    total_match(lst7, lst8);\n\n    vector<string> lst9(5000, string(1000, 'a'));\n    vector<string> lst10(5000, string(1000, 'b'));\n    total_match(lst9, lst10);\n\n    return 0;\n}"
    },
    {
        "task_id": "75",
        "entry_point": "is_multiply_prime",
        "stress_test": "[{\"input\": \"[97]\", \"output\": null}, {\"input\": \"[2 * 2 * 2 * 2]\", \"output\": null}, {\"input\": \"[2 * 2 * 3 * 3]\", \"output\": null}, {\"input\": \"[3 * 5 * 5]\", \"output\": null}, {\"input\": \"[3 * 3 * 11]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_multiply_prime(int a){\nint num=0;\n    for (int i=2;i*i<=a;i++)\n    while (a%i==0 and a>i)\n    {\n        a=a/i;\n        num+=1;\n    }\n    if (num==2) return true;\n    return false; \n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_multiply_prime(5) == false);\n    assert (is_multiply_prime(30) == true);\n    assert (is_multiply_prime(8) == true);\n    assert (is_multiply_prime(10) == false);\n    assert (is_multiply_prime(125) == true);\n    assert (is_multiply_prime(3 * 5 * 7) == true);\n    assert (is_multiply_prime(3 * 6 * 7) == false);\n    assert (is_multiply_prime(9 * 9 * 9) == false);\n    assert (is_multiply_prime(11 * 9 * 9) == false);\n    assert (is_multiply_prime(11 * 13 * 7) == true);\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\nint main(){ \n    is_multiply_prime(97);\n    is_multiply_prime(2 * 2 * 2 * 2);\n    is_multiply_prime(2 * 2 * 3 * 3);\n    is_multiply_prime(3 * 5 * 5);\n    is_multiply_prime(3 * 3 * 11);\n}"
    },
    {
        "task_id": "76",
        "entry_point": "is_simple_power",
        "stress_test": "[{\"input\": \"[134217728, 2]\", \"output\": null}, {\"input\": \"[8192, 2]\", \"output\": null}, {\"input\": \"[1048576, 4]\", \"output\": null}, {\"input\": \"[59049, 3]\", \"output\": null}, {\"input\": \"[1024, 2]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_simple_power(int x,int n){\nint p=1,count=0;\n    while (p<=x and count<100)\n    {\n        if (p==x) return true;\n        p=p*n;count+=1;\n    }\n    return false;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_simple_power(1, 4)== true);\n    assert (is_simple_power(2, 2)==true);\n    assert (is_simple_power(8, 2)==true);\n    assert (is_simple_power(3, 2)==false);\n    assert (is_simple_power(3, 1)==false);\n    assert (is_simple_power(5, 3)==false);\n    assert (is_simple_power(16, 2)== true);\n    assert (is_simple_power(143214, 16)== false);\n    assert (is_simple_power(4, 2)==true);\n    assert (is_simple_power(9, 3)==true);\n    assert (is_simple_power(16, 4)==true);\n    assert (is_simple_power(24, 2)==false);\n    assert (is_simple_power(128, 4)==false);\n    assert (is_simple_power(12, 6)==false);\n    assert (is_simple_power(1, 1)==true);\n    assert (is_simple_power(1, 12)==true);\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\nint main(){is_simple_power(134217728, 2); is_simple_power(8192, 2); is_simple_power(1048576, 4); is_simple_power(59049, 3); is_simple_power(1024, 2);}"
    },
    {
        "task_id": "77",
        "entry_point": "iscube",
        "stress_test": "[{\"input\": \"[-5832]\", \"output\": null}, {\"input\": \"[-125000]\", \"output\": null}, {\"input\": \"[-9261]\", \"output\": null}, {\"input\": \"[-6859]\", \"output\": null}, {\"input\": \"[-9999]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool iscuber(int a){\nfor (int i=0;i*i*i<=abs(a);i++)\n        if (i*i*i==abs(a)) return true;\n    return false;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (iscuber(1) == true);\n    assert (iscuber(2) == false);\n    assert (iscuber(-1) == true);\n    assert (iscuber(64) == true);\n    assert (iscuber(180) == false);\n    assert (iscuber(1000) == true);\n    assert (iscuber(0) == true);\n    assert (iscuber(1729) == false);\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\nint main(){iscuber(-5832); iscuber(-125000); iscuber(-9261); iscuber(-6859); iscuber(-9999);}"
    },
    {
        "task_id": "78",
        "entry_point": "hex_key",
        "stress_test": "[{\"input\": \"['B'*5000 + 'D'*5000]\", \"output\": null}, {\"input\": \"['0'*9999 + '1']\", \"output\": null}, {\"input\": \"['F'*10000]\", \"output\": null}, {\"input\": \"['13579BDF'*1250]\", \"output\": null}, {\"input\": \"['23456789ABCDEF'*625]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint hex_key(string num){\nstring key=\"2357BD\";\n    int out=0;\n    for (int i=0;i<num.length();i++)\n    if (find(key.begin(),key.end(),num[i])!=key.end()) out+=1;\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (hex_key(\"AB\") == 1      );\n    assert (hex_key(\"1077E\") == 2 );\n    assert (hex_key(\"ABED1A33\") == 4     );\n    assert (hex_key(\"2020\") == 2 );\n    assert (hex_key(\"123456789ABCDEF0\") == 6      );\n    assert (hex_key(\"112233445566778899AABBCCDDEEFF00\") == 12 );\n    assert (hex_key(\"\") == 0);\n}\n",
        "cpp_stress_test": "#include<string>\nusing namespace std;\nint main(){hex_key(string(5000, 'B') + string(5000, 'D'));hex_key(string(9999, '0') + '1');hex_key(string(10000, 'F'));string s4=\"\";for(int i=0;i<1250;++i)s4+=\"13579BDF\";hex_key(s4);string s5=\"\";for(int i=0;i<625;++i)s5+=\"23456789ABCDEF\";hex_key(s5);return 0;}"
    },
    {
        "task_id": "79",
        "entry_point": "decimal_to_binary",
        "stress_test": "[{\"input\": \"[262143]\", \"output\": null}, {\"input\": \"[5000]\", \"output\": null}, {\"input\": \"[8191]\", \"output\": null}, {\"input\": \"[4096]\", \"output\": null}, {\"input\": \"[131071]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring decimal_to_binary(int decimal){\nstring out=\"\";\n    if (decimal==0) return \"db0db\";\n    while (decimal>0)\n    {\n        out=to_string(decimal%2)+out;\n        decimal=decimal/2;\n    }\n    out=\"db\"+out+\"db\";\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (decimal_to_binary(0) == \"db0db\");\n    assert (decimal_to_binary(32) == \"db100000db\");\n    assert (decimal_to_binary(103) == \"db1100111db\");\n    assert (decimal_to_binary(15) == \"db1111db\");\n\n}\n",
        "cpp_stress_test": "#include <assert.h>\nint main() { decimal_to_binary(262143); decimal_to_binary(5000); decimal_to_binary(8191); decimal_to_binary(4096); decimal_to_binary(131071); }"
    },
    {
        "task_id": "80",
        "entry_point": "is_happy",
        "stress_test": "[{\"input\": \"[('abc' * 3333) + 'ab']\", \"output\": null}, {\"input\": \"['abcdefghij' * 1000]\", \"output\": null}, {\"input\": \"['abcd' * 2500]\", \"output\": null}, {\"input\": \"[('xyz' * 3333) + 'x']\", \"output\": null}, {\"input\": \"[''.join(chr((i % 26) + 97) for i in range(10000))]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_happy(string s){\nif (s.length()<3) return false;\n    for (int i=2;i<s.length();i++)\n    if (s[i]==s[i-1] or s[i]==s[i-2]) return false;\n    return true;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_happy(\"a\") == false );\n    assert (is_happy(\"aa\") == false );\n    assert (is_happy(\"abcd\") == true );\n    assert (is_happy(\"aabb\") == false );\n    assert (is_happy(\"adb\") == true );\n    assert (is_happy(\"xyy\") == false );\n    assert (is_happy(\"iopaxpoi\") == true );\n    assert (is_happy(\"iopaxioi\") == false );\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    is_happy(std::string(3333, 'a') + \"ab\");\n    is_happy(std::string(1000, 'abcdefghij'));\n    is_happy(std::string(2500, 'abcd'));\n    is_happy(std::string(3333, 'x') + \"x\");\n    is_happy([](){ std::string s; for(int i = 0; i < 10000; ++i) s += char((i % 26) + 97); return s;}());\n}"
    },
    {
        "task_id": "81",
        "entry_point": "numerical_letter_grade",
        "stress_test": "[{\"input\": \"[[round(i * 0.00005, 5) for i in range(20000)]]\", \"output\": null}, {\"input\": \"[[4.0, 4.0, 4.0] + [0.0, 0.0, 0.0] * 3333]\", \"output\": null}, {\"input\": \"[[round(j * 0.0001, 4) for j in range(10000)]]\", \"output\": null}, {\"input\": \"[[2.5] * 5000 + [1.5] * 5000]\", \"output\": null}, {\"input\": \"[[round(i * 0.0004, 4) for i in range(10000)]]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> numerical_letter_grade(vector<float> grades){\nvector<string> out={};\n    for (int i=0;i<grades.size();i++)\n    {\n        if (grades[i]>=3.9999) out.push_back(\"A+\");\n        if (grades[i]>3.7001 and grades[i]<3.9999) out.push_back(\"A\");\n        if (grades[i]>3.3001 and grades[i]<=3.7001) out.push_back(\"A-\");\n        if (grades[i]>3.0001 and grades[i]<=3.3001) out.push_back(\"B+\");\n        if (grades[i]>2.7001 and grades[i]<=3.0001) out.push_back(\"B\");\n        if (grades[i]>2.3001 and grades[i]<=2.7001) out.push_back(\"B-\");\n        if (grades[i]>2.0001 and grades[i]<=2.3001) out.push_back(\"C+\");\n        if (grades[i]>1.7001 and grades[i]<=2.0001) out.push_back(\"C\");\n        if (grades[i]>1.3001 and grades[i]<=1.7001) out.push_back(\"C-\");\n        if (grades[i]>1.0001 and grades[i]<=1.3001) out.push_back(\"D+\");\n        if (grades[i]>0.7001 and grades[i]<=1.0001) out.push_back(\"D\");\n        if (grades[i]>0.0001 and grades[i]<=0.7001) out.push_back(\"D-\");\n        if (grades[i]<=0.0001) out.push_back(\"E\");\n    }\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(numerical_letter_grade({4.0, 3, 1.7, 2, 3.5}) , {\"A+\", \"B\", \"C-\", \"C\", \"A-\"}));\n    assert (issame(numerical_letter_grade({1.2}) , {\"D+\"}));\n    assert (issame(numerical_letter_grade({0.5}) , {\"D-\"}));\n    assert (issame(numerical_letter_grade({0.0}) , {\"E\"}));\n    assert (issame(numerical_letter_grade({1, 0.3, 1.5, 2.8, 3.3}) , {\"D\", \"D-\", \"C-\", \"B\", \"B+\"}));\n    assert (issame(numerical_letter_grade({0, 0.7}) , {\"E\", \"D-\"}));\n    \n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include <vector>\n#include <cmath>\nusing namespace std;\nint main() { numerical_letter_grade([](){ vector<float> v; for(int i = 0; i < 20000; i++) v.push_back(round(i * 0.00005 * 100000.0) / 100000.0); return v; }()); vector<float> v2 = {4.0, 4.0, 4.0}; v2.insert(v2.end(), 3333 * 3, 0.0); numerical_letter_grade(v2); numerical_letter_grade([](){ vector<float> v; for(int j = 0; j < 10000; j++) v.push_back(round(j * 0.0001 * 10000.0) / 10000.0); return v; }()); vector<float> v4(5000, 2.5); v4.insert(v4.end(), 5000, 1.5); numerical_letter_grade(v4); numerical_letter_grade([](){ vector<float> v; for(int i = 0; i < 10000; i++) v.push_back(round(i * 0.0004 * 10000.0) / 10000.0); return v; }()); return 0; }"
    },
    {
        "task_id": "82",
        "entry_point": "prime_length",
        "stress_test": "[{\"input\": \"['c' * 99989]\", \"output\": null}, {\"input\": \"['a' * 99991]\", \"output\": null}, {\"input\": \"['e' * 99971]\", \"output\": null}, {\"input\": \"['m' * 10061]\", \"output\": null}, {\"input\": \"['d' * 10007]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool prime_length(string str){\nint l,i;\n    l=str.length();\n    if (l<2) return false;\n    for (i=2;i*i<=l;i++)\n    if (l%i==0) return false;\n    return true;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (prime_length(\"Hello\") == true);\n    assert (prime_length(\"abcdcba\") == true);\n    assert (prime_length(\"kittens\") == true);\n    assert (prime_length(\"orange\") == false);\n    assert (prime_length(\"wow\") == true);\n    assert (prime_length(\"world\") == true);\n    assert (prime_length(\"MadaM\") == true);\n    assert (prime_length(\"Wow\") == true);\n    assert (prime_length(\"\") == false);\n    assert (prime_length(\"HI\") == true);\n    assert (prime_length(\"go\") == true);\n    assert (prime_length(\"gogo\") == false);\n    assert (prime_length(\"aaaaaaaaaaaaaaa\") == false);\n    assert (prime_length(\"Madam\") == true);\n    assert (prime_length(\"M\") == false);\n    assert (prime_length(\"0\") == false);\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    prime_length(std::string(99989, 'c'));\n    prime_length(std::string(99991, 'a'));\n    prime_length(std::string(99971, 'e'));\n    prime_length(std::string(10061, 'm'));\n    prime_length(std::string(10007, 'd'));\n}"
    },
    {
        "task_id": "83",
        "entry_point": "starts_one_ends",
        "stress_test": "[{\"input\": \"[54321]\", \"output\": null}, {\"input\": \"[9999]\", \"output\": null}, {\"input\": \"[10000]\", \"output\": null}, {\"input\": \"[9998]\", \"output\": null}, {\"input\": \"[9876]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint starts_one_ends(int n){\nif (n<1) return 0;\n    if (n==1) return 1;\n    int out=18;\n    for (int i=2;i<n;i++)\n        out=out*10;\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (starts_one_ends(1) == 1);\n    assert (starts_one_ends(2) == 18);\n    assert (starts_one_ends(3) == 180);\n    assert (starts_one_ends(4) == 1800);\n    assert (starts_one_ends(5) == 18000);\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\nint main(){starts_one_ends(54321); starts_one_ends(9999); starts_one_ends(10000); starts_one_ends(9998); starts_one_ends(9876);}"
    },
    {
        "task_id": "84",
        "entry_point": "solve",
        "stress_test": "[{\"input\": \"[10000]\", \"output\": null}, {\"input\": \"[9999]\", \"output\": null}, {\"input\": \"[8888]\", \"output\": null}, {\"input\": \"[2468]\", \"output\": null}, {\"input\": \"[9876]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring solve(int N){\nstring str,bi=\"\";\n    str=to_string(N);\n    int i,sum=0;\n    for (int i=0;i<str.length();i++)\n        sum+=str[i]-48;\n    while (sum>0)\n    {\n        bi=to_string(sum%2)+bi;\n        sum=sum/2;\n    }\n    return bi;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (solve(1000) == \"1\");\n    assert (solve(150) == \"110\");\n    assert (solve(147) == \"1100\");\n    assert (solve(333) == \"1001\");\n    assert (solve(963) == \"10010\");\n}\n",
        "cpp_stress_test": "#include <string>\nusing namespace std;\nint main() {\n    solve(10000);\n    solve(9999);\n    solve(8888);\n    solve(2468);\n    solve(9876);\n    return 0;\n}"
    },
    {
        "task_id": "85",
        "entry_point": "add",
        "stress_test": "[{\"input\": \"[1234, 5678]\", \"output\": null}, {\"input\": \"[9999, 1]\", \"output\": null}, {\"input\": \"[8765, 4321]\", \"output\": null}, {\"input\": \"[2, 9998]\", \"output\": null}, {\"input\": \"[1024, 2048]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add(vector<int> lst){\nint sum=0;\n    for (int i=0;i*2+1<lst.size();i++)\n        if (lst[i*2+1]%2==0) sum+=lst[i*2+1];\n    return sum;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (add({4, 88}) == 88);\n    assert (add({4, 5, 6, 7, 2, 122}) == 122);\n    assert (add({4, 0, 6, 7}) == 0);\n    assert (add({4, 4, 6, 8}) == 12);\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    add({1234, 5678});\n    add({9999, 1});\n    add({8765, 4321});\n    add({2, 9998});\n    add({1024, 2048});\n}"
    },
    {
        "task_id": "86",
        "entry_point": "anti_shuffle",
        "stress_test": "[{\"input\": \"[' '.join(['a' * (i % 100) for i in range(10000)])]\", \"output\": null}, {\"input\": \"[' '.join(['Complex' + '?' * i for i in range(1000)])]\", \"output\": null}, {\"input\": \"[' '.join(['Hello' + '!' * i for i in range(1000)])]\", \"output\": null}, {\"input\": \"[' '.join([str(i) for i in range(10000)])]\", \"output\": null}, {\"input\": \"[' '.join(['Test' + '!' * i for i in range(500)])]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring anti_shuffle(string s){\nstring out=\"\";\n    string current=\"\";\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n    if (s[i]==' ')\n    {\n        sort(current.begin(),current.end());\n        if (out.length()>0) out=out+' ';\n        out=out+current;\n        current=\"\";\n    }\n    else current=current+s[i];\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (anti_shuffle(\"Hi\") == \"Hi\");\n    assert (anti_shuffle(\"hello\") == \"ehllo\");\n    assert (anti_shuffle(\"number\") == \"bemnru\");\n    assert (anti_shuffle(\"abcd\") == \"abcd\");\n    assert (anti_shuffle(\"Hello World!!!\") == \"Hello !!!Wdlor\");\n    assert (anti_shuffle(\"\") == \"\");\n    assert (anti_shuffle(\"Hi. My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\");\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\n#include<string>\n#include<sstream>\nstd::string generate_long_string_a() { std::ostringstream oss; for (int i = 0; i < 10000; ++i) { if (i > 0) oss << ' '; oss << std::string(i % 100, 'a'); } return oss.str(); } std::string generate_long_string_complex() { std::ostringstream oss; for (int i = 0; i < 1000; ++i) { if (i > 0) oss << ' '; oss << \"Complex\" + std::string(i, '?'); } return oss.str(); } std::string generate_long_string_hello() { std::ostringstream oss; for (int i = 0; i < 1000; ++i) { if (i > 0) oss << ' '; oss << \"Hello\" + std::string(i, '!'); } return oss.str(); } std::string generate_long_string_numbers() { std::ostringstream oss; for (int i = 0; i < 10000; ++i) { if (i > 0) oss << ' '; oss << std::to_string(i); } return oss.str(); } std::string generate_long_string_test() { std::ostringstream oss; for (int i = 0; i < 500; ++i) { if (i > 0) oss << ' '; oss << \"Test\" + std::string(i, '!'); } return oss.str(); } int main() { generate_long_string_a(); generate_long_string_complex(); generate_long_string_hello(); generate_long_string_numbers(); generate_long_string_test(); }"
    },
    {
        "task_id": "87",
        "entry_point": "get_row",
        "stress_test": "[{\"input\": \"[[[i for i in range(1000)] for _ in range(1000)], 500]\", \"output\": null}, {\"input\": \"[[[int(j/1000) for j in range(10000)] for i in range(10)], 9]\", \"output\": null}, {\"input\": \"[[[i for i in range(50)] + [50 for _ in range(50)] for _ in range(200)], 50]\", \"output\": null}, {\"input\": \"[[[1] * 5000, [2] * 5000, [3] * 5000, [4] * 5000], 2]\", \"output\": null}, {\"input\": \"[[[1 if (i + j) % 2 == 0 else 0 for i in range(100)] for j in range(100)], 1]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<vector<int>> get_row(vector<vector<int>> lst, int x){\nvector<vector<int>> out={};\n    for (int i=0;i<lst.size();i++)\n    for (int j=lst[i].size()-1;j>=0;j-=1)\n    if (lst[i][j]==x) out.push_back({i,j});\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<vector<int>> a,vector<vector<int>> b){\n    if (a.size()!=b.size()) return false;\n\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i].size()!=b[i].size()) return false;\n        for (int j=0;j<a[i].size();j++)\n            if (a[i][j]!=b[i][j]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(get_row({\n        {1,2,3,4,5,6},\n        {1,2,3,4,1,6},\n        {1,2,3,4,5,1}}, 1) , {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}));\n    assert (issame(get_row({\n        {1,2,3,4,5,6},\n        {1,2,3,4,5,6},\n        {1,2,3,4,5,6},\n        {1,2,3,4,5,6},\n        {1,2,3,4,5,6},\n        {1,2,3,4,5,6}}, 2) , {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}}));\n    assert (issame(get_row({\n        {1,2,3,4,5,6},\n        {1,2,3,4,5,6},\n        {1,1,3,4,5,6},\n        {1,2,1,4,5,6},\n        {1,2,3,1,5,6},\n        {1,2,3,4,1,6},\n        {1,2,3,4,5,1}\n    }, 1) , {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}}));\n    assert (issame(get_row({}, 1) , {}));\n    assert (issame(get_row({{1}}, 2) , {}));\n    assert (issame(get_row({{}, {1}, {1, 2, 3}}, 3) , {{2, 2}}));\n}\n",
        "cpp_stress_test": "#include<vector>\nusing namespace std;\nint main() {\n    vector<vector<int>> mat1(1000, vector<int>(1000));\n    for (int i = 0; i < 1000; ++i)\n        for (int j = 0; j < 1000; ++j)\n            mat1[i][j] = j;\n    get_row(mat1, 500);\n\n    vector<vector<int>> mat2(10, vector<int>(10000));\n    for (int i = 0; i < 10; ++i)\n        for (int j = 0; j < 10000; ++j)\n            mat2[i][j] = j / 1000;\n    get_row(mat2, 9);\n\n    vector<vector<int>> mat3(200, vector<int>(100));\n    for (int i = 0; i < 200; ++i) {\n        for (int j = 0; j < 50; ++j) mat3[i][j] = j;\n        for (int j = 50; j < 100; ++j) mat3[i][j] = 50;\n    }\n    get_row(mat3, 50);\n\n    vector<vector<int>> mat4 = {\n        vector<int>(5000, 1),\n        vector<int>(5000, 2),\n        vector<int>(5000, 3),\n        vector<int>(5000, 4)\n    };\n    get_row(mat4, 2);\n\n    vector<vector<int>> mat5(100, vector<int>(100));\n    for (int j = 0; j < 100; ++j)\n        for (int i = 0; i < 100; ++i)\n            mat5[j][i] = ((i + j) % 2 == 0) ? 1 : 0;\n    get_row(mat5, 1);\n\n    return 0;\n}"
    },
    {
        "task_id": "88",
        "entry_point": "sort_array",
        "stress_test": "[{\"input\": \"[[i*i % 1000 for i in range(10000)]]\", \"output\": null}, {\"input\": \"[[int(x) for x in '1234567890'*1000]]\", \"output\": null}, {\"input\": \"[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]*1000]\", \"output\": null}, {\"input\": \"[[i % 100 for i in range(10000)]]\", \"output\": null}, {\"input\": \"[[0, 1] * 5000]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> array){\nif (array.size()==0) return {};\n    if ((array[0]+array[array.size()-1]) %2==1)\n    {\n        sort(array.begin(),array.end());\n        return array;\n    }\n    else\n    {\n        sort(array.begin(),array.end());\n        vector<int> out={};\n        for (int i=array.size()-1;i>=0;i-=1)\n            out.push_back(array[i]);\n        return out;\n    }\n\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sort_array({}) , {}));\n    assert (issame(sort_array({5}) , {5}));\n    assert (issame(sort_array({2, 4, 3, 0, 1, 5}) , {0, 1, 2, 3, 4, 5}));\n    assert (issame(sort_array({2, 4, 3, 0, 1, 5, 6}) , {6, 5, 4, 3, 2, 1, 0}));\n    assert (issame(sort_array({2, 1}) , {1, 2}));\n    assert (issame(sort_array({15, 42, 87, 32 ,11, 0}) , {0, 11, 15, 32, 42, 87}));\n    assert (issame(sort_array({21, 14, 23, 11}) , {23, 21, 14, 11}));\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<vector>\nusing namespace std;\nint main(){sort_array({[](){vector<int>v;for(int i=0;i<10000;++i)v.push_back(i*i%1000);return v;}()});sort_array([](){vector<int>v;for(int i=0;i<10000;++i)v.push_back((i%10)+1);return v;}());sort_array({[&](){vector<int>v(10000);for(int i=0;i<1000;++i)for(int j=1;j<=10;++j)v[(i*10)+(j-1)]=j;return v;}()});sort_array({[](){vector<int>v;for(int i=0;i<10000;++i)v.push_back(i%100);return v;}()});sort_array({[](){vector<int>v(10000);for(int i=0;i<5000;++i){v[i*2]=0;v[i*2+1]=1;}return v;}()});}"
    },
    {
        "task_id": "89",
        "entry_point": "encrypt",
        "stress_test": "[{\"input\": \"['abcdefghijklmnopqrstuvwxyz' + 'a' * 9997]\", \"output\": null}, {\"input\": \"[''.join(chr(97 + (i % 26)) for i in range(10000))]\", \"output\": null}, {\"input\": \"[''.join('a' if i % 2 == 0 else 'z' for i in range(10000))]\", \"output\": null}, {\"input\": \"['s' * 9999 + 't']\", \"output\": null}, {\"input\": \"['hello' * 2000]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\nstring out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (encrypt(\"hi\") == \"lm\");\n    assert (encrypt(\"asdfghjkl\") == \"ewhjklnop\");\n    assert (encrypt(\"gf\") == \"kj\");\n    assert (encrypt(\"et\") == \"ix\");\n    assert (encrypt(\"faewfawefaewg\")==\"jeiajeaijeiak\");\n    assert (encrypt(\"hellomyfriend\")==\"lippsqcjvmirh\");\n    assert (encrypt(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")==\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\");\n    assert (encrypt(\"a\")==\"e\");\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    encrypt(\"abcdefghijklmnopqrstuvwxyz\" + std::string(9997, 'a')); \n    encrypt([](){std::string s; for(int i = 0; i < 10000; ++i) s += char(97 + (i % 26)); return s;}()); \n    encrypt([](){std::string s; for(int i = 0; i < 10000; ++i) s += (i % 2 == 0 ? 'a' : 'z'); return s;}()); \n    encrypt(std::string(9999, 's') + 't'); \n    encrypt(std::string(2000, 'h') + std::string(2000, 'e') + std::string(2000, 'l') + std::string(2000, 'l') + std::string(2000, 'o'));\n}"
    },
    {
        "task_id": "90",
        "entry_point": "next_smallest",
        "stress_test": "[{\"input\": \"[[x for x in range(-10**4, 10**4) if x % 5 != 0]]\", \"output\": null}, {\"input\": \"[[i for i in range(5000, -5000, -1)] + [5000]*5000]\", \"output\": null}, {\"input\": \"[list(set(range(-5*10**3, 5*10**3)))]\", \"output\": null}, {\"input\": \"[[i*(-1)**i for i in range(1, 10001)]]\", \"output\": null}, {\"input\": \"[[10000] + [i for i in range(9999, 0, -1)] + [-10000]]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint next_smallest(vector<int> lst){\nsort(lst.begin(),lst.end());\n    for (int i=1;i<lst.size();i++)\n        if (lst[i]!=lst[i-1]) return lst[i];\n    return -1;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (next_smallest({1, 2, 3, 4, 5}) == 2);\n    assert (next_smallest({5, 1, 4, 3, 2}) == 2);\n    assert (next_smallest({}) == -1);\n    assert (next_smallest({1, 1}) == -1);\n    assert (next_smallest({1,1,1,1,0}) == 1);\n    assert (next_smallest({-35, 34, 12, -45}) == -35);\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\nint main(){next_smallest({});next_smallest({});next_smallest({});next_smallest({});next_smallest({});}"
    },
    {
        "task_id": "91",
        "entry_point": "is_bored",
        "stress_test": "[{\"input\": \"['I' + '. I' * 9999]\", \"output\": null}, {\"input\": \"['I' + '!' * 5000 + '? ' + 'I' + '.' * 4999]\", \"output\": null}, {\"input\": \"['I.' * 5000]\", \"output\": null}, {\"input\": \"['I' + '?' * 2500 + '. ' + 'I' + '!' * 2500]\", \"output\": null}, {\"input\": \"['I' + '. I' * 1000 + '. I am tired.']\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_bored(string S){\nbool isstart=true;\n    bool isi=false;\n    int sum=0;\n    for (int i=0;i<S.length();i++)\n    {\n        if (S[i]==' ' and isi) {isi=false; sum+=1;}\n        if (S[i]=='I' and isstart) {isi=true;  }\n        else isi=false;   \n        if (S[i]!=' ') { isstart=false;}\n        if (S[i]=='.' or S[i]=='?' or S[i]=='!') isstart=true;\n    }\n    return sum;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_bored(\"Hello world\") == 0);\n    assert (is_bored(\"Is the sky blue?\") == 0);\n    assert (is_bored(\"I love It !\") == 1);\n    assert (is_bored(\"bIt\") == 0);\n    assert (is_bored(\"I feel good today. I will be productive. will kill It\") == 2);\n    assert (is_bored(\"You and I are going for a walk\") == 0);\n}\n",
        "cpp_stress_test": "#include<string>\n#include<iostream>\nusing namespace std;\nint main() {\n    string s1 = \"I\"; for (int i = 0; i < 9999; ++i) s1 += \". I\"; is_bored(s1);\n    string s2 = \"I\" + string(5000, '!') + \"? I\" + string(4999, '.'); is_bored(s2);\n    string s3; for (int i = 0; i < 5000; ++i) s3 += \"I.\"; is_bored(s3);\n    string s4 = \"I\" + string(2500, '?') + \". I\" + string(2500, '!'); is_bored(s4);\n    string s5 = \"I\"; for (int i = 0; i < 1000; ++i) s5 += \". I\"; s5 += \". I am tired.\"; is_bored(s5);\n    return 0;\n}"
    },
    {
        "task_id": "92",
        "entry_point": "any_int",
        "stress_test": "[{\"input\": \"[123456789, 987654321, -864197532]\", \"output\": null}, {\"input\": \"[100000, 50000, 50000]\", \"output\": null}, {\"input\": \"[10**4, 10**4 - 1, 1]\", \"output\": null}, {\"input\": \"[10**3, 10**3 - 1, -1]\", \"output\": null}, {\"input\": \"[999999999, 999999999, 1999999998]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool any_int(float a,float b,float c){\nif (round(a)!=a) return false;\n    if (round(b)!=b) return false;\n    if (round(c)!=c) return false;\n    if (a+b==c or a+c==b or b+c==a) return true;\n    return false;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (any_int(2, 3, 1)==true);\n    assert (any_int(2.5, 2, 3)==false);\n    assert (any_int(1.5, 5, 3.5)==false);\n    assert (any_int(2, 6, 2)==false);\n    assert (any_int(4, 2, 2)==true);\n    assert (any_int(2.2, 2.2, 2.2)==false);\n    assert (any_int(-4, 6, 2)==true);\n    assert (any_int(2,1,1)==true);\n    assert (any_int(3,4,7)==true);\n    assert (any_int(3.01,4,7)==false);\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\nint main(){ any_int(123456789, 987654321, -864197532); any_int(100000, 50000, 50000); any_int(10000, 9999, 1); any_int(1000, 999, -1); any_int(999999999, 999999999, 1999999998); }"
    },
    {
        "task_id": "93",
        "entry_point": "encode",
        "stress_test": "[{\"input\": \"[''.join(['M' + 'u' * 9999])]\", \"output\": null}, {\"input\": \"[''.join(['a' if i % 2 == 0 else 'e' for i in range(10000)])]\", \"output\": null}, {\"input\": \"[' '.join([''.join([''.join(['aeiouAEIOU'[(i % 10)] for i in range(100)]) for _ in range(5)]) for _ in range(20)])]\", \"output\": null}, {\"input\": \"[''.join(['AEIOUaeiou'[(i % 10)] for i in range(9999)])]\", \"output\": null}, {\"input\": \"[''.join(['A' if i % 2 == 0 else 'E' for i in range(10000)])]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring encode(string message){\nstring vowels=\"aeiouAEIOU\";\n    string out=\"\";\n    for (int i=0;i<message.length();i++)\n    {\n        char w=message[i];\n        if (w>=97 and w<=122){w=w-32;}\n        else if (w>=65 and w<=90) w=w+32;\n        if (find(vowels.begin(),vowels.end(),w)!=vowels.end()) w=w+2;\n        out=out+w;\n    }\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (encode(\"TEST\") == \"tgst\");\n    assert (encode(\"Mudasir\") == \"mWDCSKR\");\n    assert (encode(\"YES\") == \"ygs\");\n    assert (encode(\"This is a message\") == \"tHKS KS C MGSSCGG\");\n    assert (encode(\"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\");\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\n#include<string>\n#include<iostream>\n#include<vector>\nint main(){std::string test1(9999, 'u'); test1.insert(0, \"M\"); std::string test2; for(int i = 0; i < 10000; i++) test2 += (i % 2 == 0) ? 'a' : 'e'; std::string test3; std::string vowels = \"aeiouAEIOU\"; for(int i = 0; i < 20; i++) { for(int j = 0; j < 5; j++) { for(int k = 0; k < 100; k++) { test3 += vowels[k % 10]; } } test3 += ' '; } std::string test4; for(int i = 0; i < 9999; i++) test4 += \"AEIOUaeiou\"[i % 10]; std::string test5; for(int i = 0; i < 10000; i++) test5 += (i % 2 == 0) ? 'A' : 'E'; }"
    },
    {
        "task_id": "94",
        "entry_point": "skjkasdkd",
        "stress_test": "[{\"input\": \"[list(range(1, 10001))]\", \"output\": null}, {\"input\": \"[[2147483647, 2147483629, 2147483587, 2147483563, 2147483549, 2147483523, 2147483517, 2147483493]]\", \"output\": null}, {\"input\": \"[[15485863, 15485867, 15485873, 15485879, 15485881, 15485903, 15485909, 15485917, 15485923, 15485927, 15485933, 15485941, 15485963, 15485971, 15485981, 15485989]]\", \"output\": null}, {\"input\": \"[[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499] * 50]\", \"output\": null}, {\"input\": \"[[2]*5000 + [3]*5000]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\nint largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            for (int j=2;j*j<=lst[i];j++)\n                if (lst[i]%j==0) prime=false;\n            if (prime) largest=lst[i];\n        }\n    int sum=0;\n    string s;\n    s=to_string(largest);\n    for (int i=0;i<s.length();i++)\n        sum+=s[i]-48;\n    return sum;\n}\n#undef NDEBUG\n#include<assert.h>",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (skjkasdkd({0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3}) == 10);\n    assert (skjkasdkd({1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1}) == 25);\n    assert (skjkasdkd({1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3}) == 13);\n    assert (skjkasdkd({0,724,32,71,99,32,6,0,5,91,83,0,5,6}) == 11);\n    assert (skjkasdkd({0,81,12,3,1,21}) == 3);\n    assert (skjkasdkd({0,8,1,2,1,7}) == 7);\n    assert (skjkasdkd({8191}) == 19);\n    assert (skjkasdkd({8191, 123456, 127, 7}) == 19);\n    assert (skjkasdkd({127, 97, 8192}) == 10);\n}\n",
        "cpp_stress_test": "#include<vector>\nusing namespace std;\nint main() {\nvector<int> input1;\nfor (int i = 1; i <= 10000; ++i) input1.push_back(i);\nskjkasdkd(input1);\nskjkasdkd({2147483629, 2147483587, 2147483563, 2147483549, 2147483523, 2147483517, 2147483493});\nskjkasdkd({15485863, 15485867, 15485873, 15485879, 15485881, 15485903, 15485909, 15485917, 15485923, 15485927, 15485933, 15485941, 15485963, 15485971, 15485981, 15485989});\nvector<int> input3 = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499};\nvector<int> input4;\nfor (int i = 0; i < 50; ++i) input4.insert(input4.end(), input3.begin(), input3.end());\nskjkasdkd(input4);\nvector<int> input5(5000, 2);\ninput5.insert(input5.end(), 5000, 3);\nskjkasdkd(input5);\nreturn 0;\n}"
    },
    {
        "task_id": "95",
        "entry_point": "check_dict_case",
        "stress_test": "[{\"input\": \"[{'apple': 'a', 'banana': 'b', 'cherry': 'c', 'date': 'd', 'elderberry': 'e', 'fig': 'f', 'grape': 'g', 'honeydew': 'h', 'kiwi': 'i', 'lemon': 'j', 'kumquat': 'k', 'lychee': 'l', 'mango': 'm', 'nectarine': 'n', 'orange': 'o', 'papaya': 'p', 'quince': 'q', 'raspberry': 'r', 'strawberry': 's', 'tangerine': 't', 'ugli fruit': 'u', 'vanilla': 'v', 'watermelon': 'w', 'xigua': 'x', 'yellow passion fruit': 'y', 'zucchini': 'z'}]\", \"output\": null}, {\"input\": \"[{'a'*i: 'value' for i in range(1, 5001)} | {'A'*i: 'value' for i in range(5001, 10001)}]\", \"output\": null}, {\"input\": \"[{'a'*i: 'value' for i in range(1, 10001)}]\", \"output\": null}, {\"input\": \"[{'a': 'apple', 'B': 'banana', 'c': 'cherry', 'D': 'date', 'e': 'elderberry', 'F': 'fig', 'g': 'grape', 'H': 'honeydew', 'i': 'kiwi', 'J': 'lemon'}]\", \"output\": null}, {\"input\": \"[{'a': 'apple', 'B': 'banana', 'c': 'cherry', 'D': 'date', 'e': 'elderberry', 'F': 'fig', 'g': 'grape', 'H': 'honeydew', 'i': 'iceberg lettuce'}]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool check_dict_case(map<string,string> dict){\nmap<string,string>::iterator it;\n    int islower=0,isupper=0;\n    if (dict.size()==0) return false;\n    for (it=dict.begin();it!=dict.end();it++)\n    {\n        string key=it->first;\n    \n        for (int i=0;i<key.length();i++)\n        {\n            if (key[i]<65 or (key[i]>90 and key[i]<97) or key[i]>122) return false;\n            if (key[i]>=65 and key[i]<=90) isupper=1;\n            if (key[i]>=97 and key[i]<=122) islower=1;\n            if (isupper+islower==2) return false;\n        }\n\n    }\n    return true;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (check_dict_case({{\"p\",\"pineapple\"}, {\"b\",\"banana\"}}) == true);\n    assert (check_dict_case({{\"p\",\"pineapple\"}, {\"A\",\"banana\"}, {\"B\",\"banana\"}}) == false);\n    assert (check_dict_case({{\"p\",\"pineapple\"}, {\"5\",\"banana\"}, {\"a\",\"apple\"}}) == false);\n    assert (check_dict_case({{\"Name\",\"John\"}, {\"Age\",\"36\"}, {\"City\",\"Houston\"}}) == false);\n    assert (check_dict_case({{\"STATE\",\"NC\"}, {\"ZIP\",\"12345\"} }) == true  );\n    assert (check_dict_case({{\"fruit\",\"Orange\"}, {\"taste\",\"Sweet\"} }) == true  );\n    assert (check_dict_case({}) == false);\n}\n",
        "cpp_stress_test": "#include<map>\n#include<string>\nusing namespace std;\nint main() {\ncheck_dict_case({{\"apple\",\"a\"}, {\"banana\",\"b\"}, {\"cherry\",\"c\"}, {\"date\",\"d\"}, {\"elderberry\",\"e\"}, {\"fig\",\"f\"}, {\"grape\",\"g\"}, {\"honeydew\",\"h\"}, {\"kiwi\",\"i\"}, {\"lemon\",\"j\"}, {\"kumquat\",\"k\"}, {\"lychee\",\"l\"}, {\"mango\",\"m\"}, {\"nectarine\",\"n\"}, {\"orange\",\"o\"}, {\"papaya\",\"p\"}, {\"quince\",\"q\"}, {\"raspberry\",\"r\"}, {\"strawberry\",\"s\"}, {\"tangerine\",\"t\"}, {\"ugli fruit\",\"u\"}, {\"vanilla\",\"v\"}, {\"watermelon\",\"w\"}, {\"xigua\",\"x\"}, {\"yellow passion fruit\",\"y\"}, {\"zucchini\",\"z\"}});\nmap<string,string> map1, map2;\nfor(int i = 1; i <= 5000; ++i) map1[string(i, 'a')] = \"value\";\nfor(int i = 5001; i <= 10000; ++i) map2[string(i, 'A')] = \"value\";\nmap1.insert(map2.begin(), map2.end());\ncheck_dict_case(map1);\nmap<string,string> map3;\nfor(int i = 1; i <= 10000; ++i) map3[string(i, 'a')] = \"value\";\ncheck_dict_case(map3);\ncheck_dict_case({{\"a\",\"apple\"}, {\"B\",\"banana\"}, {\"c\",\"cherry\"}, {\"D\",\"date\"}, {\"e\",\"elderberry\"}, {\"F\",\"fig\"}, {\"g\",\"grape\"}, {\"H\",\"honeydew\"}, {\"i\",\"kiwi\"}, {\"J\",\"lemon\"}});\ncheck_dict_case({{\"a\",\"apple\"}, {\"B\",\"banana\"}, {\"c\",\"cherry\"}, {\"D\",\"date\"}, {\"e\",\"elderberry\"}, {\"F\",\"fig\"}, {\"g\",\"grape\"}, {\"H\",\"honeydew\"}, {\"i\",\"iceberg lettuce\"}});\nreturn 0;\n}"
    },
    {
        "task_id": "96",
        "entry_point": "count_up_to",
        "stress_test": "[{\"input\": \"[9998]\", \"output\": null}, {\"input\": \"[9999]\", \"output\": null}, {\"input\": \"[10000]\", \"output\": null}, {\"input\": \"[9973]\", \"output\": null}, {\"input\": \"[9876]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\nvector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(count_up_to(5) , {2,3}));\n    assert (issame(count_up_to(6) , {2,3,5}));\n    assert (issame(count_up_to(7) , {2,3,5}));\n    assert (issame(count_up_to(10) , {2,3,5,7}));\n    assert (issame(count_up_to(0) , {}));\n    assert (issame(count_up_to(22) , {2,3,5,7,11,13,17,19}));\n    assert (issame(count_up_to(1) , {}));\n    assert (issame(count_up_to(18) , {2,3,5,7,11,13,17}));\n    assert (issame(count_up_to(47) , {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43}));\n    assert (issame(count_up_to(101) , {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}));\n}\n",
        "cpp_stress_test": "#include<vector>\nusing namespace std;\nint main(){count_up_to(9998);count_up_to(9999);count_up_to(10000);count_up_to(9973);count_up_to(9876);}"
    },
    {
        "task_id": "97",
        "entry_point": "multiply",
        "stress_test": "[{\"input\": \"[-9999, 8888]\", \"output\": null}, {\"input\": \"[-77777, 88888]\", \"output\": null}, {\"input\": \"[999, -999]\", \"output\": null}, {\"input\": \"[1000, -1000]\", \"output\": null}, {\"input\": \"[-987654321, 123456789]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint multiply(int a,int b){\nreturn (abs(a)%10)*(abs(b)%10);\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (multiply(148, 412) == 16                   );\n    assert (multiply(19, 28) == 72       );\n    assert (multiply(2020, 1851) == 0);\n    assert (multiply(14,-15) == 20   );\n    assert (multiply(76, 67) == 42    );\n    assert (multiply(17, 27) == 49    );\n    assert (multiply(0, 1) == 0);\n    assert (multiply(0, 0) == 0);\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\nint main(){multiply(-9999, 8888);multiply(-77777, 88888);multiply(999, -999);multiply(1000, -1000);multiply(-987654321, 123456789);}"
    },
    {
        "task_id": "98",
        "entry_point": "count_upper",
        "stress_test": "[{\"input\": \"['U'*5000 + 'O'*5000 + 'I'*5000 + 'E'*5000]\", \"output\": null}, {\"input\": \"['A'*2500 + 'E'*2500 + 'I'*2500 + 'O'*2500 + 'U'*2500]\", \"output\": null}, {\"input\": \"[''*2500 + 'A'*2500 + 'E'*2500 + 'I'*2500 + 'O'*2500 + 'U'*2500]\", \"output\": null}, {\"input\": \"['A'*5000 + 'O'*5000]\", \"output\": null}, {\"input\": \"['A'*2500 + 'E'*2500 + 'I'*2500 + 'O'*2500]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_upper(string s){\nstring uvowel=\"AEIOU\";\n    int count=0;\n    for (int i=0;i*2<s.length();i++)\n    if (find(uvowel.begin(),uvowel.end(),s[i*2])!=uvowel.end())\n        count+=1;\n    return count;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (count_upper(\"aBCdEf\")  == 1);\n    assert (count_upper(\"abcdefg\") == 0);\n    assert (count_upper(\"dBBE\") == 0);\n    assert (count_upper(\"B\")  == 0);\n    assert (count_upper(\"U\")  == 1);\n    assert (count_upper(\"\") == 0);\n    assert (count_upper(\"EEEE\") == 2);\n}\n",
        "cpp_stress_test": "#include <iostream>\nint main() { count_upper(std::string('U', 5000) + std::string('O', 5000) + std::string('I', 5000) + std::string('E', 5000)); count_upper(std::string('A', 2500) + std::string('E', 2500) + std::string('I', 2500) + std::string('O', 2500) + std::string('U', 2500)); count_upper(std::string('A', 2500) + std::string('E', 2500) + std::string('I', 2500) + std::string('O', 2500) + std::string('U', 2500)); count_upper(std::string('A', 5000) + std::string('O', 5000)); count_upper(std::string('A', 2500) + std::string('E', 2500) + std::string('I', 2500) + std::string('O', 2500)); return 0; }"
    },
    {
        "task_id": "99",
        "entry_point": "closest_integer",
        "stress_test": "[{\"input\": \"['1234567890.123456789']\", \"output\": null}, {\"input\": \"['-9876543210.987654321']\", \"output\": null}, {\"input\": \"['-2.718281828459045']\", \"output\": null}, {\"input\": \"['3.141592653589793']\", \"output\": null}, {\"input\": \"['-9999999999.999']\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint closest_integer(string value){\ndouble w;\n    w=atof(value.c_str());\n    return round(w);\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (closest_integer(\"10\") == 10);\n    assert (closest_integer(\"14.5\") == 15);\n    assert (closest_integer(\"-15.5\") == -16);\n    assert (closest_integer(\"15.3\") == 15);\n    assert (closest_integer(\"0\") == 0);\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\nint main(){closest_integer(\"1234567890.123456789\");closest_integer(\"-9876543210.987654321\");closest_integer(\"-2.718281828459045\");closest_integer(\"3.141592653589793\");closest_integer(\"-9999999999.999\");}"
    },
    {
        "task_id": "100",
        "entry_point": "make_a_pile",
        "stress_test": "[{\"input\": \"[10000]\", \"output\": null}, {\"input\": \"[9999]\", \"output\": null}, {\"input\": \"[9876]\", \"output\": null}, {\"input\": \"[8765]\", \"output\": null}, {\"input\": \"[7890]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> make_a_pile(int n){\nvector<int> out={n};\n    for (int i=1;i<n;i++)\n        out.push_back(out[out.size()-1]+2);\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(make_a_pile(3) , {3, 5, 7}));\n    assert (issame(make_a_pile(4) , {4,6,8,10}));\n    assert (issame(make_a_pile(5) , {5, 7, 9, 11, 13}));\n    assert (issame(make_a_pile(6) , {6, 8, 10, 12, 14, 16}));\n    assert (issame(make_a_pile(8) , {8, 10, 12, 14, 16, 18, 20, 22}));\n}\n",
        "cpp_stress_test": "#include<vector>\nusing namespace std;\n\nint main(){\n    make_a_pile(10000);\n    make_a_pile(9999);\n    make_a_pile(9876);\n    make_a_pile(8765);\n    make_a_pile(7890);\n}"
    },
    {
        "task_id": "101",
        "entry_point": "words_string",
        "stress_test": "[{\"input\": \"[' '.join(['word' + str(i) for i in range(10000)])]\", \"output\": null}, {\"input\": \"['word1 word2, word3, ' * 3333 + 'word4']\", \"output\": null}, {\"input\": \"[', '.join(['word' + str(i) for i in range(5000)]) + ', end']\", \"output\": null}, {\"input\": \"['a'*10000 + ', b'*9999 + ', c']\", \"output\": null}, {\"input\": \"['alpha, ' * 4999 + 'omega']\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> words_string(string s){\nstring current=\"\";\n    vector<string> out={};\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n     if (s[i]==' ' or s[i]==',')\n     {\n        if (current.length()>0)\n        {\n            out.push_back(current);\n            current=\"\";\n        }\n     }\n     else current=current+s[i];\n     return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(words_string(\"Hi, my name is John\") , {\"Hi\", \"my\", \"name\", \"is\", \"John\"}));\n    assert (issame(words_string(\"One, two, three, four, five, six\") , {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"}));\n    assert (issame(words_string(\"Hi, my name\") , {\"Hi\", \"my\", \"name\"}));\n    assert (issame(words_string(\"One,, two, three, four, five, six,\") , {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"}));\n    assert (issame(words_string(\"\") , {}));\n    assert (issame(words_string(\"ahmed     , gamal\") , {\"ahmed\", \"gamal\"}));\n}\n",
        "cpp_stress_test": "#include <string>\n#include <vector>\n#include <sstream>\nusing namespace std;\n\nint main() {\n    // Test 1: 'word0 word1 ... word9999'\n    string s1;\n    for (int i = 0; i < 10000; ++i) s1 += \"word\" + to_string(i) + \" \";\n    words_string(s1);\n\n    // Test 2: 'word1 word2, word3, ' * 3333 + 'word4'\n    string s2;\n    for (int i = 0; i < 3333; ++i) s2 += \"word1 word2, word3, \";\n    s2 += \"word4\";\n    words_string(s2);\n\n    // Test 3: 'word0, word1, ..., word4999, end'\n    string s3;\n    for (int i = 0; i < 5000; ++i) s3 += \"word\" + to_string(i) + \", \";\n    s3 += \"end\";\n    words_string(s3);\n\n    // Test 4: 'aaaa...aaaa, b, b, ..., c'\n    string s4(10000, 'a');\n    for (int i = 0; i < 9999; ++i) s4 += \", b\";\n    s4 += \", c\";\n    words_string(s4);\n\n    // Test 5: 'alpha, alpha, ..., omega'\n    string s5;\n    for (int i = 0; i < 4999; ++i) s5 += \"alpha, \";\n    s5 += \"omega\";\n    words_string(s5);\n}"
    },
    {
        "task_id": "102",
        "entry_point": "choose_num",
        "stress_test": "[{\"input\": \"[999, 1001]\", \"output\": null}, {\"input\": \"[2, 9999]\", \"output\": null}, {\"input\": \"[1, 9999]\", \"output\": null}, {\"input\": \"[11, 13]\", \"output\": null}, {\"input\": \"[100, 101]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint choose_num(int x,int y){\nif (y<x) return -1;\n    if (y==x and y%2==1) return -1;\n    if (y%2==1) return y-1;\n    return y;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (choose_num(12, 15) == 14);\n    assert (choose_num(13, 12) == -1);\n    assert (choose_num(33, 12354) == 12354);\n    assert (choose_num(5234, 5233) == -1);\n    assert (choose_num(6, 29) == 28);\n    assert (choose_num(27, 10) == -1);\n    assert (choose_num(7, 7) == -1);\n    assert (choose_num(546, 546) == 546);\n}\n",
        "cpp_stress_test": "#include<assert.h>\nint main(){choose_num(999, 1001); choose_num(2, 9999); choose_num(1, 9999); choose_num(11, 13); choose_num(100, 101);}"
    },
    {
        "task_id": "103",
        "entry_point": "rounded_avg",
        "stress_test": "[{\"input\": \"[100, 10100]\", \"output\": null}, {\"input\": \"[1, 10000]\", \"output\": null}, {\"input\": \"[1, 9999]\", \"output\": null}, {\"input\": \"[10, 10000]\", \"output\": null}, {\"input\": \"[500, 10000]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\nif (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (rounded_avg(1, 5) == \"11\");\n    assert (rounded_avg(7, 13) == \"1010\");\n    assert (rounded_avg(964,977) == \"1111001010\");\n    assert (rounded_avg(996,997) == \"1111100100\");\n    assert (rounded_avg(560,851) == \"1011000001\");  \n    assert (rounded_avg(185,546) == \"101101101\");\n    assert (rounded_avg(362,496) == \"110101101\");\n    assert (rounded_avg(350,902) == \"1001110010\");\n    assert (rounded_avg(197,233) == \"11010111\");\n    assert (rounded_avg(7, 5) == \"-1\");\n    assert (rounded_avg(5, 1) == \"-1\");\n    assert (rounded_avg(5, 5) == \"101\");\n}\n",
        "cpp_stress_test": "#include <cassert>\nint main() { rounded_avg(100, 10100); rounded_avg(1, 10000); rounded_avg(1, 9999); rounded_avg(10, 10000); rounded_avg(500, 10000); }"
    },
    {
        "task_id": "104",
        "entry_point": "unique_digits",
        "stress_test": "[{\"input\": \"[[x for x in range(1, 10001)]]\", \"output\": null}, {\"input\": \"[[i for i in range(1, 10001) if i % 2 == 1]]\", \"output\": null}, {\"input\": \"[[i * 1111 for i in range(1, 1001)]]\", \"output\": null}, {\"input\": \"[[1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120]]\", \"output\": null}, {\"input\": \"[[100001, 100003, 100007, 100009, 100011, 100013, 100015, 100017, 100019, 100021, 100023, 100025, 100027, 100029, 100031, 100033, 100035, 100037, 100039, 100041, 100043, 100045, 100047, 100049, 100051, 100053, 100055, 100057, 100059, 100061, 100063, 100065, 100067, 100069, 100071, 100073, 100075, 100077, 100079, 100081, 100083, 100085, 100087, 100089, 100091, 100093, 100095, 100097, 100099]]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> unique_digits(vector<int> x){\nvector<int> out={};\n    for (int i=0;i<x.size();i++)\n        {\n            int num=x[i];\n            bool u=true;\n            if (num==0) u=false;\n            while (num>0 and u)\n            {\n                if (num%2==0) u=false;\n                num=num/10;\n            }\n            if (u) out.push_back(x[i]);\n        }\n    sort(out.begin(),out.end());\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(unique_digits({15, 33, 1422, 1}) , {1, 15, 33}));\n    assert (issame(unique_digits({152, 323, 1422, 10}) , {}));\n    assert (issame(unique_digits({12345, 2033, 111, 151}) , {111, 151}));\n    assert (issame(unique_digits({135, 103, 31}) , {31, 135}));\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\n#include<vector>\nusing namespace std;\nint main() {\n    vector<int> test1; for (int x = 1; x <= 10000; ++x) test1.push_back(x);\n    vector<int> test2; for (int i = 1; i <= 10000; i += 2) test2.push_back(i);\n    vector<int> test3; for (int i = 1; i <= 1000; ++i) test3.push_back(i * 1111);\n    vector<int> test4 = {1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120}; \n    vector<int> test5 = {100001, 100003, 100007, 100009, 100011, 100013, 100015, 100017, 100019, 100021, 100023, 100025, 100027, 100029, 100031, 100033, 100035, 100037, 100039, 100041, 100043, 100045, 100047, 100049, 100051, 100053, 100055, 100057, 100059, 100061, 100063, 100065, 100067, 100069, 100071, 100073, 100075, 100077, 100079, 100081, 100083, 100085, 100087, 100089, 100091, 100093, 100095, 100097, 100099};\n}"
    },
    {
        "task_id": "105",
        "entry_point": "by_length",
        "stress_test": "[{\"input\": \"[list(range(-10000, 10001))]\", \"output\": null}, {\"input\": \"[[i if i % 2 == 0 else -i for i in range(1, 10**4 + 1)]]\", \"output\": null}, {\"input\": \"[[i for i in range(10**4, 0, -1)]]\", \"output\": null}, {\"input\": \"[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20] * 500]\", \"output\": null}, {\"input\": \"[[-9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9] * 500]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> by_length(vector<int> arr){\nmap<int,string> numto={{0,\"Zero\"},{1,\"One\"},{2,\"Two\"},{3,\"Three\"},{4,\"Four\"},{5,\"Five\"},{6,\"Six\"},{7,\"Seven\"},{8,\"Eight\"},{9,\"Nine\"}};\n    sort(arr.begin(),arr.end());\n    vector<string> out={};\n    for (int i=arr.size()-1;i>=0;i-=1)\n        if (arr[i]>=1 and arr[i]<=9)\n        out.push_back(numto[arr[i]]);\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(by_length({2, 1, 1, 4, 5, 8, 2, 3}) , {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"}));\n    assert (issame(by_length({}) , {}));\n    assert (issame(by_length({1, -1 , 55}) , {\"One\"}));\n    assert (issame(by_length({1, -1, 3, 2}) , {\"Three\", \"Two\", \"One\"}));\n    assert (issame(by_length({9, 4, 8}) , {\"Nine\", \"Eight\", \"Four\"}));\n}\n",
        "cpp_stress_test": "#include <vector>\nusing namespace std;\n\nint main() {\n    // list(range(-10000, 10001))  -10000 to 10000 inclusive\n    vector<int> v1;\n    for (int i = -10000; i <= 10000; ++i) v1.push_back(i);\n    by_length(v1);\n\n    // [i if i % 2 == 0 else -i for i in range(1, 10001)]\n    vector<int> v2;\n    for (int i = 1; i <= 10000; ++i) v2.push_back((i % 2 == 0) ? i : -i);\n    by_length(v2);\n\n    // list(range(10000, 0, -1))\n    vector<int> v3;\n    for (int i = 10000; i >= 1; --i) v3.push_back(i);\n    by_length(v3);\n\n    // [1..20] * 500\n    vector<int> v4;\n    for (int i = 0; i < 500; ++i)\n        for (int j = 1; j <= 20; ++j)\n            v4.push_back(j);\n    by_length(v4);\n\n    // [-9..9] * 500\n    vector<int> v5;\n    for (int i = 0; i < 500; ++i)\n        for (int j = -9; j <= 9; ++j)\n            v5.push_back(j);\n    by_length(v5);\n}"
    },
    {
        "task_id": "106",
        "entry_point": "f",
        "stress_test": "[{\"input\": \"[3333]\", \"output\": null}, {\"input\": \"[3000]\", \"output\": null}, {\"input\": \"[2500]\", \"output\": null}, {\"input\": \"[2468]\", \"output\": null}, {\"input\": \"[2345]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> f(int n){\nint sum=0,prod=1;\n    vector<int> out={};\n    for (int i=1;i<=n;i++)\n    {\n        sum+=i;\n        prod*=i;\n        if (i%2==0) out.push_back(prod);\n        else out.push_back(sum);\n    } \n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(f(5) , {1, 2, 6, 24, 15}));\n    assert (issame(f(7) , {1, 2, 6, 24, 15, 720, 28}));\n    assert (issame(f(1) , {1}));\n    assert (issame(f(3) , {1, 2, 6}));\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\n#include<vector>\nusing namespace std;\nbool issame(vector<int> a, vector<int> b) { \n    if (a.size() != b.size()) return false; \n    for (int i = 0; i < a.size(); i++) { \n        if (a[i] != b[i]) return false; \n    } \n    return true; \n}\nint main() { \n    f(3333);\n    f(3000);\n    f(2500);\n    f(2468);\n    f(2345);\n}"
    },
    {
        "task_id": "107",
        "entry_point": "even_odd_palindrome",
        "stress_test": "[{\"input\": \"[1000]\", \"output\": null}, {\"input\": \"[999]\", \"output\": null}, {\"input\": \"[987]\", \"output\": null}, {\"input\": \"[888]\", \"output\": null}, {\"input\": \"[876]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_palindrome(int n){\nint num1=0,num2=0;\n    for (int i=1;i<=n;i++)\n    {\n        string w=to_string(i);\n        string p(w.rbegin(),w.rend());\n        if (w==p and i%2==1) num1+=1;\n        if (w==p and i%2==0) num2+=1;\n            \n    }\n    return {num2,num1};\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(even_odd_palindrome(123) , {8, 13}));\n    assert (issame(even_odd_palindrome(12) , {4, 6}));\n    assert (issame(even_odd_palindrome(3) , {1, 2}));\n    assert (issame(even_odd_palindrome(63) , {6, 8}));\n    assert (issame(even_odd_palindrome(25) , {5, 6}));\n    assert (issame(even_odd_palindrome(19) , {4, 6}));\n    assert (issame(even_odd_palindrome(9) , {4, 5}));\n    assert (issame(even_odd_palindrome(1) , {0, 1}));\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include <assert.h>\n#include <vector>\nusing namespace std;\nbool issame(vector<int> a, vector<int> b) {\n    if (a.size() != b.size()) return false;\n    for (int i = 0; i < a.size(); i++) {\n        if (a[i] != b[i]) return false;\n    }\n    return true;\n}\nint main() {\n    even_odd_palindrome(1000);\n    even_odd_palindrome(999);\n    even_odd_palindrome(987);\n    even_odd_palindrome(888);\n    even_odd_palindrome(876);\n}"
    },
    {
        "task_id": "108",
        "entry_point": "count_nums",
        "stress_test": "[{\"input\": \"[[int(x) for x in range(-9999, 10000)]]\", \"output\": null}, {\"input\": \"[[(-1)**i * i for i in range(10000)]]\", \"output\": null}, {\"input\": \"[[x if x % 2 == 0 else -x for x in range(1, 10000)]]\", \"output\": null}, {\"input\": \"[[i for i in range(-5000, 5000)]]\", \"output\": null}, {\"input\": \"[[int(x) for x in range(-5000, 5000)]]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_nums(vector<int> n){\nint num=0;\n    for (int i=0;i<n.size();i++)\n        if (n[i]>0) num+=1;\n        else\n        {\n            int sum=0;\n            int w;\n            w=abs(n[i]);\n            while (w>=10)\n            {\n                sum+=w%10;\n                w=w/10;\n            }\n            sum-=w;\n            if (sum>0) num+=1;\n        }\n    return num;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (count_nums({}) == 0);\n    assert (count_nums({-1, -2, 0}) == 0);\n    assert (count_nums({1, 1, 2, -2, 3, 4, 5}) == 6);\n    assert (count_nums({1, 6, 9, -6, 0, 1, 5}) == 5);\n    assert (count_nums({1, 100, 98, -7, 1, -1}) == 4);\n    assert (count_nums({12, 23, 34, -45, -56, 0}) == 5);\n    assert (count_nums({-0, 1}) == 1);\n    assert (count_nums({1}) == 1);\n}\n",
        "cpp_stress_test": "#define NDEBUG\n#include<vector>\nint main(){\n    count_nums(std::vector<int>(20000)); \n    std::vector<int> vec1(10000); for (int i = 0; i < 10000; i++) vec1[i] = (i % 2 == 0) ? i : -i; count_nums(vec1);\n    std::vector<int> vec2(10000); for (int i = 1; i < 10000; i++) vec2[i - 1] = (i % 2 == 0) ? i : -i; count_nums(vec2);\n    std::vector<int> vec3(10000); for (int i = 0; i < 10000; i++) vec3[i] = i-5000; count_nums(vec3); \n    std::vector<int> vec4(10000); for (int i = 0; i < 10000; i++) vec4[i] = i-5000; count_nums(vec4);\n}"
    },
    {
        "task_id": "109",
        "entry_point": "move_one_ball",
        "stress_test": "[{\"input\": \"[list(range(2, 10001)) + [1]]\", \"output\": null}, {\"input\": \"[list(range(5000, 10000)) + list(range(5000))]\", \"output\": null}, {\"input\": \"[[10000] + list(range(1, 10000))]\", \"output\": null}, {\"input\": \"[list(range(1, 10001))]\", \"output\": null}, {\"input\": \"[[5000] + list(range(1, 5000)) + list(range(5001, 10001))]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool move_one_ball(vector<int> arr){\nint num=0;\n    if (arr.size()==0) return true;\n    for (int i=1;i<arr.size();i++)\n        if (arr[i]<arr[i-1]) num+=1;\n    if (arr[arr.size()-1]>arr[0]) num+=1;\n    if (num<2) return true;\n    return false;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (move_one_ball({3, 4, 5, 1, 2})==true);\n    assert (move_one_ball({3, 5, 10, 1, 2})==true);\n    assert (move_one_ball({4, 3, 1, 2})==false);\n    assert (move_one_ball({3, 5, 4, 1, 2})==false);\n    assert (move_one_ball({})==true);\n}\n",
        "cpp_stress_test": "#include <vector>\nusing namespace std;\n\nint main() {\n    // list(range(2, 10001)) + [1]\n    vector<int> v1;\n    for (int i = 2; i <= 10000; ++i) v1.push_back(i);\n    v1.push_back(1);\n    move_one_ball(v1);\n\n    // list(range(5000, 10000)) + list(range(0, 5000))\n    vector<int> v2;\n    for (int i = 5000; i < 10000; ++i) v2.push_back(i);\n    for (int i = 0; i < 5000; ++i) v2.push_back(i);\n    move_one_ball(v2);\n\n    // [10000] + list(range(1, 10000))\n    vector<int> v3;\n    v3.push_back(10000);\n    for (int i = 1; i < 10000; ++i) v3.push_back(i);\n    move_one_ball(v3);\n\n    // list(range(1, 10001))\n    vector<int> v4;\n    for (int i = 1; i <= 10000; ++i) v4.push_back(i);\n    move_one_ball(v4);\n\n    // [5000] + list(range(1, 5000)) + list(range(5001, 10001))\n    vector<int> v5;\n    v5.push_back(5000);\n    for (int i = 1; i < 5000; ++i) v5.push_back(i);\n    for (int i = 5001; i <= 10000; ++i) v5.push_back(i);\n    move_one_ball(v5);\n}"
    },
    {
        "task_id": "110",
        "entry_point": "exchange",
        "stress_test": "[{\"input\": \"[[i * 2 + 1 for i in range(5000)], [i * 2 for i in range(5000)]]\", \"output\": null}, {\"input\": \"[[1] * 5000, [i * 2 for i in range(1, 5001)]]\", \"output\": null}, {\"input\": \"[[1, 3, 5, 7, 9] * 1000, [2, 4, 6, 8, 10] * 1000]\", \"output\": null}, {\"input\": \"[[1] * 4999 + [2], [2] * 5000]\", \"output\": null}, {\"input\": \"[list(range(1, 5001)), list(range(5001, 10001))]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring exchange(vector<int> lst1,vector<int> lst2){\nint num=0;\n    for (int i=0;i<lst1.size();i++)\n    if (lst1[i]%2==0) num+=1;\n    for (int i=0;i<lst2.size();i++)\n    if (lst2[i]%2==0) num+=1;\n    if (num>=lst1.size()) return \"YES\";\n    return \"NO\";\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (exchange({1, 2, 3, 4}, {1, 2, 3, 4}) == \"YES\");\n    assert (exchange({1, 2, 3, 4}, {1, 5, 3, 4}) == \"NO\");\n    assert (exchange({1, 2, 3, 4}, {2, 1, 4, 3}) == \"YES\" );\n    assert (exchange({5, 7, 3}, {2, 6, 4}) == \"YES\");\n    assert (exchange({5, 7, 3}, {2, 6, 3}) == \"NO\" );\n    assert (exchange({3, 2, 6, 1, 8, 9}, {3, 5, 5, 1, 1, 1}) == \"NO\");\n    assert (exchange({100, 200}, {200, 200}) == \"YES\");\n}\n",
        "cpp_stress_test": "#include <vector>\nusing namespace std;\n\nint main() {\n    // [i * 2 + 1 for i in range(5000)], [i * 2 for i in range(5000)]\n    vector<int> v1a, v1b;\n    for (int i = 0; i < 5000; ++i) {\n        v1a.push_back(i * 2 + 1);\n        v1b.push_back(i * 2);\n    }\n    exchange(v1a, v1b);\n\n    // [1] * 5000, [i * 2 for i in range(1, 5001)]\n    vector<int> v2a(5000, 1), v2b;\n    for (int i = 1; i <= 5000; ++i) v2b.push_back(i * 2);\n    exchange(v2a, v2b);\n\n    // [1, 3, 5, 7, 9] * 1000, [2, 4, 6, 8, 10] * 1000\n    vector<int> v3a, v3b;\n    for (int i = 0; i < 1000; ++i) {\n        v3a.insert(v3a.end(), {1, 3, 5, 7, 9});\n        v3b.insert(v3b.end(), {2, 4, 6, 8, 10});\n    }\n    exchange(v3a, v3b);\n\n    // [1]*4999 + [2], [2]*5000\n    vector<int> v4a(4999, 1);\n    v4a.push_back(2);\n    vector<int> v4b(5000, 2);\n    exchange(v4a, v4b);\n\n    // list(range(1, 5001)), list(range(5001, 10001))\n    vector<int> v5a, v5b;\n    for (int i = 1; i <= 5000; ++i) v5a.push_back(i);\n    for (int i = 5001; i <= 10000; ++i) v5b.push_back(i);\n    exchange(v5a, v5b);\n}"
    },
    {
        "task_id": "111",
        "entry_point": "histogram",
        "stress_test": "[{\"input\": \"['a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z']\", \"output\": null}, {\"input\": \"['z y x w v u t s r q p o n m l k j i h g f e d c b a z y x w v u t s r q p o n m l k j i h g f e d c b a z y x w v u t s r q p o n m l k j i h g f e d c b a z y x w v u t s r q p o n m l k j i h g f e d c b a z y x w v u t s r q p o n m l k j i h g f e d c b a z y x w v u t s r q p o n m l k j i h g f e d c b a']\", \"output\": null}, {\"input\": \"['a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z']\", \"output\": null}, {\"input\": \"['a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z']\", \"output\": null}, {\"input\": \"['a a a a a a a a a a b b b b b b b b b b c c c c c c c c c c d d d d d d d d d d e e e e e e e e e e f f f f f f f f f f g g g g g g g g g g h h h h h h h h h h']\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nmap<char,int> histogram(string test){\nmap<char,int> count={},out={};\n    map <char,int>::iterator it;\n    int max=0;\n    for (int i=0;i<test.length();i++)\n        if (test[i]!=' ')\n        {\n            count[test[i]]+=1;\n            if (count[test[i]]>max) max=count[test[i]];\n        }\n    for (it=count.begin();it!=count.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (w2==max) out[w1]=w2;\n    }\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(map<char,int> a,map<char,int> b){\n    if (a.size()!=b.size()) return false;\n    map <char,int>::iterator it;\n    for (it=a.begin();it!=a.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (b.find(w1)==b.end()) return false;\n        if (b[w1]!=w2) return false;\n    }\n\n    return true;\n}\nint main(){\n    assert (issame(histogram(\"a b b a\") , {{'a',2},{'b', 2}}));\n    assert (issame(histogram(\"a b c a b\") , {{'a', 2},{'b', 2}}));\n    assert (issame(histogram(\"a b c d g\") , {{'a', 1}, {'b', 1}, {'c', 1}, {'d', 1}, {'g', 1}}));\n    assert (issame(histogram(\"r t g\") , {{'r', 1},{'t', 1},{'g', 1}}));\n    assert (issame(histogram(\"b b b b a\") , {{'b', 4}}));\n    assert (issame(histogram(\"r t g\") , {{'r', 1},{'t', 1},{'g', 1}}));\n    assert (issame(histogram(\"\") , {}));\n    assert (issame(histogram(\"a\") , {{'a', 1}}));\n}\n",
        "cpp_stress_test": "#include <string>\nusing namespace std;\n\nint main() {\n    string s1;\n    for (int i = 0; i < 10; ++i)\n        s1 += \"a b c d e f g h i j k l m n o p q r s t u v w x y z \";\n    histogram(s1);\n\n    string s2;\n    for (int i = 0; i < 6; ++i)\n        s2 += \"z y x w v u t s r q p o n m l k j i h g f e d c b a \";\n    histogram(s2);\n\n    string s3;\n    for (int i = 0; i < 5; ++i)\n        s3 += \"a b c d e f g h i j k l m n o p q r s t u v w x y z \";\n    histogram(s3);\n\n    string s4;\n    for (int i = 0; i < 3; ++i)\n        s4 += \"a b c d e f g h i j k l m n o p q r s t u v w x y z \";\n    histogram(s4);\n\n    string s5;\n    s5 += string(10, 'a') + ' ' + string(10, 'b') + ' ' + string(10, 'c') + ' ' + string(10, 'd') + ' ';\n    s5 += string(10, 'e') + ' ' + string(10, 'f') + ' ' + string(10, 'g') + ' ' + string(10, 'h');\n    histogram(s5);\n}"
    },
    {
        "task_id": "112",
        "entry_point": "reverse_delete",
        "stress_test": "[{\"input\": \"['palindrome'*4000 + 'emordnilap'*4000, 'o']\", \"output\": null}, {\"input\": \"['level'*2500 + 'reviver'*2500 + 'deified'*2500, 'e']\", \"output\": null}, {\"input\": \"['noon'*2500 + 'civic'*2500 + 'radar'*2500, 'n']\", \"output\": null}, {\"input\": \"['level'*2000 + 'reviver'*2000, 'l']\", \"output\": null}, {\"input\": \"['palindrome'*1000 + 'emordnilap'*1000, 'p']\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> reverse_delete(string s,string c){\nstring n=\"\";\n    for (int i=0;i<s.length();i++)\n    if (find(c.begin(),c.end(),s[i])==c.end())\n        n=n+s[i]; \n    if (n.length()==0) return {n,\"True\"};\n    string w(n.rbegin(),n.rend());\n    if (w==n) return {n,\"True\"};\n    return {n,\"False\"};\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(reverse_delete(\"abcde\",\"ae\") , {\"bcd\",\"False\"}));\n    assert (issame(reverse_delete(\"abcdef\", \"b\") , {\"acdef\",\"False\"}));\n    assert (issame(reverse_delete(\"abcdedcba\",\"ab\") , {\"cdedc\",\"True\"}));\n    assert (issame(reverse_delete(\"dwik\",\"w\") , {\"dik\",\"False\"}));\n    assert (issame(reverse_delete(\"a\",\"a\") , {\"\",\"True\"}));\n    assert (issame(reverse_delete(\"abcdedcba\",\"\") , {\"abcdedcba\",\"True\"}));\n    assert (issame(reverse_delete(\"abcdedcba\",\"v\") , {\"abcdedcba\",\"True\"}));\n    assert (issame(reverse_delete(\"vabba\",\"v\") , {\"abba\",\"True\"}));\n    assert (issame(reverse_delete(\"mamma\", \"mia\") , {\"\", \"True\"}));\n}\n",
        "cpp_stress_test": "#include <string>\nusing namespace std;\n\nint main() {\n    string s1;\n    for (int i = 0; i < 4000; ++i) s1 += \"palindrome\";\n    for (int i = 0; i < 4000; ++i) s1 += \"emordnilap\";\n    reverse_delete(s1, \"o\");\n\n    string s2;\n    for (int i = 0; i < 2500; ++i) s2 += \"level\";\n    for (int i = 0; i < 2500; ++i) s2 += \"reviver\";\n    for (int i = 0; i < 2500; ++i) s2 += \"deified\";\n    reverse_delete(s2, \"e\");\n\n    string s3;\n    for (int i = 0; i < 2500; ++i) s3 += \"noon\";\n    for (int i = 0; i < 2500; ++i) s3 += \"civic\";\n    for (int i = 0; i < 2500; ++i) s3 += \"radar\";\n    reverse_delete(s3, \"n\");\n\n    string s4;\n    for (int i = 0; i < 2000; ++i) s4 += \"level\";\n    for (int i = 0; i < 2000; ++i) s4 += \"reviver\";\n    reverse_delete(s4, \"l\");\n\n    string s5;\n    for (int i = 0; i < 1000; ++i) s5 += \"palindrome\";\n    for (int i = 0; i < 1000; ++i) s5 += \"emordnilap\";\n    reverse_delete(s5, \"p\");\n}"
    },
    {
        "task_id": "113",
        "entry_point": "odd_count",
        "stress_test": "[{\"input\": \"[['1', '2', '3', '4', '5', '6', '7', '8', '9', '0'] * 1000]\", \"output\": null}, {\"input\": \"[['13579' * 1000 + '02468' * 1000, '97531' * 1000 + '86420' * 1000]]\", \"output\": null}, {\"input\": \"[['1234567890' * 1000, '9876543210' * 1000]]\", \"output\": null}, {\"input\": \"[['13579' * 2000, '24680' * 2000]]\", \"output\": null}, {\"input\": \"[['1234567890' * 500, '0987654321' * 500, '1111111111' * 1000]]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> odd_count(vector<string> lst){\nvector<string> out={};\n    for (int i=0;i<lst.size();i++)\n        {\n            int sum=0;\n            for (int j=0;j<lst[i].length();j++)\n                if (lst[i][j]>=48 and lst[i][j]<=57 and lst[i][j]%2==1)\n                sum+=1;\n            string s=\"the number of odd elements in the string i of the input.\";\n            string s2=\"\";\n            for (int j=0;j<s.length();j++)\n                if (s[j]=='i') s2=s2+to_string(sum);\n                else s2=s2+s[j];\n            out.push_back(s2);\n        }\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(odd_count({\"1234567\"}) , {\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}));\n    assert (issame(odd_count({\"3\",\"11111111\"}) , {\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"}));\n    assert (issame(odd_count({\"271\", \"137\", \"314\"}) , {\n        \"the number of odd elements 2n the str2ng 2 of the 2nput.\",\n        \"the number of odd elements 3n the str3ng 3 of the 3nput.\",\n        \"the number of odd elements 2n the str2ng 2 of the 2nput.\"\n    }));\n}\n",
        "cpp_stress_test": "#include<vector>\n#include<string>\n#include<iostream>\nusing namespace std;\nint main() {\n    vector<string> lst1(10000);\n    for (int i = 0; i < 10000; ++i) lst1[i] = to_string((i % 10));\n    odd_count(lst1);\n\n    string s1(5000, '1'); s1 += string(5000, '0');\n    string s2(5000, '9'); s2 += string(5000, '0');\n    odd_count({s1, s2});\n\n    string s3;\n    for (int i = 0; i < 1000; ++i) s3 += \"1234567890\";\n    string s4;\n    for (int i = 0; i < 1000; ++i) s4 += \"9876543210\";\n    odd_count({s3, s4});\n\n    string s5;\n    for (int i = 0; i < 2000; ++i) s5 += \"13579\";\n    string s6;\n    for (int i = 0; i < 2000; ++i) s6 += \"24680\";\n    odd_count({s5, s6});\n\n    string s7, s8, s9;\n    for (int i = 0; i < 500; ++i) s7 += \"1234567890\";\n    for (int i = 0; i < 500; ++i) s8 += \"0987654321\";\n    for (int i = 0; i < 1000; ++i) s9 += \"1111111111\";\n    odd_count({s7, s8, s9});\n    return 0;\n}"
    },
    {
        "task_id": "114",
        "entry_point": "minSubArraySum",
        "stress_test": "[{\"input\": \"[[10**5] * 5000 + [-10**5] * 5000]\", \"output\": null}, {\"input\": \"[list(range(1, 5001)) + list(range(-5000, 0))]\", \"output\": null}, {\"input\": \"[[i - 5000 for i in range(10000)]]\", \"output\": null}, {\"input\": \"[[i for i in range(-5000, 5001)]]\", \"output\": null}, {\"input\": \"[list(range(-5000, 5000))]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\nlong long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (minSubArraySum({2, 3, 4, 1, 2, 4}) == 1);\n    assert (minSubArraySum({-1, -2, -3}) == -6);\n    assert (minSubArraySum({-1, -2, -3, 2, -10}) == -14);\n    assert (minSubArraySum({-9999999999999999}) == -9999999999999999);\n    assert (minSubArraySum({0, 10, 20, 1000000}) == 0);\n    assert (minSubArraySum({-1, -2, -3, 10, -5}) == -6);\n    assert (minSubArraySum({100, -1, -2, -3, 10, -5}) == -6);\n    assert (minSubArraySum({10, 11, 13, 8, 3, 4}) == 3);\n    assert (minSubArraySum({100, -33, 32, -1, 0, -2}) == -33);\n    assert (minSubArraySum({-10}) == -10);\n    assert (minSubArraySum({7}) == 7);\n    assert (minSubArraySum({1, -1}) == -1);\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint main() {\n    vector<long long> v1(5000, 100000); v1.insert(v1.end(), 5000, -100000); minSubArraySum(v1);\n\n    vector<long long> v2; for (int i = 1; i <= 5000; ++i) v2.push_back(i); for (int i = -5000; i < 0; ++i) v2.push_back(i); minSubArraySum(v2);\n\n    vector<long long> v3; for (int i = 0; i < 10000; ++i) v3.push_back(i - 5000); minSubArraySum(v3);\n\n    vector<long long> v4; for (int i = -5000; i <= 5000; ++i) v4.push_back(i); minSubArraySum(v4);\n\n    vector<long long> v5; for (int i = -5000; i < 5000; ++i) v5.push_back(i); minSubArraySum(v5);\n\n    return 0;\n}"
    },
    {
        "task_id": "115",
        "entry_point": "max_fill",
        "stress_test": "[{\"input\": \"[[[1 if j == 99 else 0 for j in range(100)] for i in range(100)], 1]\", \"output\": null}, {\"input\": \"[[[0]*100 for _ in range(100)], 1]\", \"output\": null}, {\"input\": \"[[[0]*100 for _ in range(99)] + [[1]*100], 1]\", \"output\": null}, {\"input\": \"[[[1]*10 + [0]*90 for _ in range(100)], 1]\", \"output\": null}, {\"input\": \"[[[1 if i % 3 == 0 else 0 for i in range(100)] for _ in range(100)], 3]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint max_fill(vector<vector<int>> grid,int capacity){\nint out=0;\n    for (int i=0;i<grid.size();i++)\n    {\n        int sum=0;\n        for (int j=0;j<grid[i].size();j++)\n            sum+=grid[i][j];\n        if (sum>0)  out+=(sum-1)/capacity+1;\n    }\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (max_fill({{0,0,1,0}, {0,1,0,0}, {1,1,1,1}}, 1) == 6);\n    assert (max_fill({{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}}, 2) == 5);\n    assert (max_fill({{0,0,0}, {0,0,0}}, 5) == 0);\n    assert (max_fill({{1,1,1,1}, {1,1,1,1}}, 2) == 4);\n    assert (max_fill({{1,1,1,1}, {1,1,1,1}}, 9) == 2);\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include <vector>\nusing namespace std;\nint main() {\n    vector<vector<int>> g1(100, vector<int>(100, 0)); for (int i = 0; i < 100; ++i) g1[i][99] = 1; max_fill(g1, 1);\n    vector<vector<int>> g2(100, vector<int>(100, 0)); max_fill(g2, 1);\n    vector<vector<int>> g3(99, vector<int>(100, 0)); g3.push_back(vector<int>(100, 1)); max_fill(g3, 1);\n    vector<vector<int>> g4(100, vector<int>(100, 0)); for (int i = 0; i < 100; ++i) for (int j = 0; j < 10; ++j) g4[i][j] = 1; max_fill(g4, 1);\n    vector<vector<int>> g5(100, vector<int>(100, 0)); for (int i = 0; i < 100; ++i) for (int j = 0; j < 100; ++j) if (j % 3 == 0) g5[i][j] = 1; max_fill(g5, 3);\n    return 0;\n}"
    },
    {
        "task_id": "116",
        "entry_point": "sort_array",
        "stress_test": "[{\"input\": \"[[i*i % 1000 for i in range(10000)]]\", \"output\": null}, {\"input\": \"[[int(x) for x in '1234567890'*1000]]\", \"output\": null}, {\"input\": \"[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]*1000]\", \"output\": null}, {\"input\": \"[[i % 100 for i in range(10000)]]\", \"output\": null}, {\"input\": \"[[0, 1] * 5000]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\nvector<int> bin={};\n    int m;\n\n    for (int i=0;i<arr.size();i++)\n    {\n        int b=0,n=abs(arr[i]);\n        while (n>0)\n        {\n            b+=n%2;n=n/2;\n        }\n        bin.push_back(b);\n    }\n    for (int i=0;i<arr.size();i++)\n    for (int j=1;j<arr.size();j++)\n    if (bin[j]<bin[j-1] or (bin[j]==bin[j-1] and arr[j]<arr[j-1]))\n    {\n        m=arr[j];arr[j]=arr[j-1];arr[j-1]=m;\n        m=bin[j];bin[j]=bin[j-1];bin[j-1]=m;\n    }\n    return arr;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sort_array({1,5,2,3,4}) , {1, 2, 4, 3, 5}));\n    assert (issame(sort_array({-2,-3,-4,-5,-6}) , {-4, -2, -6, -5, -3}));\n    assert (issame(sort_array({1,0,2,3,4}) , {0, 1, 2, 4, 3}));\n    assert (issame(sort_array({}) , {}));\n    assert (issame(sort_array({2,5,77,4,5,3,5,7,2,3,4}) , {2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77}));\n    assert (issame(sort_array({3,6,44,12,32,5}) , {32, 3, 5, 6, 12, 44}));\n    assert (issame(sort_array({2,4,8,16,32}) , {2, 4, 8, 16, 32}));\n    assert (issame(sort_array({2,4,8,16,32}) , {2, 4, 8, 16, 32}));\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include <vector>\nusing namespace std;\nint main() {\n    vector<int> v1; for (int i = 0; i < 10000; ++i) v1.push_back((i * i) % 1000); sort_array(v1);\n    vector<int> v2; for (int i = 0; i < 10000; ++i) v2.push_back(\"1234567890\"[i % 10] - '0'); sort_array(v2);\n    vector<int> v3; for (int i = 0; i < 10000; ++i) v3.push_back(i % 10 + 1); sort_array(v3);\n    vector<int> v4; for (int i = 0; i < 10000; ++i) v4.push_back(i % 100); sort_array(v4);\n    vector<int> v5; for (int i = 0; i < 5000; ++i) { v5.push_back(0); v5.push_back(1); } sort_array(v5);\n    return 0;\n}"
    },
    {
        "task_id": "117",
        "entry_point": "select_words",
        "stress_test": "[{\"input\": \"['a'.join(['b' for _ in range(10000)]), 10000]\", \"output\": null}, {\"input\": \"['xyz' * 3333, 9999]\", \"output\": null}, {\"input\": \"[''.join(['consonants' for _ in range(1000)]), 9000]\", \"output\": null}, {\"input\": \"['b' * 5000 + 'a' * 5000, 5000]\", \"output\": null}, {\"input\": \"['a' * 1000 + 'b' * 1000, 1000]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> select_words(string s,int n){\nstring vowels=\"aeiouAEIOU\";\n    string current=\"\";\n    vector<string> out={};\n    int numc=0;\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n        if (s[i]==' ')\n        {\n            if (numc==n) out.push_back(current);\n            current=\"\";\n            numc=0;\n        }\n        else\n        {\n            current=current+s[i];\n            if ((s[i]>=65 and s[i]<=90) or (s[i]>=97 and s[i]<=122))\n            if (find(vowels.begin(),vowels.end(),s[i])==vowels.end())\n                numc+=1;\n        }\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(select_words(\"Mary had a little lamb\", 4) , {\"little\"}   ));\n    assert (issame(select_words(\"Mary had a little lamb\", 3) , {\"Mary\", \"lamb\"} ));\n    assert (issame(select_words(\"simple white space\", 2) , {}     ));\n    assert (issame(select_words(\"Hello world\", 4) , {\"world\"}  ));\n    assert (issame(select_words(\"Uncle sam\", 3) , {\"Uncle\"}));\n    assert (issame(select_words(\"\", 4) , {}));\n    assert (issame(select_words(\"a b c d e f\", 1) , {\"b\", \"c\", \"d\", \"f\"}));\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\n#include<string>\n#include<vector>\nusing namespace std;\nint main(){\n    select_words(string(9999, 'b') + 'a' + string(9999, 'b'), 10000); \n    select_words(string(3333, 'x') + string(3333, 'y') + string(3333, 'z'), 9999);\n    select_words(string(1000, 'c') + string(1000, 'o') + string(1000, 'n') + string(1000, 's') + string(1000, 'o') + string(1000, 'n') + string(1000, 'a') + string(1000, 'n') + string(1000, 't') + string(1000, 's'), 9000);\n    select_words(string(5000, 'b') + string(5000, 'a'), 5000);\n    select_words(string(1000, 'a') + string(1000, 'b'), 1000);\n}"
    },
    {
        "task_id": "118",
        "entry_point": "get_closest_vowel",
        "stress_test": "[{\"input\": \"['xxxyyyzzz' * 1111 + 'O' + 'aaabbbccc' * 1111]\", \"output\": null}, {\"input\": \"['a' * 10000 + 'b']\", \"output\": null}, {\"input\": \"['start' + 'a'*9994 + 'end']\", \"output\": null}, {\"input\": \"['b' * 3333 + 'a' * 3333 + 'c' * 3334]\", \"output\": null}, {\"input\": \"['xYz' * 3333 + 'O']\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring get_closest_vowel(string word){\nstring out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=word.length()-2;i>=1;i-=1)\n        if (find(vowels.begin(),vowels.end(),word[i])!=vowels.end())\n            if (find(vowels.begin(),vowels.end(),word[i+1])==vowels.end())\n                if (find(vowels.begin(),vowels.end(),word[i-1])==vowels.end())\n                    return out+word[i];\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (get_closest_vowel(\"yogurt\") == \"u\");\n    assert (get_closest_vowel(\"full\") == \"u\");\n    assert (get_closest_vowel(\"easy\") == \"\");\n    assert (get_closest_vowel(\"eAsy\") == \"\");\n    assert (get_closest_vowel(\"ali\") == \"\");\n    assert (get_closest_vowel(\"bad\") == \"a\");\n    assert (get_closest_vowel(\"most\") ==\"o\");\n    assert (get_closest_vowel(\"ab\") == \"\");\n    assert (get_closest_vowel(\"ba\") == \"\");\n    assert (get_closest_vowel(\"quick\") == \"\");\n    assert (get_closest_vowel(\"anime\") == \"i\");\n    assert (get_closest_vowel(\"Asia\") == \"\");\n    assert (get_closest_vowel(\"Above\") == \"o\");\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    get_closest_vowel(std::string(1111, 'x') + std::string(1111, 'y') + std::string(1111, 'z') + \"O\" + std::string(1111, 'a') + std::string(1111, 'b') + std::string(1111, 'c'));\n    get_closest_vowel(std::string(10000, 'a') + \"b\");\n    get_closest_vowel(\"start\" + std::string(9994, 'a') + \"end\");\n    get_closest_vowel(std::string(3333, 'b') + std::string(3333, 'a') + std::string(3334, 'c'));\n    get_closest_vowel(std::string(3333, 'x') + std::string(3333, 'Y') + std::string(3333, 'z') + \"O\");\n}"
    },
    {
        "task_id": "119",
        "entry_point": "match_parens",
        "stress_test": "[{\"input\": \"[['(' * 2500 + '()' * 2500 + ')', '()' * 5000]]\", \"output\": null}, {\"input\": \"[['(' * 4999 + ')', '(' * 5000 + ')' * 5001]]\", \"output\": null}, {\"input\": \"[['((' * 5000, '))' * 5000]]\", \"output\": null}, {\"input\": \"[['(' * 2500 + ')()' * 2500, '()' * 5000]]\", \"output\": null}, {\"input\": \"[['(' * 3456 + ')' * 3456 + '(' * 1544, ')' * 1544 + '(' * 3456 + ')' * 3456]]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring match_parens(vector<string> lst){\nstring l1=lst[0]+lst[1];\n    int i,count=0;\n    bool can=true;\n    for (i=0;i<l1.length();i++)\n        {\n            if (l1[i]=='(') count+=1;\n            if (l1[i]==')') count-=1;\n            if (count<0) can=false;\n        }\n    if (count!=0) return \"No\";\n    if (can==true) return \"Yes\";\n    l1=lst[1]+lst[0];\n    can=true;\n    for (i=0;i<l1.length();i++)\n        {\n            if (l1[i]=='(') count+=1;\n            if (l1[i]==')') count-=1;\n            if (count<0) can=false;\n        }\n    if (can==true) return \"Yes\";\n    return \"No\";\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (match_parens({\"()(\", \")\"}) == \"Yes\");\n    assert (match_parens({\")\", \")\"}) == \"No\");\n    assert (match_parens({\"(()(())\", \"())())\"}) == \"No\");\n    assert (match_parens({\")())\", \"(()()(\"}) == \"Yes\");\n    assert (match_parens({\"(())))\", \"(()())((\"}) == \"Yes\");\n    assert (match_parens({\"()\", \"())\"}) == \"No\");\n    assert (match_parens({\"(()(\", \"()))()\"}) == \"Yes\");\n    assert (match_parens({\"((((\", \"((())\"}) == \"No\");\n    assert (match_parens({\")(()\", \"(()(\"}) == \"No\");\n    assert (match_parens({\")(\", \")(\"}) == \"No\");\n    assert (match_parens({\"(\", \")\"}) == \"Yes\");\n    assert (match_parens({\")\", \"(\"}) == \"Yes\" );\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include <string>\n#include <vector>\nusing namespace std;\nint main() {\n    match_parens({string(2500, '(') + string(2500, ')') + string(2500, '('), string(5000, ')')});\n    match_parens({string(4999, '(') + \")\", string(5000, '(') + string(5001, ')')});\n    match_parens({string(5000, '(') + string(5000, '('), string(5000, ')') + string(5000, ')')});\n    match_parens({string(2500, '(') + string(2500, ')') + string(2500, '(') + string(2500, ')'), string(5000, '(') + string(5000, ')')});\n    match_parens({string(3456, '(') + string(3456, ')') + string(1544, '('), string(1544, ')') + string(3456, '(') + string(3456, ')')});\n    return 0;\n}"
    },
    {
        "task_id": "120",
        "entry_point": "maximum",
        "stress_test": "[{\"input\": \"[[i % 5 - 2 for i in range(1000)], 500]\", \"output\": null}, {\"input\": \"[[999, 1000, -1000, -999] * 250, 1000]\", \"output\": null}, {\"input\": \"[[(-1)**i * i for i in range(1000)], 999]\", \"output\": null}, {\"input\": \"[[i if i % 2 == 0 else -i for i in range(1000)], 300]\", \"output\": null}, {\"input\": \"[[(-1)**i * (i % 1000) for i in range(1000)], 100]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\nsort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(maximum({-3, -4, 5}, 3) , {-4, -3, 5}));\n    assert (issame(maximum({4, -4, 4}, 2) , {4, 4}));\n    assert (issame(maximum({-3, 2, 1, 2, -1, -2, 1}, 1) , {2}));\n    assert (issame(maximum({123, -123, 20, 0 , 1, 2, -3}, 3) , {2, 20, 123}));\n    assert (issame(maximum({-123, 20, 0 , 1, 2, -3}, 4) , {0, 1, 2, 20}));\n    assert (issame(maximum({5, 15, 0, 3, -13, -8, 0}, 7) , {-13, -8, 0, 0, 3, 5, 15}));\n    assert (issame(maximum({-1, 0, 2, 5, 3, -10}, 2) , {3, 5}));\n    assert (issame(maximum({1, 0, 5, -7}, 1) , {5}));\n    assert (issame(maximum({4, -4}, 2) , {-4, 4}));\n    assert (issame(maximum({-10, 10}, 2) , {-10, 10}));\n    assert (issame(maximum({1, 2, 3, -23, 243, -400, 0}, 0) , {}));\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include <vector>\nusing namespace std;\nint main() {\n    vector<int> v1; for (int i = 0; i < 1000; ++i) v1.push_back(i % 5 - 2); maximum(v1, 500);\n    vector<int> v2; for (int i = 0; i < 250; ++i) { v2.push_back(999); v2.push_back(1000); v2.push_back(-1000); v2.push_back(-999); } maximum(v2, 1000);\n    vector<int> v3; for (int i = 0; i < 1000; ++i) v3.push_back((i % 2 == 0) ? i : -i); maximum(v3, 999);\n    vector<int> v4; for (int i = 0; i < 1000; ++i) v4.push_back((i % 2 == 0) ? i : -i); maximum(v4, 300);\n    vector<int> v5; for (int i = 0; i < 1000; ++i) v5.push_back((i % 2 == 0 ? 1 : -1) * (i % 1000)); maximum(v5, 100);\n    return 0;\n}"
    },
    {
        "task_id": "121",
        "entry_point": "solution",
        "stress_test": "[{\"input\": \"[[i for i in range(10001, 20001)]]\", \"output\": null}, {\"input\": \"[list(range(1, 10001))]\", \"output\": null}, {\"input\": \"[[9999] * 9999 + [1]]\", \"output\": null}, {\"input\": \"[[1] * 10000]\", \"output\": null}, {\"input\": \"[[7] * 2000 + [14] * 3000 + [21] * 5000]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\nint sum=0;\n    for (int i=0;i*2<lst.size();i++)\n        if (lst[i*2]%2==1) sum+=lst[i*2];\n    return sum;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (solutions({5, 8, 7, 1})    == 12);\n    assert (solutions({3, 3, 3, 3, 3}) == 9);\n    assert (solutions({30, 13, 24, 321}) == 0);\n    assert (solutions({5, 9}) == 5);\n    assert (solutions({2, 4, 8}) == 0);\n    assert (solutions({30, 13, 23, 32}) == 23);\n    assert (solutions({3, 13, 2, 9}) == 3);\n}\n",
        "cpp_stress_test":"#undef NDEBUG\n#include<assert.h>\n#include<vector>\n#include<numeric>\nusing namespace std;\nint main(){\n    vector<int> v1; for (int i = 10001; i <= 4000000; ++i) v1.push_back(i); solutions(v1);\n    vector<int> v2(10000); iota(v2.begin(), v2.end(), 1); solutions(v2);\n    vector<int> vec1(9999, 9999); vec1.push_back(1); solutions(vec1);\n    solutions(vector<int>(10000, 1));\n    vector<int> vec2(2000, 7); vec2.insert(vec2.end(), 3000, 14); vec2.insert(vec2.end(), 5000, 21); solutions(vec2);\n}"
    },
    {
        "task_id": "122",
        "entry_point": "add_elements",
        "stress_test": "[{\"input\": \"[[10**i for i in range(1, 101)], 100]\", \"output\": null}, {\"input\": \"[[int('9' * i) for i in range(1, 101)], 100]\", \"output\": null}, {\"input\": \"[[i % 150 for i in range(100)], 100]\", \"output\": null}, {\"input\": \"[[i ** 2 % 123 for i in range(1, 101)], 100]\", \"output\": null}, {\"input\": \"[[int('9' * (i % 3 + 1)) for i in range(1, 101)], 100]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add_elements(vector<int> arr,int k){\nint sum=0;\n    for (int i=0;i<k;i++)\n        if( arr[i]>=-99 and arr[i]<=99)\n            sum+=arr[i];\n    return sum;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (add_elements({1,-2,-3,41,57,76,87,88,99}, 3) == -4);\n    assert (add_elements({111,121,3,4000,5,6}, 2) == 0);\n    assert (add_elements({11,21,3,90,5,6,7,8,9}, 4) == 125);\n    assert (add_elements({111,21,3,4000,5,6,7,8,9}, 4) == 24);\n    assert (add_elements({1}, 1) == 1);\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include <vector>\n#include <cmath>\n#include <string>\nusing namespace std;\nint main() {\n    vector<int> v1; for(int i = 1; i <= 100; ++i) v1.push_back(i < 10 ? (int)pow(10, i) : 0); add_elements(v1, 100);\n    vector<int> v2; for(int i = 1; i <= 100; ++i) v2.push_back(i <= 9 ? stoi(string(i, '9')) : 0); add_elements(v2, 100);\n    vector<int> v3; for(int i = 0; i < 900000; ++i) v3.push_back(i % 150); add_elements(v3, 100);\n    vector<int> v4; for(int i = 1; i <= 900000; ++i) v4.push_back((i * i) % 123); add_elements(v4, 100);\n    vector<int> v5; for(int i = 1; i <= 800000; ++i) v5.push_back(stoi(string(i % 3 + 1, '9'))); add_elements(v5, 100);\n    return 0;\n}"
    },
    {
        "task_id": "123",
        "entry_point": "get_odd_collatz",
        "stress_test": "[{\"input\": \"[271828182]\", \"output\": null}, {\"input\": \"[314159265]\", \"output\": null}, {\"input\": \"[999999]\", \"output\": null}, {\"input\": \"[678901]\", \"output\": null}, {\"input\": \"[9999999]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> get_odd_collatz(int n){\nvector<int> out={1};\n    while (n!=1)\n    {\n        if (n%2==1) {out.push_back(n); n=n*3+1;}\n        else n=n/2;\n    }\n    sort(out.begin(),out.end());\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(get_odd_collatz(14) , {1, 5, 7, 11, 13, 17}));\n    assert (issame(get_odd_collatz(5) , {1, 5}));\n    assert (issame(get_odd_collatz(12) , {1, 3, 5}));\n    assert (issame(get_odd_collatz(1) , {1}));\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include <vector>\nusing namespace std;\nint main() {\n    get_odd_collatz(271828182);\n    get_odd_collatz(314159264);\n    get_odd_collatz(9999999);\n    get_odd_collatz(678901);\n    get_odd_collatz(9999999);\n    return 0;\n}"
    },
    {
        "task_id": "124",
        "entry_point": "valid_date",
        "stress_test": "[{\"input\": \"['02-29-2000']\", \"output\": null}, {\"input\": \"['02-29-1900']\", \"output\": null}, {\"input\": \"['02-29-2020']\", \"output\": null}, {\"input\": \"['02-29-2004']\", \"output\": null}, {\"input\": \"['02-30-2000']\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool valid_date(string date){\nint mm,dd,yy,i;\n    if (date.length()!=10) return false;\n    for (int i=0;i<10;i++)\n        if (i==2 or i==5)\n        {\n            if (date[i]!='-') return false;\n        }\n        else\n            if (date[i]<48 or date[i]>57) return false;\n\n    mm=atoi(date.substr(0,2).c_str());\n    dd=atoi(date.substr(3,2).c_str());\n    yy=atoi(date.substr(6,4).c_str());\n    if (mm<1 or mm>12) return false;\n    if (dd<1 or dd>31) return false;\n    if (dd==31 and (mm==4 or mm==6 or mm==9 or mm==11 or mm==2)) return false;\n    if (dd==30 and mm==2) return false;\n    return true;\n\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (valid_date(\"03-11-2000\") == true);\n    assert (valid_date(\"15-01-2012\") == false);\n    assert (valid_date(\"04-0-2040\") == false);\n    assert (valid_date(\"06-04-2020\") == true);\n    assert (valid_date(\"01-01-2007\") == true);\n    assert (valid_date(\"03-32-2011\") == false);\n    assert (valid_date(\"\") == false);\n    assert (valid_date(\"04-31-3000\") == false);\n    assert (valid_date(\"06-06-2005\") == true);\n    assert (valid_date(\"21-31-2000\") == false);\n    assert (valid_date(\"04-12-2003\") == true);\n    assert (valid_date(\"04122003\") == false);\n    assert (valid_date(\"20030412\") == false);\n    assert (valid_date(\"2003-04\") == false);\n    assert (valid_date(\"2003-04-12\") == false);\n    assert (valid_date(\"04-2003\") == false);\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\nint main(){ valid_date(\"02-29-2000\"); valid_date(\"02-29-1900\"); valid_date(\"02-29-2020\"); valid_date(\"02-29-2004\"); valid_date(\"02-30-2000\"); }"
    },
    {
        "task_id": "125",
        "entry_point": "split_words",
        "stress_test": "[{\"input\": \"['abacabadabacaba'*714 + 'abacabad']\", \"output\": null}, {\"input\": \"[''.join(['a' if i % 2 == 0 else 'b' for i in range(10000)])]\", \"output\": null}, {\"input\": \"['a'*5000 + 'b'*5000]\", \"output\": null}, {\"input\": \"[''.join(['a'] * 10000)]\", \"output\": null}, {\"input\": \"['A'*5000 + 'b'*5000 + 'C'*5000]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split_words(string txt){\nint i;\n    string current=\"\";\n    vector<string> out={};\n    if (find(txt.begin(),txt.end(),' ')!=txt.end())\n    {\n        txt=txt+' ';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==' ') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    if (find(txt.begin(),txt.end(),',')!=txt.end())\n    {\n        txt=txt+',';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==',') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    int num=0;\n    for (i=0;i<txt.length();i++)\n        if (txt[i]>=97 and txt[i]<=122 and txt[i]%2==0)\n            num+=1;\n    return {to_string(num)};\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(split_words(\"Hello world!\") , {\"Hello\",\"world!\"}));\n    assert (issame(split_words(\"Hello,world!\") , {\"Hello\",\"world!\"}));\n    assert (issame(split_words(\"Hello world,!\") , {\"Hello\",\"world,!\"}));\n    assert (issame(split_words(\"Hello,Hello,world !\") , {\"Hello,Hello,world\",\"!\"}));\n    assert (issame(split_words(\"abcdef\") , {\"3\"}));\n    assert (issame(split_words(\"aaabb\") , {\"2\"}));\n    assert (issame(split_words(\"aaaBb\") , {\"1\"}));\n    assert (issame(split_words(\"\") ,{\"0\"}));\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include <string>\nusing namespace std;\nint main() {\n    split_words(string(714, 'a') + \"bacabadabacaba\" + string(714, 'a') + \"bacabad\");\n    string alt = \"\"; for(int i = 0; i < 9900000; ++i) alt += (i % 2 == 0 ? 'a' : 'b'); split_words(alt);\n    split_words(string(5000, 'a') + string(5000, 'b'));\n    split_words(string(10000, 'a'));\n    split_words(string(5000, 'A') + string(5000, 'b') + string(5000, 'C'));\n    return 0;}"
    },
    {
        "task_id": "126",
        "entry_point": "is_sorted",
        "stress_test": "[{\"input\": \"[[i for i in range(10000)] + [9999]]\", \"output\": null}, {\"input\": \"[[i for i in range(9999)] + [5000]]\", \"output\": null}, {\"input\": \"[[i for i in range(10000)]]\", \"output\": null}, {\"input\": \"[[i for i in range(5000)] + [5000] + [i for i in range(5000, 10000)]]\", \"output\": null}, {\"input\": \"[list(range(1, 10000)) + [9999]]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_sorted(vector<int> lst){\nfor (int i=1;i<lst.size();i++)\n    {\n        if (lst[i]<lst[i-1]) return false;\n        if (i>=2 and lst[i]==lst[i-1] and lst[i]==lst[i-2]) return false;\n    }\n    return true;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_sorted({5}) == true);\n    assert (is_sorted({1, 2, 3, 4, 5}) == true);\n    assert (is_sorted({1, 3, 2, 4, 5}) == false);\n    assert (is_sorted({1, 2, 3, 4, 5, 6}) == true);\n    assert (is_sorted({1, 2, 3, 4, 5, 6, 7}) == true);\n    assert (is_sorted({1, 3, 2, 4, 5, 6, 7}) == false);\n    assert (is_sorted({}) == true);\n    assert (is_sorted({1}) == true);\n    assert (is_sorted({3, 2, 1}) == false);\n    assert (is_sorted({1, 2, 2, 2, 3, 4}) == false);\n    assert (is_sorted({1, 2, 3, 3, 3, 4}) == false);\n    assert (is_sorted({1, 2, 2, 3, 3, 4}) == true);\n    assert (is_sorted({1, 2, 3, 4}) == true);\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include <assert.h>\n#include <vector>\nusing namespace std;\nint main(){\n    vector<int> v1(10000);\n    for (int i = 0; i < 10000; ++i) v1[i] = i;\n    v1.push_back(9999); \n    \n    vector<int> v2(9999);\n    for (int i = 0; i < 9999; ++i) v2[i] = i;\n    v2.push_back(5000); \n    \n    vector<int> v3(10000);\n    for (int i = 0; i < 10000; ++i) v3[i] = i; \n    \n    vector<int> v4(10000);\n    for (int i = 0; i < 5000; ++i) v4[i] = i;\n    v4[5000] = 5000;\n    for (int i = 5001; i < 10000; ++i) v4[i] = i;\n    \n    vector<int> v5(9999);\n    for (int i = 1; i <= 9999; ++i) v5[i-1] = i;\n    v5.push_back(9999);\n    \n    // Example usage of the vectors to ensure syntax validity, actual logic test functions not included since assertions are omitted\n    (void)v1;\n    (void)v2;\n    (void)v3;\n    (void)v4;\n    (void)v5;\n}\n"
    },
    {
        "task_id": "127",
        "entry_point": "intersection",
        "stress_test": "[{\"input\": \"[[-1234, 5678], [345, 6789]]\", \"output\": null}, {\"input\": \"[[1, 10**4], [2, 9999]]\", \"output\": null}, {\"input\": \"[[-10**4, 10**4], [-9999, 0]]\", \"output\": null}, {\"input\": \"[[-10**4 + 1, 10**4 - 1], [-10**4, 10**4]]\", \"output\": null}, {\"input\": \"[[-9999, 9999], [-9998, 9998]]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring intersection( vector<int> interval1,vector<int> interval2){\nint inter1,inter2,l,i;\n    inter1=max(interval1[0],interval2[0]);\n    inter2=min(interval1[1],interval2[1]);\n    l=inter2-inter1;\n    if (l<2) return \"NO\";\n    for (i=2;i*i<=l;i++)\n        if (l%i==0) return \"NO\";\n    return \"YES\";\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (intersection({1, 2}, {2, 3}) == \"NO\");\n    assert (intersection({-1, 1}, {0, 4}) == \"NO\");\n    assert (intersection({-3, -1}, {-5, 5}) == \"YES\");\n    assert (intersection({-2, 2}, {-4, 0}) == \"YES\");\n    assert (intersection({-11, 2}, {-1, -1}) == \"NO\");\n    assert (intersection({1, 2}, {3, 5}) == \"NO\");\n    assert (intersection({1, 2}, {1, 2}) == \"NO\");\n    assert (intersection({-2, -2}, {-3, -2}) == \"NO\");\n}\n",
        "cpp_stress_test": "#include <iostream>\nint main(){intersection({-1234, 5678}, {345, 6789});intersection({1, 10000}, {2, 9999});intersection({-10000, 10000}, {-9999, 0});intersection({-9999, 9999}, {-9998, 9998});intersection({-9999, 9999}, {-9998, 9998});}\n"
    },
    {
        "task_id": "128",
        "entry_point": "prod_signs",
        "stress_test": "[{\"input\": \"[[-i for i in range(1, 10001)]]\", \"output\": null}, {\"input\": \"[[(-1)**i * i for i in range(1, 10001)]]\", \"output\": null}, {\"input\": \"[[-1] * 10000]\", \"output\": null}, {\"input\": \"[[(-1)**i for i in range(10000)]]\", \"output\": null}, {\"input\": \"[[1] * 10000]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint prod_signs(vector<int> arr){\nif (arr.size()==0) return -32768;\n    int i,sum=0,prods=1;\n    for (i=0;i<arr.size();i++)\n    {\n        sum+=abs(arr[i]);\n        if (arr[i]==0) prods=0;\n        if (arr[i]<0) prods=-prods;\n   }\n   return sum*prods;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (prod_signs({1, 2, 2, -4}) == -9);\n    assert (prod_signs({0, 1}) == 0);\n    assert (prod_signs({1, 1, 1, 2, 3, -1, 1}) == -10);\n    assert (prod_signs({}) == -32768);\n    assert (prod_signs({2, 4,1, 2, -1, -1, 9}) == 20);\n    assert (prod_signs({-1, 1, -1, 1}) == 4);\n    assert (prod_signs({-1, 1, 1, 1}) == -4);\n    assert (prod_signs({-1, 1, 1, 0}) == 0);\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include <vector>\nusing namespace std;\nint main() {\n    vector<int> v1; for (int i = 1; i <= 10000; ++i) v1.push_back(-i); prod_signs(v1);\n    vector<int> v2; for (int i = 1; i <= 10000; ++i) v2.push_back((i % 2 == 0) ? i : -i); prod_signs(v2);\n    vector<int> v3(10000, -1); prod_signs(v3);\n    vector<int> v4; for (int i = 0; i < 10000; ++i) v4.push_back((i % 2 == 0) ? 1 : -1); prod_signs(v4);\n    vector<int> v5(10000, 1); prod_signs(v5);\n    return 0;\n}"
    },
    {
        "task_id": "129",
        "entry_point": "minPath",
        "stress_test": "[{\"input\": \"[[[i + j * 100 for i in range(1, 101)] for j in range(100)], 1000]\", \"output\": null}, {\"input\": \"[[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [11, 12, 13, 14, 15, 16, 17, 18, 19, 20], [21, 22, 23, 24, 25, 26, 27, 28, 29, 30], [31, 32, 33, 34, 35, 36, 37, 38, 39, 40], [41, 42, 43, 44, 45, 46, 47, 48, 49, 50], [51, 52, 53, 54, 55, 56, 57, 58, 59, 60], [61, 62, 63, 64, 65, 66, 67, 68, 69, 70], [71, 72, 73, 74, 75, 76, 77, 78, 79, 80], [81, 82, 83, 84, 85, 86, 87, 88, 89, 90], [91, 92, 93, 94, 95, 96, 97, 98, 99, 100]], 150]\", \"output\": null}, {\"input\": \"[[[100, 99, 98, 97, 96, 95, 94, 93, 92, 91], [90, 89, 88, 87, 86, 85, 84, 83, 82, 81], [80, 79, 78, 77, 76, 75, 74, 73, 72, 71], [70, 69, 68, 67, 66, 65, 64, 63, 62, 61], [60, 59, 58, 57, 56, 55, 54, 53, 52, 51], [50, 49, 48, 47, 46, 45, 44, 43, 42, 41], [40, 39, 38, 37, 36, 35, 34, 33, 32, 31], [30, 29, 28, 27, 26, 25, 24, 23, 22, 21], [20, 19, 18, 17, 16, 15, 14, 13, 12, 11], [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]], 100]\", \"output\": null}, {\"input\": \"[[[64, 63, 62, 61, 60, 59, 58, 57], [56, 55, 54, 53, 52, 51, 50, 49], [48, 47, 46, 45, 44, 43, 42, 41], [40, 39, 38, 37, 36, 35, 34, 33], [32, 31, 30, 29, 28, 27, 26, 25], [24, 23, 22, 21, 20, 19, 18, 17], [16, 15, 14, 13, 12, 11, 10, 9], [8, 7, 6, 5, 4, 3, 2, 1]], 50]\", \"output\": null}, {\"input\": \"[[[9, 8, 7, 6, 5, 4, 3, 2, 1], [18, 17, 16, 15, 14, 13, 12, 11, 10], [27, 26, 25, 24, 23, 22, 21, 20, 19], [36, 35, 34, 33, 32, 31, 30, 29, 28], [45, 44, 43, 42, 41, 40, 39, 38, 37], [54, 53, 52, 51, 50, 49, 48, 47, 46], [63, 62, 61, 60, 59, 58, 57, 56, 55], [72, 71, 70, 69, 68, 67, 66, 65, 64], [81, 80, 79, 78, 77, 76, 75, 74, 73]], 30]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\nint i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(minPath({{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, 3) , {1, 2, 1}));\n    assert (issame(minPath({{5, 9, 3}, {4, 1, 6}, {7, 8, 2}}, 1) , {1}));\n    assert (issame(minPath({{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}}, 4) , {1, 2, 1, 2}));\n    assert (issame(minPath({{6, 4, 13, 10}, {5, 7, 12, 1}, {3, 16, 11, 15}, {8, 14, 9, 2}}, 7) , {1, 10, 1, 10, 1, 10, 1}));\n    assert (issame(minPath({{8, 14, 9, 2}, {6, 4, 13, 15}, {5, 7, 1, 12}, {3, 10, 11, 16}}, 5) , {1, 7, 1, 7, 1}));\n    assert (issame(minPath({{11, 8, 7, 2}, {5, 16, 14, 4}, {9, 3, 15, 6}, {12, 13, 10, 1}}, 9) , {1, 6, 1, 6, 1, 6, 1, 6, 1}));\n    assert (issame(minPath({{12, 13, 10, 1}, {9, 3, 15, 6}, {5, 16, 14, 4}, {11, 8, 7, 2}}, 12) , {1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6}));\n    assert (issame(minPath({{2, 7, 4}, {3, 1, 5}, {6, 8, 9}}, 8) , {1, 3, 1, 3, 1, 3, 1, 3}));\n    assert (issame(minPath({{6, 1, 5}, {3, 8, 9}, {2, 7, 4}}, 8) , {1, 5, 1, 5, 1, 5, 1, 5}));\n    assert (issame(minPath({{1, 2}, {3, 4}}, 10) , {1, 2, 1, 2, 1, 2, 1, 2, 1, 2}));\n    assert (issame(minPath({{1, 3}, {3, 2}}, 10) , {1, 3, 1, 3, 1, 3, 1, 3, 1, 3}));\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include <vector>\nusing namespace std;\nint main() {\n    vector<vector<int>> grid1; for (int j = 0; j < 100; ++j) { vector<int> row; for (int i = 1; i <= 100; ++i) row.push_back(i + j * 100); grid1.push_back(row); } minPath(grid1, 1000);\n    vector<vector<int>> grid2; for (int i = 0; i < 10; ++i) { vector<int> row; for (int j = 1; j <= 10; ++j) row.push_back(i * 10 + j); grid2.push_back(row); } minPath(grid2, 150);\n    vector<vector<int>> grid3; for (int i = 0; i < 10; ++i) { vector<int> row; for (int j = 0; j < 10; ++j) row.push_back(100 - (i * 10 + j)); grid3.push_back(row); } minPath(grid3, 100);\n    vector<vector<int>> grid4; for (int i = 0; i < 8; ++i) { vector<int> row; for (int j = 0; j < 8; ++j) row.push_back(64 - (i * 8 + j)); grid4.push_back(row); } minPath(grid4, 50);\n    vector<vector<int>> grid5; for (int i = 0; i < 9; ++i) { vector<int> row; for (int j = 9; j >= 1; --j) row.push_back(i * 9 + j); grid5.push_back(row); } minPath(grid5, 30);\n    return 0;\n}"
    },
    {
        "task_id": "130",
        "entry_point": "tri",
        "stress_test": "[{\"input\": \"[9998]\", \"output\": null}, {\"input\": \"[10000]\", \"output\": null}, {\"input\": \"[9999]\", \"output\": null}, {\"input\": \"[9876]\", \"output\": null}, {\"input\": \"[8888]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\nvector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(tri(3) , {1, 3, 2, 8}));\n    assert (issame(tri(4) , {1, 3, 2, 8, 3}));\n    assert (issame(tri(5) , {1, 3, 2, 8, 3, 15}));\n    assert (issame(tri(6) , {1, 3, 2, 8, 3, 15, 4}));\n    assert (issame(tri(7) , {1, 3, 2, 8, 3, 15, 4, 24}));\n    assert (issame(tri(8) , {1, 3, 2, 8, 3, 15, 4, 24, 5}));\n    assert (issame(tri(9) , {1, 3, 2, 8, 3, 15, 4, 24, 5, 35}));\n    assert (issame(tri(20) , {1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11}));\n    assert (issame(tri(0) , {1}));\n    assert (issame(tri(1) , {1, 3}));\n}\n",
        "cpp_stress_test": "int main(){tri(9998);tri(10000);tri(9999);tri(9876);tri(8888);}"
    },
    {
        "task_id": "131",
        "entry_point": "digits",
        "stress_test": "[{\"input\": \"[13579135791357913579]\", \"output\": null}, {\"input\": \"[11111111111111111111]\", \"output\": null}, {\"input\": \"[1111111111111111111]\", \"output\": null}, {\"input\": \"[12345678901234567890]\", \"output\": null}, {\"input\": \"[13579086421357908642]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint digits(int n){\nint prod=1,has=0;\n    string s=to_string(n);\n    for (int i=0;i<s.length();i++)\n        if (s[i]%2==1) \n        {\n            has=1;\n            prod=prod*(s[i]-48);\n        }\n    if (has==0) return 0;\n    return prod;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (digits(5) == 5);\n    assert (digits(54) == 5);\n    assert (digits(120) ==1);\n    assert (digits(5014) == 5);\n    assert (digits(98765) == 315);\n    assert (digits(5576543) == 2625);\n    assert (digits(2468) == 0);\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include <string>\nusing namespace std;\nint main(){\n    string s1 = \"13579135791357913579\"; int p1 = 1; bool h1 = false; for (char c : s1) if ((c - '0') % 2 == 1) { p1 *= (c - '0'); h1 = true; } if (!h1) p1 = 0;\n    string s2 = \"11111111111111111111\"; int p2 = 1; bool h2 = false; for (char c : s2) if ((c - '0') % 2 == 1) { p2 *= (c - '0'); h2 = true; } if (!h2) p2 = 0;\n    string s3 = \"1111111111111111111\";  int p3 = 1; bool h3 = false; for (char c : s3) if ((c - '0') % 2 == 1) { p3 *= (c - '0'); h3 = true; } if (!h3) p3 = 0;\n    string s4 = \"12345678901234567890\"; int p4 = 1; bool h4 = false; for (char c : s4) if ((c - '0') % 2 == 1) { p4 *= (c - '0'); h4 = true; } if (!h4) p4 = 0;\n    string s5 = \"13579086421357908642\"; int p5 = 1; bool h5 = false; for (char c : s5) if ((c - '0') % 2 == 1) { p5 *= (c - '0'); h5 = true; } if (!h5) p5 = 0;\n    return 0;\n}"
    },
    {
        "task_id": "132",
        "entry_point": "is_nested",
        "stress_test": "[{\"input\": \"['[' + '[][' * 4999 + ']' * 10000 + ']']\", \"output\": null}, {\"input\": \"['[' + '[]' * 4999 + ']' * 5001 + ']']\", \"output\": null}, {\"input\": \"['[' + '[]' * 4998 + '[' + ']' * 5000 + ']']\", \"output\": null}, {\"input\": \"['[' * 5000 + ']' * 4999 + '[]']\", \"output\": null}, {\"input\": \"['' + '[' * 5000 + ']' * 5000 + '']\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_nested(string str){\nint count=0,maxcount=0;\n    for (int i=0;i<str.length();i++)\n    {\n        if (str[i]=='[') count+=1;\n        if (str[i]==']') count-=1;\n        if (count<0) count=0;\n        if (count>maxcount) maxcount=count;\n        if (count<=maxcount-2) return  true;\n    }\n    return false;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_nested(\"[[]]\") == true);\n    assert (is_nested(\"[]]]]]]][[[[[]\") == false);\n    assert (is_nested(\"[][]\") == false);\n    assert (is_nested((\"[]\")) == false);\n    assert (is_nested(\"[[[[]]]]\") == true);\n    assert (is_nested(\"[]]]]]]]]]]\") == false);\n    assert (is_nested(\"[][][[]]\") == true);\n    assert (is_nested(\"[[]\") == false);\n    assert (is_nested(\"[]]\") == false);\n    assert (is_nested(\"[[]][[\") == true);\n    assert (is_nested(\"[[][]]\") == true);\n    assert (is_nested(\"\") == false);\n    assert (is_nested(\"[[[[[[[[\") == false);\n    assert (is_nested(\"]]]]]]]]\") == false);\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\nint main(){is_nested(\"[\" + std::string(4999, '[') + std::string(4999, ']') + \"]\");is_nested(\"[\" + std::string(4999, '[') + std::string(5001, ']') + \"]\");is_nested(\"[\" + std::string(4998, '[') + \"[\" + std::string(5000, ']') + \"]\");is_nested(std::string(5000, '[') + std::string(4999, ']') + \"[]\");is_nested(std::string(5000, '[') + std::string(5000, ']'));}"
    },
    {
        "task_id": "133",
        "entry_point": "sum_squares",
        "stress_test": "[{\"input\": \"[[(-1)**i * (i**3) for i in range(10000)]]\", \"output\": null}, {\"input\": \"[[i**3 for i in range(10000)]]\", \"output\": null}, {\"input\": \"[[(-1)**i * (i**2) for i in range(10000)]]\", \"output\": null}, {\"input\": \"[[i**2 for i in range(10000)]]\", \"output\": null}, {\"input\": \"[[-i for i in range(10000)]]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\nint sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (sum_squares({1,2,3})==14);\n    assert (sum_squares({1.0,2,3})==14);\n    assert (sum_squares({1,3,5,7})==84);\n    assert (sum_squares({1.4,4.2,0})==29);\n    assert (sum_squares({-2.4,1,1})==6);\n    assert (sum_squares({100,1,15,2})==10230);\n    assert (sum_squares({10000,10000})==200000000);\n    assert (sum_squares({-1.4,4.6,6.3})==75);\n    assert (sum_squares({-1.4,17.9,18.9,19.9})==1086);\n    assert (sum_squares({0})==0);\n    assert (sum_squares({-1})==1);\n    assert (sum_squares({-1,1,0})==2);\n}\n",
        "cpp_stress_test": "#include<vector>\nint main(){std::vector<int> v1; for(int i=0;i<10000;++i) v1.push_back((i%2?-1:1)*i*i*i); std::vector<int> v2; for(int i=0;i<10000;++i) v2.push_back(i*i*i); std::vector<int> v3; for(int i=0;i<10000;++i) v3.push_back((i%2?-1:1)*i*i); std::vector<int> v4; for(int i=0;i<10000;++i) v4.push_back(i*i); std::vector<int> v5; for(int i=0;i<10000;++i) v5.push_back(-i);}"
    },
    {
        "task_id": "134",
        "entry_point": "check_if_last_char_is_a_letter",
        "stress_test": "[{\"input\": \"[' ' * 9999 + 'a']\", \"output\": null}, {\"input\": \"['1' + ' ' * 9998 + 'a']\", \"output\": null}, {\"input\": \"[' ' * 10000]\", \"output\": null}, {\"input\": \"[' ' * 5000 + 'a' * 5000]\", \"output\": null}, {\"input\": \"['a' * 5000 + ' b' + ' ' * 4999]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool check_if_last_char_is_a_letter(string txt){\nif (txt.length()==0) return false;\n    char chr=txt[txt.length()-1];\n    if (chr<65 or (chr>90 and chr<97) or chr>122) return false;\n    if (txt.length()==1) return true;\n    chr=txt[txt.length()-2];\n    if ((chr>=65 and chr<=90) or (chr>=97 and chr<=122)) return false;\n    return true;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (check_if_last_char_is_a_letter(\"apple\") == false);\n    assert (check_if_last_char_is_a_letter(\"apple pi e\") == true);\n    assert (check_if_last_char_is_a_letter(\"eeeee\") == false);\n    assert (check_if_last_char_is_a_letter(\"A\") == true);\n    assert (check_if_last_char_is_a_letter(\"Pumpkin pie \") == false);\n    assert (check_if_last_char_is_a_letter(\"Pumpkin pie 1\") == false);\n    assert (check_if_last_char_is_a_letter(\"\") == false);\n    assert (check_if_last_char_is_a_letter(\"eeeee e \") == false);\n    assert (check_if_last_char_is_a_letter(\"apple pie\") == false);\n    assert (check_if_last_char_is_a_letter(\"apple pi e \") == false);\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    check_if_last_char_is_a_letter(std::string(9999, ' ') + \"a\");\n    check_if_last_char_is_a_letter(\"1\" + std::string(9998, ' ') + \"a\");\n    check_if_last_char_is_a_letter(std::string(10000, ' '));\n    check_if_last_char_is_a_letter(std::string(5000, ' ') + std::string(5000, 'a'));\n    check_if_last_char_is_a_letter(std::string(5000, 'a') + \" b\" + std::string(4999, ' '));\n}"
    },
    {
        "task_id": "135",
        "entry_point": "can_arrange",
        "stress_test": "[{\"input\": \"[[10000 - i for i in range(10000)]]\", \"output\": null}, {\"input\": \"[list(range(10000, 0, -1))]\", \"output\": null}, {\"input\": \"[list(range(9999, -1, -1))]\", \"output\": null}, {\"input\": \"[[i if i % 2 == 0 else i - 2 for i in range(10000)]]\", \"output\": null}, {\"input\": \"[[i**2 for i in range(10000)]]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint can_arrange(vector<int> arr){\nint max=-1;\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]<=i) max=i;\n    return max;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (can_arrange({1,2,4,3,5})==3);\n    assert (can_arrange({1,2,4,5})==-1);\n    assert (can_arrange({1,4,2,5,6,7,8,9,10})==2);\n    assert (can_arrange({4,8,5,7,3})==4);\n    assert (can_arrange({})==-1);\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include <vector>\nusing namespace std;\nint main() {\n    vector<int> v1; for (int i = 0; i < 10000; ++i) v1.push_back(10000 - i); can_arrange(v1);\n    vector<int> v2; for (int i = 10000; i > 0; --i) v2.push_back(i); can_arrange(v2);\n    vector<int> v3; for (int i = 9999; i >= 0; --i) v3.push_back(i); can_arrange(v3);\n    vector<int> v4; for (int i = 0; i < 10000; ++i) v4.push_back((i % 2 == 0) ? i : i - 2); can_arrange(v4);\n    vector<int> v5; for (int i = 0; i < 10000; ++i) v5.push_back(i * i); can_arrange(v5);\n    return 0;\n}"
    },
    {
        "task_id": "136",
        "entry_point": "largest_smallest_integers",
        "stress_test": "[{\"input\": \"[[i if i % 5 != 0 else -i for i in range(-10000, 10000)]]\", \"output\": null}, {\"input\": \"[[i if i % 3 != 0 else -i for i in range(-9999, 9999)]]\", \"output\": null}, {\"input\": \"[[int(i / 2) if i % 2 == 0 else -int(i / 2) for i in range(20000)]]\", \"output\": null}, {\"input\": \"[list(range(-5000, 0)) + [0] * 9999 + list(range(1, 5001))]\", \"output\": null}, {\"input\": \"[[-2**31 + i for i in range(10000)]]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> largest_smallest_integers(vector<int> lst){\nint maxneg=0,minpos=0;\n    for (int i=0;i<lst.size();i++)\n    {\n        if (lst[i]<0 and (maxneg==0 or lst[i]>maxneg)) maxneg=lst[i];\n        if (lst[i]>0 and (minpos==0 or lst[i]<minpos)) minpos=lst[i];\n    }\n    return {maxneg,minpos};\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(largest_smallest_integers({2, 4, 1, 3, 5, 7}) , {0, 1}));\n    assert (issame(largest_smallest_integers({2, 4, 1, 3, 5, 7, 0}) , {0, 1}));\n    assert (issame(largest_smallest_integers({1, 3, 2, 4, 5, 6, -2}) , {-2, 1}));\n    assert (issame(largest_smallest_integers({4, 5, 3, 6, 2, 7, -7}) , {-7, 2}));\n    assert (issame(largest_smallest_integers({7, 3, 8, 4, 9, 2, 5, -9}) , {-9, 2}));\n    assert (issame(largest_smallest_integers({}) , {0, 0}));\n    assert (issame(largest_smallest_integers({0}) , {0, 0}));\n    assert (issame(largest_smallest_integers({-1, -3, -5, -6}) , {-1, 0}));\n    assert (issame(largest_smallest_integers({-1, -3, -5, -6, 0}) , {-1, 0}));\n    assert (issame(largest_smallest_integers({-6, -4, -4, -3, 1}) , {-3, 1}));\n    assert (issame(largest_smallest_integers({-6, -4, -4, -3, -100, 1}) , {-3, 1}));\n\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include <vector>\nusing namespace std;\nint main() {\n    vector<int> v1; for (int i = -10000; i < 10000; ++i) v1.push_back(i % 5 != 0 ? i : -i); largest_smallest_integers(v1);\n    vector<int> v2; for (int i = -9999; i < 9999; ++i) v2.push_back(i % 3 != 0 ? i : -i); largest_smallest_integers(v2);\n    vector<int> v3; for (int i = 0; i < 20000; ++i) v3.push_back(i % 2 == 0 ? i / 2 : -i / 2); largest_smallest_integers(v3);\n    vector<int> v4; for (int i = -5000; i < 0; ++i) v4.push_back(i); for (int i = 0; i < 9999; ++i) v4.push_back(0); for (int i = 1; i <= 5000; ++i) v4.push_back(i); largest_smallest_integers(v4);\n    vector<int> v5; for (int i = 0; i < 10000; ++i) v5.push_back(-2147483648 + i); largest_smallest_integers(v5);\n    return 0;\n}"
    },
    {
        "task_id": "137",
        "entry_point": "compare_one",
        "stress_test": "[{\"input\": \"['1000,0000000000001', '1000.0000000000002']\", \"output\": null}, {\"input\": \"['-9999999999999999,9999999999999999', float('-inf')]\", \"output\": null}, {\"input\": \"[float('inf'), '9999999999999999,9999999999999999']\", \"output\": null}, {\"input\": \"['123456789123456789', '123456789123456789.0']\", \"output\": null}, {\"input\": \"['1234567890,1234567890', 1234567890.1234567890]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\ndouble  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (boost::any_cast<int>(compare_one(1, 2)) == 2);\n    assert (boost::any_cast<double>(compare_one(1, 2.5))== 2.5);\n    assert (boost::any_cast<int>(compare_one(2, 3)) == 3);\n    assert (boost::any_cast<int>(compare_one(5, 6)) == 6);\n    assert (boost::any_cast<string>(compare_one(1, string(\"2,3\")))== \"2,3\");\n    assert (boost::any_cast<string>(compare_one(string(\"5,1\"), string(\"6\"))) == \"6\");\n    assert (boost::any_cast<string>(compare_one(string(\"1\"), string(\"2\"))) == \"2\");\n    assert (boost::any_cast<string>(compare_one(string(\"1\"), 1)) == \"None\");\n}\n",
        "cpp_stress_test": "#include <boost/any.hpp>\n#include <string>\n#include <limits>\nusing namespace std;\nint main() {\n    compare_one(string(\"1000,0000000000001\"), string(\"1000.0000000000002\"));\n    compare_one(string(\"-9999999999999999,9999999999999999\"), -numeric_limits<double>::infinity());\n    compare_one(numeric_limits<double>::infinity(), string(\"9999999999999999,9999999999999999\"));\n    compare_one(string(\"123456789123456789\"), string(\"123456789123456789.0\"));\n    compare_one(string(\"1234567890,1234567890\"), 1234567890.1234567890);\n    return 0;\n}"
    },
    {
        "task_id": "138",
        "entry_point": "is_equal_to_sum_even",
        "stress_test": "[{\"input\": \"[2]\", \"output\": null}, {\"input\": \"[1000]\", \"output\": null}, {\"input\": \"[9998]\", \"output\": null}, {\"input\": \"[10000]\", \"output\": null}, {\"input\": \"[1234]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_equal_to_sum_even(int n){\nif (n%2==0 and n>=8) return true;\n    return false;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_equal_to_sum_even(4) == false);\n    assert (is_equal_to_sum_even(6) == false);\n    assert (is_equal_to_sum_even(8) == true);\n    assert (is_equal_to_sum_even(10) == true);\n    assert (is_equal_to_sum_even(11) == false);\n    assert (is_equal_to_sum_even(12) == true);\n    assert (is_equal_to_sum_even(13) == false);\n    assert (is_equal_to_sum_even(16) == true);\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\nint main(){ is_equal_to_sum_even(2); is_equal_to_sum_even(1000); is_equal_to_sum_even(9998); is_equal_to_sum_even(10000); is_equal_to_sum_even(1234); }"
    },
    {
        "task_id": "139",
        "entry_point": "special_factorial",
        "stress_test": "[{\"input\": \"[500]\", \"output\": null}, {\"input\": \"[250]\", \"output\": null}, {\"input\": \"[200]\", \"output\": null}, {\"input\": \"[100]\", \"output\": null}, {\"input\": \"[99]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long special_factorial(int n){\nlong long fact=1,bfact=1;\n    for (int i=1;i<=n;i++)\n    {\n        fact=fact*i;\n        bfact=bfact*fact;\n    }\n    return bfact;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (special_factorial(4) == 288);\n    assert (special_factorial(5) == 34560);\n    assert (special_factorial(7) == 125411328000);\n    assert (special_factorial(1) == 1);\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\nint main(){ special_factorial(500); special_factorial(250); special_factorial(200); special_factorial(100); special_factorial(99); }"
    },
    {
        "task_id": "140",
        "entry_point": "fix_spaces",
        "stress_test": "[{\"input\": \"['An    extremely long string with a lot of spaces ' * 1000]\", \"output\": null}, {\"input\": \"['A'*10000 + ' ' + 'B'*10000]\", \"output\": null}, {\"input\": \"['A'*1000 + ' ' + 'B'*1000 + ' ' * 5 + 'C'*1000]\", \"output\": null}, {\"input\": \"['This  is a string      with   multiple spaces and  even more spaces   ']\", \"output\": null}, {\"input\": \"['a b c    d e f g h i     j k l m n o p q r s t u    v w x y z']\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring fix_spaces(string text){\nstring out=\"\";\n    int spacelen=0;\n    for (int i=0;i<text.length();i++)\n    if (text[i]==' ') spacelen+=1;\n    else\n    {\n        if (spacelen==1) out=out+'_';\n        if (spacelen==2) out=out+\"__\";\n        if (spacelen>2) out=out+'-';\n        spacelen=0;\n        out=out+text[i];\n    }\n    if (spacelen==1) out=out+'_';\n    if (spacelen==2) out=out+\"__\";\n    if (spacelen>2) out=out+'-';\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (fix_spaces(\"Example\") == \"Example\");\n    assert (fix_spaces(\"Mudasir Hanif \") == \"Mudasir_Hanif_\");\n    assert (fix_spaces(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\");\n    assert (fix_spaces(\"Exa   mple\") == \"Exa-mple\");\n    assert (fix_spaces(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\");\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include <string>\nusing namespace std;\nint main() {\n    string s1; for (int i = 0; i < 1000; ++i) s1 += \"An    extremely long string with a lot of spaces \"; fix_spaces(s1);\n    string s2 = string(10000, 'A') + \" \" + string(10000, 'B'); fix_spaces(s2);\n    string s3 = string(1000, 'A') + \" \" + string(1000, 'B') + string(5, ' ') + string(1000, 'C'); fix_spaces(s3);\n    fix_spaces(\"This  is a string      with   multiple spaces and  even more spaces   \");\n    fix_spaces(\"a b c    d e f g h i     j k l m n o p q r s t u    v w x y z\");\n    return 0;\n}"
    },
    {
        "task_id": "141",
        "entry_point": "file_name_check",
        "stress_test": "[{\"input\": \"['a' + '1' * 9997 + '.exe']\", \"output\": null}, {\"input\": \"['a' + '1' * 9997 + '.txt']\", \"output\": null}, {\"input\": \"['a' * 9999 + '1' * 3 + '.txt']\", \"output\": null}, {\"input\": \"['a' * 9997 + '1' * 3 + 'b' + '.dll']\", \"output\": null}, {\"input\": \"['a' * 9998 + '1' * 2 + '.exe']\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring file_name_check(string file_name){\nint numdigit=0,numdot=0;\n    if (file_name.length()<5) return \"No\";\n    char w=file_name[0];\n    if (w<65 or (w>90 and w<97) or w>122) return \"No\";\n    string last=file_name.substr(file_name.length()-4,4);\n    if (last!=\".txt\" and last!=\".exe\" and last!=\".dll\") return \"No\";\n    for (int i=0;i<file_name.length();i++)\n    {\n        if (file_name[i]>=48 and file_name[i]<=57) numdigit+=1;\n        if (file_name[i]=='.') numdot+=1;\n    }\n    if (numdigit>3 or numdot!=1) return \"No\";\n    return \"Yes\"; \n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (file_name_check(\"example.txt\") == \"Yes\");\n    assert (file_name_check(\"1example.dll\") == \"No\");\n    assert (file_name_check(\"s1sdf3.asd\") == \"No\");\n    assert (file_name_check(\"K.dll\") == \"Yes\");\n    assert (file_name_check(\"MY16FILE3.exe\") == \"Yes\");\n    assert (file_name_check(\"His12FILE94.exe\") == \"No\");\n    assert (file_name_check(\"_Y.txt\") == \"No\");\n    assert (file_name_check(\"?aREYA.exe\") == \"No\");\n    assert (file_name_check(\"/this_is_valid.dll\") == \"No\");\n    assert (file_name_check(\"this_is_valid.wow\") == \"No\");\n    assert (file_name_check(\"this_is_valid.txt\") == \"Yes\");\n    assert (file_name_check(\"this_is_valid.txtexe\") == \"No\");\n    assert (file_name_check(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert (file_name_check(\"@this1_is6_valid.exe\") == \"No\");\n    assert (file_name_check(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert (file_name_check(\"all.exe.txt\") == \"No\");\n    assert (file_name_check(\"I563_No.exe\") == \"Yes\");\n    assert (file_name_check(\"Is3youfault.txt\") == \"Yes\");\n    assert (file_name_check(\"no_one#knows.dll\") == \"Yes\");\n    assert (file_name_check(\"1I563_Yes3.exe\") == \"No\");\n    assert (file_name_check(\"I563_Yes3.txtt\") == \"No\");\n    assert (file_name_check(\"final..txt\") == \"No\");\n    assert (file_name_check(\"final132\") == \"No\");\n    assert (file_name_check(\"_f4indsartal132.\") == \"No\");\n    assert (file_name_check(\".txt\") == \"No\");\n    assert (file_name_check(\"s.\") == \"No\");\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\nint main(){file_name_check(std::string(1, 'a') + std::string(9997, '1') + \".exe\");file_name_check(std::string(1, 'a') + std::string(9997, '1') + \".txt\");file_name_check(std::string(9999, 'a') + std::string(3, '1') + \".txt\");file_name_check(std::string(9997, 'a') + std::string(3, '1') + \"b\" + \".dll\");file_name_check(std::string(9998, 'a') + std::string(2, '1') + \".exe\");}"
    },
    {
        "task_id": "142",
        "entry_point": "sum_squares",
        "stress_test": "[{\"input\": \"[[(-1)**i * (i**3) for i in range(10000)]]\", \"output\": null}, {\"input\": \"[[i**3 for i in range(10000)]]\", \"output\": null}, {\"input\": \"[[(-1)**i * (i**2) for i in range(10000)]]\", \"output\": null}, {\"input\": \"[[i**2 for i in range(10000)]]\", \"output\": null}, {\"input\": \"[[-i for i in range(10000)]]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\nint sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (sum_squares({1,2,3}) == 6);\n    assert (sum_squares({1,4,9}) == 14);\n    assert (sum_squares({}) == 0);\n    assert (sum_squares({1,1,1,1,1,1,1,1,1}) == 9);\n    assert (sum_squares({-1,-1,-1,-1,-1,-1,-1,-1,-1}) == -3);\n    assert (sum_squares({0}) == 0);\n    assert (sum_squares({-1,-5,2,-1,-5}) == -126);\n    assert (sum_squares({-56,-99,1,0,-2}) == 3030);\n    assert (sum_squares({-1,0,0,0,0,0,0,0,-1}) == 0);\n    assert (sum_squares({-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37}) == -14196);\n    assert (sum_squares({-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10}) == -1448);\n}\n",
        "cpp_stress_test": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nint main() {\n    std::vector<int> v1;\n    for (int i = 0; i < 10000; ++i) v1.push_back(std::pow(-1, i) * std::pow(i, 3));\n    std::vector<int> v2;\n    for (int i = 0; i < 10000; ++i) v2.push_back(std::pow(i, 3));\n    std::vector<int> v3;\n    for (int i = 0; i < 10000; ++i) v3.push_back(std::pow(-1, i) * std::pow(i, 2));\n    std::vector<int> v4;\n    for (int i = 0; i < 10000; ++i) v4.push_back(std::pow(i, 2));\n    std::vector<int> v5;\n    for (int i = 0; i < 10000; ++i) v5.push_back(-i);\n}"
    },
    {
        "task_id": "143",
        "entry_point": "words_in_sentence",
        "stress_test": "[{\"input\": \"['a sentence with mixed lengths of words to see how the function handles different scenarios']\", \"output\": null}, {\"input\": \"['x' * 100]\", \"output\": null}, {\"input\": \"['this sentence has many many words that have lengths which are not prime numbers']\", \"output\": null}, {\"input\": \"['prime length words are fun to find and test in various ways for stress testing']\", \"output\": null}, {\"input\": \"['supercalifragilisticexpialidocious antidisestablishmentarianism floccinaucinihilipilification']\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring words_in_sentence(string sentence){\nstring out=\"\";\n    string current=\"\";\n    sentence=sentence+' ';\n\n    for (int i=0;i<sentence.size();i++)\n    if (sentence[i]!=' ') current=current+sentence[i];\n    else\n    {\n        bool isp=true;\n        int l=current.length();\n        if (l<2) isp=false;\n        for (int j=2;j*j<=l;j++)\n            if (l%j==0) isp=false;\n        if (isp) out=out+current+' ';\n        current=\"\";        \n    }\n    if (out.length()>0)\n        out.pop_back();\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (words_in_sentence(\"This is a test\") == \"is\");\n    assert (words_in_sentence(\"lets go for swimming\") == \"go for\");\n    assert (words_in_sentence(\"there is no place available here\") == \"there is no place\");\n    assert (words_in_sentence(\"Hi I am Hussein\") == \"Hi am Hussein\");\n    assert (words_in_sentence(\"go for it\") == \"go for it\");\n    assert (words_in_sentence(\"here\") == \"\");\n    assert (words_in_sentence(\"here is\") == \"is\");\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\nint main(){words_in_sentence(\"a sentence with mixed lengths of words to see how the function handles different scenarios\");words_in_sentence(std::string(100, 'x'));words_in_sentence(\"this sentence has many many words that have lengths which are not prime numbers\");words_in_sentence(\"prime length words are fun to find and test in various ways for stress testing\");words_in_sentence(\"supercalifragilisticexpialidocious antidisestablishmentarianism floccinaucinihilipilification\");}"
    },
    {
        "task_id": "144",
        "entry_point": "simplify",
        "stress_test": "[{\"input\": \"['123456/789012', '345678/123456']\", \"output\": null}, {\"input\": \"['9999/10000', '10000/9999']\", \"output\": null}, {\"input\": \"['5432/9876', '8765/4321']\", \"output\": null}, {\"input\": \"['9999/1234', '4321/5678']\", \"output\": null}, {\"input\": \"['1001/1002', '1003/1004']\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nbool simplify(string x,string n){\nint a,b,c,d,i;\n    for (i=0;i<x.size();i++)\n        if (x[i]=='/') \n        {\n            a=atoi(x.substr(0,i).c_str());\n            b=atoi(x.substr(i+1).c_str());\n        }\n    for (i=0;i<n.size();i++)\n        if (n[i]=='/') \n        {\n            c=atoi(n.substr(0,i).c_str());\n            d=atoi(n.substr(i+1).c_str());\n        }\n    if ((a*c)%(b*d)==0) return true;\n    return false;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (simplify(\"1/5\", \"5/1\") == true);\n    assert (simplify(\"1/6\", \"2/1\") == false);\n    assert (simplify(\"5/1\", \"3/1\") == true);\n    assert (simplify(\"7/10\", \"10/2\") == false);\n    assert (simplify(\"2/10\", \"50/10\") == true);\n    assert (simplify(\"7/2\", \"4/2\") == true);\n    assert (simplify(\"11/6\", \"6/1\") == true);\n    assert (simplify(\"2/3\", \"5/2\") == false);\n    assert (simplify(\"5/2\", \"3/5\") == false);\n    assert (simplify(\"2/4\", \"8/4\") == true);\n    assert (simplify(\"2/4\", \"4/2\") == true);\n    assert (simplify(\"1/5\", \"5/1\") == true);\n    assert (simplify(\"1/5\", \"1/5\") == false);\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    simplify(\"123456/789012\", \"345678/123456\");\n    simplify(\"9999/10000\", \"10000/9999\");\n    simplify(\"5432/9876\", \"8765/4321\");\n    simplify(\"9999/1234\", \"4321/5678\");\n    simplify(\"1001/1002\", \"1003/1004\");\n}"
    },
    {
        "task_id": "145",
        "entry_point": "order_by_points",
        "stress_test": "[{\"input\": \"[[i if i % 3 == 0 else -i for i in range(1, 10001)]]\", \"output\": null}, {\"input\": \"[[int(x) for x in range(-10000, 10000, 2)]]\", \"output\": null}, {\"input\": \"[[i if i % 2 == 0 else -i for i in range(1, 10001)]]\", \"output\": null}, {\"input\": \"[[(-1) ** i * i for i in range(1, 10001)]]\", \"output\": null}, {\"input\": \"[[i * (-1) ** i for i in range(1, 10000)]]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> order_by_points(vector<int> nums){\nvector<int> sumdigit={};\n    for (int i=0;i<nums.size();i++)\n    {\n        string w=to_string(abs(nums[i]));\n        int sum=0;\n        for (int j=1;j<w.length();j++)\n            sum+=w[j]-48;\n        if (nums[i]>0) sum+=w[0]-48;\n        else sum-=w[0]-48;\n        sumdigit.push_back(sum);\n    }\n    int m;\n    for (int i=0;i<nums.size();i++)\n    for (int j=1;j<nums.size();j++)\n    if (sumdigit[j-1]>sumdigit[j])\n    {\n        m=sumdigit[j];sumdigit[j]=sumdigit[j-1];sumdigit[j-1]=m;\n        m=nums[j];nums[j]=nums[j-1];nums[j-1]=m;\n    }\n     \n    return nums;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(order_by_points({1, 11, -1, -11, -12}) , {-1, -11, 1, -12, 11}));\n    assert (issame(order_by_points({1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46}) , {0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457}));\n    assert (issame(order_by_points({}) , {}));\n    assert (issame(order_by_points({1, -11, -32, 43, 54, -98, 2, -3}) , {-3, -32, -98, -11, 1, 2, 43, 54}));\n    assert (issame(order_by_points({1,2,3,4,5,6,7,8,9,10,11}) , {1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9}));\n    assert (issame(order_by_points({0,6,6,-76,-21,23,4}) , {-76, -21, 0, 4, 23, 6, 6}));\n    \n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\n#include<vector>\nusing namespace std;\nint main(){vector<int> a;for(int i=1;i<=10000;i++){a.push_back(i%3==0?i:-i);}vector<int> b=order_by_points(a);vector<int> c;for(int i=-10000;i<10000;i+=2){c.push_back(i);}b=order_by_points(c);a.clear();for(int i=1;i<=10000;i++){a.push_back(i%2==0?i:-i);}b=order_by_points(a);a.clear();for(int i=1;i<=10000;i++){a.push_back(pow(-1,i)*i);}b=order_by_points(a);a.clear();for(int i=1;i<10000;i++){a.push_back(i*pow(-1,i));}b=order_by_points(a);}"
    },
    {
        "task_id": "146",
        "entry_point": "specialFilter",
        "stress_test": "[{\"input\": \"[[i for i in range(1, 10001)]]\", \"output\": null}, {\"input\": \"[[x for x in range(-10000, 10001, 2)]]\", \"output\": null}, {\"input\": \"[[i for i in range(-5000, 5000)]]\", \"output\": null}, {\"input\": \"[[i for i in range(1, 10001) if i % 2 != 0 and i > 10]]\", \"output\": null}, {\"input\": \"[[x for x in range(1, 10001) if str(x)[0] in '13579' and str(x)[-1] in '13579']]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint specialFilter(vector<int> nums){\nint num=0;\n    for (int i=0;i<nums.size();i++)\n    if (nums[i]>10)\n    {\n        string w=to_string(nums[i]);\n        if (w[0]%2==1 and w[w.length()-1]%2==1) num+=1;\n    }\n    return num;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (specialFilter({5, -2, 1, -5}) == 0  );\n    assert (specialFilter({15, -73, 14, -15}) == 1);\n    assert (specialFilter({33, -2, -3, 45, 21, 109}) == 2);\n    assert (specialFilter({43, -12, 93, 125, 121, 109}) == 4);\n    assert (specialFilter({71, -2, -33, 75, 21, 19}) == 3);\n    assert (specialFilter({1}) == 0              );\n    assert (specialFilter({}) == 0                   );\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include <vector>\nusing namespace std;\nint main() {\n    vector<int> v1; for (int i = 1; i <= 10000; ++i) v1.push_back(i); specialFilter(v1);\n    vector<int> v2; for (int x = -10000; x <= 10000; x += 2) v2.push_back(x); specialFilter(v2);\n    vector<int> v3; for (int i = -5000; i < 5000; ++i) v3.push_back(i); specialFilter(v3);\n    vector<int> v4; for (int i = 11; i <= 10000; i += 2) v4.push_back(i); specialFilter(v4);\n    vector<int> v5; for (int x = 1; x <= 10000; ++x) { string s = to_string(x); if (s[0] % 2 == 1 && s.back() % 2 == 1) v5.push_back(x); } specialFilter(v5);\n    return 0;\n}"
    },
    {
        "task_id": "147",
        "entry_point": "get_max_triples",
        "stress_test": "[{\"input\": \"[200]\", \"output\": null}, {\"input\": \"[199]\", \"output\": null}, {\"input\": \"[198]\", \"output\": null}, {\"input\": \"[197]\", \"output\": null}, {\"input\": \"[196]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint get_matrix_triples(int n){\nvector<int> a;\n    vector<vector<int>> sum={{0,0,0}};\n    vector<vector<int>> sum2={{0,0,0}};\n    for (int i=1;i<=n;i++)\n    {\n        a.push_back((i*i-i+1)%3);\n        sum.push_back(sum[sum.size()-1]);\n        sum[i][a[i-1]]+=1;\n    }\n    for (int times=1;times<3;times++)\n    {\n    for (int i=1;i<=n;i++)\n    {\n        sum2.push_back(sum2[sum2.size()-1]);\n        if (i>=1)\n        for (int j=0;j<=2;j++)\n            sum2[i][(a[i-1]+j)%3]+=sum[i-1][j];\n    }\n    sum=sum2;\n    sum2={{0,0,0}};\n    }\n\n    return sum[n][0];\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (get_matrix_triples(5) == 1);\n    assert (get_matrix_triples(6) == 4);\n    assert (get_matrix_triples(10) == 36);\n    assert (get_matrix_triples(100) == 53361);\n}\n",
        "cpp_stress_test": "int main(){get_matrix_triples(200);get_matrix_triples(199);get_matrix_triples(198);get_matrix_triples(197);get_matrix_triples(196);}"
    },
    {
        "task_id": "148",
        "entry_point": "bf",
        "stress_test": "[{\"input\": \"['Neptune', 'Mars']\", \"output\": null}, {\"input\": \"['Jupiter', 'Uranus']\", \"output\": null}, {\"input\": \"['Saturn', 'Jupiter']\", \"output\": null}, {\"input\": \"['Neptune', 'Mercury']\", \"output\": null}, {\"input\": \"['Mercury', 'Neptune']\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> bf(string planet1,string planet2){\nvector<string> planets={\"Mercury\",\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\"};\n    int pos1=-1,pos2=-1,m;\n    for (m=0;m<planets.size();m++)\n    {\n    if (planets[m]==planet1) pos1=m;\n    if (planets[m]==planet2) pos2=m;\n    }\n    if (pos1==-1 or pos2==-1) return {};\n    if (pos1>pos2) {m=pos1;pos1=pos2;pos2=m;}\n    vector<string> out={};\n    for (m=pos1+1;m<pos2;m++)\n    out.push_back(planets[m]);\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(bf(\"Jupiter\", \"Neptune\") , {\"Saturn\", \"Uranus\"}));\n    assert (issame(bf(\"Earth\", \"Mercury\") , {\"Venus\",}));\n    assert (issame(bf(\"Mercury\", \"Uranus\") , {\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}));\n    assert (issame(bf(\"Neptune\", \"Venus\") , {\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"}));\n    assert (issame(bf(\"Earth\", \"Earth\") , {}));\n    assert (issame(bf(\"Mars\", \"Earth\") , {}));\n    assert (issame(bf(\"Jupiter\", \"Makemake\") , {}));\n}\n",
        "cpp_stress_test":"#undef NDEBUG\n#include<assert.h>\n#include<vector>\n#include<string>\nusing namespace std;\nint main() { bf(\"Neptune\", \"Mars\"); bf(\"Jupiter\", \"Uranus\"); bf(\"Saturn\", \"Jupiter\"); bf(\"Neptune\", \"Mercury\"); bf(\"Mercury\", \"Neptune\"); }"
    },
    {
        "task_id": "149",
        "entry_point": "sorted_list_sum",
        "stress_test": "[{\"input\": \"[['a'*i for i in range(1, 5001)] + ['b'*i for i in range(1, 5001)] + ['c'*i for i in range(1, 5001)]]\", \"output\": null}, {\"input\": \"[['x'*i for i in range(1, 10001)]]\", \"output\": null}, {\"input\": \"[['a'*i for i in range(1, 10001)]]\", \"output\": null}, {\"input\": \"[['a'*i for i in range(2, 10001, 2)]+['b'*i for i in range(1, 10001, 2)]]\", \"output\": null}, {\"input\": \"[['a'*i for i in range(1, 10001, 2)] + ['b'*i for i in range(2, 10002, 2)]]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nvector<string> sorted_list_sum(vector<string> lst){\nvector<string> out={};\n    for (int i=0;i<lst.size();i++)\n    if (lst[i].length()%2==0) out.push_back(lst[i]);\n    string mid;\n    sort(out.begin(),out.end());\n    for (int i=0;i<out.size();i++)\n    for (int j=1;j<out.size();j++)\n    if (out[j].length()<out[j-1].length())\n    {\n        mid=out[j];out[j]=out[j-1];out[j-1]=mid;\n    }\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sorted_list_sum({\"aa\", \"a\", \"aaa\"}) , {\"aa\"}));\n    assert (issame(sorted_list_sum({\"school\", \"AI\", \"asdf\", \"b\"}) , {\"AI\", \"asdf\", \"school\"}));\n    assert (issame(sorted_list_sum({\"d\", \"b\", \"c\", \"a\"}) , {}));\n    assert (issame(sorted_list_sum({\"d\", \"dcba\", \"abcd\", \"a\"}) , {\"abcd\", \"dcba\"}));\n    assert (issame(sorted_list_sum({\"AI\", \"ai\", \"au\"}) , {\"AI\", \"ai\", \"au\"}));\n    assert (issame(sorted_list_sum({\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"}) , {}));\n    assert (issame(sorted_list_sum({\"aaaa\", \"bbbb\", \"dd\", \"cc\"}) , {\"cc\", \"dd\", \"aaaa\", \"bbbb\"}));\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include <string>\n#include <vector>\nusing namespace std;\nint main(){\n    vector<string> v1; for(int i = 1; i <= 5000; ++i) v1.push_back(string(i, 'a')); for(int i = 1; i <= 5000; ++i) v1.push_back(string(i, 'b')); for(int i = 1; i <= 5000; ++i) v1.push_back(string(i, 'c')); sorted_list_sum(v1);\n    vector<string> v2; for(int i = 1; i <= 10000; ++i) v2.push_back(string(i, 'x')); sorted_list_sum(v2);\n    vector<string> v3; for(int i = 1; i <= 10000; ++i) v3.push_back(string(i, 'a')); sorted_list_sum(v3);\n    vector<string> v4; for(int i = 2; i <= 10000; i += 2) v4.push_back(string(i, 'a')); for(int i = 1; i <= 10000; i += 2) v4.push_back(string(i, 'b')); sorted_list_sum(v4);\n    vector<string> v5; for(int i = 1; i <= 10000; i += 2) v5.push_back(string(i, 'a')); for(int i = 2; i <= 10002; i += 2) v5.push_back(string(i, 'b')); sorted_list_sum(v5);\n    return 0;\n}"
    },
    {
        "task_id": "150",
        "entry_point": "x_or_y",
        "stress_test": "[{\"input\": \"[999983, 31415, 92653]\", \"output\": null}, {\"input\": \"[999983, 100, 200]\", \"output\": null}, {\"input\": \"[99991, 10101, 20202]\", \"output\": null}, {\"input\": \"[99991, 234, 432]\", \"output\": null}, {\"input\": \"[10007, 8888, 9999]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\nbool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (x_or_y(7, 34, 12) == 34);\n    assert (x_or_y(15, 8, 5) == 5);\n    assert (x_or_y(3, 33, 5212) == 33);\n    assert (x_or_y(1259, 3, 52) == 3);\n    assert (x_or_y(7919, -1, 12) == -1);\n    assert (x_or_y(3609, 1245, 583) == 583);\n    assert (x_or_y(91, 56, 129) == 129);\n    assert (x_or_y(6, 34, 1234) == 1234);\n    assert (x_or_y(1, 2, 0) == 0);\n    assert (x_or_y(2, 2, 0) == 2);\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\nint main(){x_or_y(999983, 31415, 92653);x_or_y(999983, 100, 200);x_or_y(99991, 10101, 20202);x_or_y(99991, 234, 432);x_or_y(10007, 8888, 9999);}"
    },
    {
        "task_id": "151",
        "entry_point": "double_the_difference",
        "stress_test": "[{\"input\": \"[[1, 3, 5, 7, 9] * 2000]\", \"output\": null}, {\"input\": \"[[i for i in range(-10000, 10001)]]\", \"output\": null}, {\"input\": \"[[-i if i % 2 != 0 else i for i in range(-10000, 0)]]\", \"output\": null}, {\"input\": \"[[i for i in range(1, 10001) if i % 2 != 0]]\", \"output\": null}, {\"input\": \"[[i if i % 3 != 0 else -i for i in range(1, 10001)]]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long double_the_difference(vector<float> lst){\nlong long sum=0;\n    for (int i=0;i<lst.size();i++)\n    if (lst[i]-round(lst[i])<1e-4)\n    if (lst[i]>0 and (int)(round(lst[i]))%2==1) sum+=(int)(round(lst[i]))*(int)(round(lst[i]));\n    return sum;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (double_the_difference({}) == 0);\n    assert (double_the_difference({5, 4}) == 25);\n    assert (double_the_difference({0.1, 0.2, 0.3}) == 0 );\n    assert (double_the_difference({-10, -20, -30}) == 0 );\n    assert (double_the_difference({-1, -2, 8}) == 0);\n    assert (double_the_difference({0.2, 3, 5}) == 34);\n    \n    \n    long long odd_sum=0;\n    vector<float> lst={};\n\n    for (int i=-99;i<100;i+=2)\n    {\n        lst.push_back(i+0.0);\n        if (i>0 and i%2==1) odd_sum+=i*i;\n    }\n  \n    assert (double_the_difference(lst) == odd_sum );\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include <vector>\nusing namespace std;\nint main(){\n    vector<float> v1; for(int i = 0; i < 2000; ++i) { v1.push_back(1); v1.push_back(3); v1.push_back(5); v1.push_back(7); v1.push_back(9); } double_the_difference(v1);\n    vector<float> v2; for(int i = -10000; i <= 10000; ++i) v2.push_back(i); double_the_difference(v2);\n    vector<float> v3; for(int i = -10000; i < 0; ++i) v3.push_back((i % 2 != 0) ? -i : i); double_the_difference(v3);\n    vector<float> v4; for(int i = 1; i <= 10000; ++i) if(i % 2 != 0) v4.push_back(i); double_the_difference(v4);\n    vector<float> v5; for(int i = 1; i <= 10000; ++i) v5.push_back((i % 3 != 0) ? i : -i); double_the_difference(v5);\n    return 0;\n}"
    },
    {
        "task_id": "152",
        "entry_point": "compare",
        "stress_test": "[{\"input\": \"[[i * (-1)**i for i in range(10000)], [i * (1)**i for i in range(10000)]]\", \"output\": null}, {\"input\": \"[[i for i in range(10000)], [(-i) for i in range(10000)]]\", \"output\": null}, {\"input\": \"[[int(i/2) for i in range(10000)], [int(i/3) for i in range(10000)]]\", \"output\": null}, {\"input\": \"[[(-1)**i * (i % 100) for i in range(10000)], [(-1)**(i+1) * ((i+10) % 100) for i in range(10000)]]\", \"output\": null}, {\"input\": \"[[(-1)**i * (i % 10) for i in range(10000)], [(-1)**(i+1) * ((i+5) % 10) for i in range(10000)]]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> compare(vector<int> game,vector<int> guess){\nvector<int> out;\n    for (int i=0;i<game.size();i++)\n    out.push_back(abs(game[i]-guess[i]));\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(compare({1,2,3,4,5,1},{1,2,3,4,2,-2}),{0,0,0,0,3,3}));\n    assert (issame(compare({0,5,0,0,0,4},{4,1,1,0,0,-2}),{4,4,1,0,0,6}));\n    assert (issame(compare({1,2,3,4,5,1},{1,2,3,4,2,-2}),{0,0,0,0,3,3}));\n    assert (issame(compare({0,0,0,0,0,0},{0,0,0,0,0,0}),{0,0,0,0,0,0}));\n    assert (issame(compare({1,2,3},{-1,-2,-3}),{2,4,6}));\n    assert (issame(compare({1,2,3,5},{-1,2,3,4}),{2,0,0,1}));\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include <vector>\n#include <cmath>\nusing namespace std;\nint main(){\n    vector<int> a1, b1; for (int i = 0; i < 10000; ++i) { a1.push_back(i * ((i % 2) ? -1 : 1)); b1.push_back(i); } compare(a1, b1);\n    vector<int> a2, b2; for (int i = 0; i < 10000; ++i) { a2.push_back(i); b2.push_back(-i); } compare(a2, b2);\n    vector<int> a3, b3; for (int i = 0; i < 10000; ++i) { a3.push_back(i / 2); b3.push_back(i / 3); } compare(a3, b3);\n    vector<int> a4, b4; for (int i = 0; i < 10000; ++i) { a4.push_back(((i % 2) ? -1 : 1) * (i % 100)); b4.push_back(((i + 1) % 2 ? -1 : 1) * ((i + 10) % 100)); } compare(a4, b4);\n    vector<int> a5, b5; for (int i = 0; i < 10000; ++i) { a5.push_back(((i % 2) ? -1 : 1) * (i % 10)); b5.push_back(((i + 1) % 2 ? -1 : 1) * ((i + 5) % 10)); } compare(a5, b5);\n    return 0;\n}"
    },
    {
        "task_id": "153",
        "entry_point": "Strongest_Extension",
        "stress_test": "[{\"input\": \"['ClassF', [f'{chr(65 + (i % 26)) * (i % 100)}{chr(97 + (i % 26)) * (100 - (i % 100))}' for i in range(1000)]]\", \"output\": null}, {\"input\": \"['ClassG', [f'Ext{i}' for i in range(10000)]]\", \"output\": null}, {\"input\": \"['LongClassName', ['MmNnOoPp' * 3000, 'QqRrSsTt' * 2000, 'UuVvWwXx' * 1000]]\", \"output\": null}, {\"input\": \"['ExampleClass', ['PpQqRrSs' * 2000, 'TtUuVv' * 3333, 'WwXxYyZz' * 2500]]\", \"output\": null}, {\"input\": \"['EdgeCase', ['AaBbCc' * 1500, 'DdEeFf' * 1750, 'GgHhIi' * 2000, 'JjKkLl' * 2250]]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\nstring strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (Strongest_Extension(\"Watashi\", {\"tEN\", \"niNE\", \"eIGHt8OKe\"}) == \"Watashi.eIGHt8OKe\");\n    assert (Strongest_Extension(\"Boku123\", {\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}) == \"Boku123.YEs.WeCaNe\");\n    assert (Strongest_Extension(\"__YESIMHERE\", {\"t\", \"eMptY\", \"(nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}) == \"__YESIMHERE.NuLl__\");\n    assert (Strongest_Extension(\"K\", {\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}) == \"K.TAR\");\n    assert (Strongest_Extension(\"__HAHA\", {\"Tab\", \"123\", \"781345\", \"-_-\"}) == \"__HAHA.123\");\n    assert (Strongest_Extension(\"YameRore\", {\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}) == \"YameRore.okIWILL123\");\n    assert (Strongest_Extension(\"finNNalLLly\", {\"Die\", \"NowW\", \"Wow\", \"WoW\"}) == \"finNNalLLly.WoW\");\n    assert (Strongest_Extension(\"_\", {\"Bb\", \"91245\"}) == \"_.Bb\");\n    assert (Strongest_Extension(\"Sp\", {\"671235\", \"Bb\"}) == \"Sp.671235\");\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include <string>\n#include <vector>\nusing namespace std;\nint main(){\n    vector<string> v1; for (int i = 0; i < 1000; ++i) { string s1((i % 100), char(65 + (i % 26))); string s2((100 - (i % 100)), char(97 + (i % 26))); v1.push_back(s1 + s2); } Strongest_Extension(\"ClassF\", v1);\n    vector<string> v2; for (int i = 0; i < 10000; ++i) v2.push_back(\"Ext\" + to_string(i)); Strongest_Extension(\"ClassG\", v2);\n    vector<string> v3 = {string(8 * 3000, 'M'), string(8 * 2000, 'Q'), string(8 * 1000, 'U')}; Strongest_Extension(\"LongClassName\", v3);\n    vector<string> v4 = {string(8 * 2000, 'P'), string(6 * 3333, 'T'), string(8 * 2500, 'W')}; Strongest_Extension(\"ExampleClass\", v4);\n    vector<string> v5 = {string(6 * 1500, 'A'), string(6 * 1750, 'D'), string(6 * 2000, 'G'), string(6 * 2250, 'J')}; Strongest_Extension(\"EdgeCase\", v5);\n    return 0;\n}"
    },
    {
        "task_id": "154",
        "entry_point": "cycpattern_check",
        "stress_test": "[{\"input\": \"['qwertyuiopasdfghjklzxcvbnm' * 400, 'mnbvcxzlkjhgfdsapoiuytrewq']\", \"output\": null}, {\"input\": \"['xxxyyyzzz' * 3333 + 'xyz', 'zyxzyx']\", \"output\": null}, {\"input\": \"['hello' * 2000 + 'world', 'worldhello']\", \"output\": null}, {\"input\": \"['1234567890' * 1000, '0987654321']\", \"output\": null}, {\"input\": \"['thequickbrownfox' * 600, 'foxquick']\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nbool cycpattern_check(string a,string b){\nfor (int i=0;i<b.size();i++)\n    {\n        string rotate=b.substr(i)+b.substr(0,i);\n        if (a.find(rotate)!=string::npos) return true;\n    }\n    return false;\n\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert  (cycpattern_check(\"xyzw\",\"xyw\") == false );\n    assert  (cycpattern_check(\"yello\",\"ell\") == true );\n    assert  (cycpattern_check(\"whattup\",\"ptut\") == false );\n    assert  (cycpattern_check(\"efef\",\"fee\") == true );\n    assert  (cycpattern_check(\"abab\",\"aabb\") == false );\n    assert  (cycpattern_check(\"winemtt\",\"tinem\") == true );\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\nint main(){cycpattern_check(std::string(400,'qwertyuiopasdfghjklzxcvbnm'),\"mnbvcxzlkjhgfdsapoiuytrewq\");cycpattern_check(std::string(3333,'xxxyyyzzz')+\"xyz\",\"zyxzyx\");cycpattern_check(std::string(2000,'hello')+\"world\",\"worldhello\");cycpattern_check(std::string(1000,'1234567890'),\"0987654321\");cycpattern_check(std::string(600,'thequickbrownfox'),\"foxquick\");}"
    },
    {
        "task_id": "155",
        "entry_point": "even_odd_count",
        "stress_test": "[{\"input\": \"[-10203040506070809000]\", \"output\": null}, {\"input\": \"[10203040506070809000]\", \"output\": null}, {\"input\": \"[-13579246801357924680]\", \"output\": null}, {\"input\": \"[-98765432109876543210]\", \"output\": null}, {\"input\": \"[-11223344556677889900]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_count(long long num){\nstring w=to_string(abs(num));\n    int n1=0,n2=0;\n    for (int i=0;i<w.length();i++)\n    if (w[i]%2==1) n1+=1;\n    else n2+=1;\n    return {n2,n1};\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(even_odd_count(7) , {0, 1}));\n    assert (issame(even_odd_count(-78) , {1, 1}));\n    assert (issame(even_odd_count(3452) , {2, 2}));\n    assert (issame(even_odd_count(346211) , {3, 3}));\n    assert (issame(even_odd_count(-345821) , {3, 3}));\n    assert (issame(even_odd_count(-2) , {1, 0}));\n    assert (issame(even_odd_count(-45347) , {2, 3}));\n    assert (issame(even_odd_count(0) , {1, 0}));\n}\n",
        "cpp_stress_test": "#include <vector>\nusing namespace std;\nint main() {\n    even_odd_count(-9000000000000000000LL);\n    even_odd_count(9223372036854775807LL);\n    even_odd_count(-9223372036854775807LL);\n    even_odd_count(1357924680135792468LL);\n  return 0;\n}"
    },
    {
        "task_id": "156",
        "entry_point": "int_to_mini_roman",
        "stress_test": "[{\"input\": \"[888]\", \"output\": null}, {\"input\": \"[388]\", \"output\": null}, {\"input\": \"[333]\", \"output\": null}, {\"input\": \"[777]\", \"output\": null}, {\"input\": \"[666]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\nstring current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (int_to_mini_romank(19) == \"xix\");\n    assert (int_to_mini_romank(152) == \"clii\");\n    assert (int_to_mini_romank(251) == \"ccli\");\n    assert (int_to_mini_romank(426) == \"cdxxvi\");\n    assert (int_to_mini_romank(500) == \"d\");\n    assert (int_to_mini_romank(1) == \"i\");\n    assert (int_to_mini_romank(4) == \"iv\");\n    assert (int_to_mini_romank(43) == \"xliii\");\n    assert (int_to_mini_romank(90) == \"xc\");\n    assert (int_to_mini_romank(94) == \"xciv\");\n    assert (int_to_mini_romank(532) == \"dxxxii\");\n    assert (int_to_mini_romank(900) == \"cm\");\n    assert (int_to_mini_romank(994) == \"cmxciv\");\n    assert (int_to_mini_romank(1000) == \"m\");\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\nint main(){int_to_mini_romank(888);int_to_mini_romank(388);int_to_mini_romank(333);int_to_mini_romank(777);int_to_mini_romank(666);}"
    },
    {
        "task_id": "157",
        "entry_point": "right_angle_triangle",
        "stress_test": "[{\"input\": \"[100, 101, 141.421356237]\", \"output\": null}, {\"input\": \"[10**3, (10**3) * (2**0.5), 10**3]\", \"output\": null}, {\"input\": \"[3000, 4000, 5000]\", \"output\": null}, {\"input\": \"[50, 120, 130]\", \"output\": null}, {\"input\": \"[7500, 10000, 12500]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool right_angle_triangle(float a,float b,float c){\nif (abs(a*a+b*b-c*c)<1e-4 or abs(a*a+c*c-b*b)<1e-4 or abs(b*b+c*c-a*a)<1e-4) return true;\n    return false;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (right_angle_triangle(3, 4, 5) == true);\n    assert (right_angle_triangle(1, 2, 3) == false);\n    assert (right_angle_triangle(10, 6, 8) == true);\n    assert (right_angle_triangle(2, 2, 2) == false);\n    assert (right_angle_triangle(7, 24, 25) == true);\n    assert (right_angle_triangle(10, 5, 7) == false);\n    assert (right_angle_triangle(5, 12, 13) == true);\n    assert (right_angle_triangle(15, 8, 17) == true);\n    assert (right_angle_triangle(48, 55, 73) == true);\n    assert (right_angle_triangle(1, 1, 1) == false);\n    assert (right_angle_triangle(2, 2, 10) == false);\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\nint main(){right_angle_triangle(100, 101, 141.421356237);right_angle_triangle(1000, 1414.21356237, 1000);right_angle_triangle(3000, 4000, 5000);right_angle_triangle(50, 120, 130);right_angle_triangle(7500, 10000, 12500);}"
    },
    {
        "task_id": "158",
        "entry_point": "find_max",
        "stress_test": "[{\"input\": \"[[''.join(chr((i % 26) + 97) for i in range(1000)) for _ in range(30)]]\", \"output\": null}, {\"input\": \"[['aa' * 2500, 'bb' * 2500, 'cc' * 2500, 'dd' * 2500, 'ee' * 2500]]\", \"output\": null}, {\"input\": \"[['x' * 4000, 'xy' * 2000, 'xyz' * 1333, 'xyza' * 1000]]\", \"output\": null}, {\"input\": \"[['a' * 5000, 'b' * 5000, 'ab' * 2500]]\", \"output\": null}, {\"input\": \"[['abcdefg' * 1000, 'gfedcba' * 1000, 'abcdabcdabcdabcd']]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\nstring max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert ((find_max({\"name\", \"of\", \"string\"}) == \"string\"));\n    assert ((find_max({\"name\", \"enam\", \"game\"}) == \"enam\"));\n    assert ((find_max({\"aaaaaaa\", \"bb\", \"cc\"}) == \"aaaaaaa\"));\n    assert ((find_max({\"abc\", \"cba\"}) == \"abc\"));\n    assert ((find_max({\"play\", \"this\", \"game\", \"of\",\"footbott\"}) == \"footbott\"));\n    assert ((find_max({\"we\", \"are\", \"gonna\", \"rock\"}) == \"gonna\"));\n    assert ((find_max({\"we\", \"are\", \"a\", \"mad\", \"nation\"}) == \"nation\"));\n    assert ((find_max({\"this\", \"is\", \"a\", \"prrk\"}) == \"this\"));\n    assert ((find_max({\"b\"}) == \"b\"));\n    assert ((find_max({\"play\", \"play\", \"play\"}) == \"play\"));\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include <string>\n#include <vector>\n#include <numeric>\nusing namespace std;\nint main(){\n    string repeated;\n    for (int i = 0; i < 1000; ++i) repeated += char((i % 26) + 'a');\n    vector<string> v1(30, repeated); find_max(v1);\n    find_max({string(2500, 'a') + string(2500, 'a'), string(2500, 'b') + string(2500, 'b'), string(2500, 'c') + string(2500, 'c'), string(2500, 'd') + string(2500, 'd'), string(2500, 'e') + string(2500, 'e')});\n    find_max({string(4000, 'x'), string(2000, 'x') + string(2000, 'y'), string(1333, 'x') + string(1333, 'y') + string(1334, 'z'), string(1000, 'x') + string(1000, 'y') + string(1000, 'z') + string(1000, 'a')});\n    find_max({string(5000, 'a'), string(5000, 'b'), string(2500, 'a') + string(2500, 'b')});\n    find_max({string(1000, 'a') + string(1000, 'b') + string(1000, 'c') + string(1000, 'd') + string(1000, 'e') + string(1000, 'f') + string(1000, 'g'), string(1000, 'g') + string(1000, 'f') + string(1000, 'e') + string(1000, 'd') + string(1000, 'c') + string(1000, 'b') + string(1000, 'a'), \"abcdabcdabcdabcd\"});\n    return 0;\n}"
    },
    {
        "task_id": "159",
        "entry_point": "eat",
        "stress_test": "[{\"input\": \"[999, 1, 1000]\", \"output\": null}, {\"input\": \"[789, 210, 987]\", \"output\": null}, {\"input\": \"[500, 500, 1000]\", \"output\": null}, {\"input\": \"[1000, 0, 1000]\", \"output\": null}, {\"input\": \"[0, 999, 1000]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> eat(int number,int need,int remaining){\nif (need>remaining) return {number+remaining, 0};\n    return {number+need,remaining-need};\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(eat(5, 6, 10) , {11, 4}));\n    assert (issame(eat(4, 8, 9) , {12, 1}));\n    assert (issame(eat(1, 10, 10) , {11, 0}));\n    assert (issame(eat(2, 11, 5) , {7, 0}));\n    \n    assert (issame(eat(4, 5, 7) , {9, 2}));\n    assert (issame(eat(4, 5, 1) , {5, 0}));\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\n#include<vector>\nusing namespace std;\nbool issame(vector<int> a,vector<int>b){if (a.size()!=b.size()) return false;for (int i=0;i<a.size();i++){if (a[i]!=b[i]) return false;}return true;}\nint main(){issame(eat(999, 1, 1000) , {});issame(eat(789, 210, 987) , {});issame(eat(500, 500, 1000) , {});issame(eat(1000, 0, 1000) , {});issame(eat(0, 999, 1000) , {});}"
    },
    {
        "task_id": "160",
        "entry_point": "do_algebra",
        "stress_test": "[{\"input\": \"[['-']*5000 + ['+']*5000, [i for i in range(1, 10002)]]\", \"output\": null}, {\"input\": \"[['+']*9999, [1]*10000]\", \"output\": null}, {\"input\": \"[['+']*1000, list(range(1, 1002))]\", \"output\": null}, {\"input\": \"[['*']*1000, [2]*1001]\", \"output\": null}, {\"input\": \"[['*', '+', '-', '**', '//'], [123, 456, 789, 1011, 1213, 1415]]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint do_algebra(vector<string> operato, vector<int> operand){\nvector<int> num={};\n    vector<int> posto={};\n    for (int i=0;i<operand.size();i++)\n        posto.push_back(i);\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"**\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        operand[posto[i]]=pow(operand[posto[i]],operand[posto[i+1]]);\n        posto[i+1]=posto[i];\n        }\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"*\" or operato[i]==\"//\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        if (operato[i]==\"*\")\n            operand[posto[i]]=operand[posto[i]]*operand[posto[i+1]];\n        else\n            operand[posto[i]]=operand[posto[i]]/operand[posto[i+1]];\n        posto[i+1]=posto[i];\n        }\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"+\" or operato[i]==\"-\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        if (operato[i]==\"+\")\n            operand[posto[i]]=operand[posto[i]]+operand[posto[i+1]];\n        else\n            operand[posto[i]]=operand[posto[i]]-operand[posto[i+1]];\n        posto[i+1]=posto[i];\n        }\n    return operand[0];\n\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (do_algebra({\"**\", \"*\", \"+\"}, {2, 3, 4, 5}) == 37);\n    assert (do_algebra({\"+\", \"*\", \"-\"}, {2, 3, 4, 5}) == 9);\n    assert (do_algebra({\"//\", \"*\"}, {7, 3, 4}) == 8);\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include <assert.h>\n#include <vector>\n#include <string>\n#include <numeric>\nusing namespace std;\nint main(){\n    vector<string> ops1(5000, \"-\"); ops1.insert(ops1.end(), 5000, \"+\"); vector<int> vals1(10001); iota(vals1.begin(), vals1.end(), 1); do_algebra(ops1, vals1);\n    vector<string> ops2(9999, \"+\"); vector<int> vals2(10000, 1); do_algebra(ops2, vals2);\n    vector<string> ops3(1000, \"+\"); vector<int> vals3(1002); iota(vals3.begin(), vals3.end(), 1); do_algebra(ops3, vals3);\n    vector<string> ops4(1000, \"*\"); vector<int> vals4(1001, 2); do_algebra(ops4, vals4);\n    vector<string> ops5 = {\"*\", \"+\", \"-\", \"**\", \"//\"}; vector<int> vals5 = {123, 456, 789, 1011, 1213, 1415}; do_algebra(ops5, vals5);\n    return 0;\n}"
    },
    {
        "task_id": "161",
        "entry_point": "solve",
        "stress_test": "[{\"input\": \"['a' * 10000 + 'B' * 10000]\", \"output\": null}, {\"input\": \"['abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' * 200]\", \"output\": null}, {\"input\": \"[''.join([chr(65 + (i % 26)) if i % 2 == 0 else chr(97 + (i % 26)) for i in range(10000)])]\", \"output\": null}, {\"input\": \"['A' * 9999 + 'a']\", \"output\": null}, {\"input\": \"[''.join(chr((i % 26) + 65) for i in range(10000))]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\nint nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (solve(\"AsDf\") == \"aSdF\");\n    assert (solve(\"1234\") == \"4321\");\n    assert (solve(\"ab\") == \"AB\");\n    assert (solve(\"#a@C\") == \"#A@c\");\n    assert (solve(\"#AsdfW^45\") == \"#aSDFw^45\");\n    assert (solve(\"#6@2\") == \"2@6#\");\n    assert (solve(\"#$a^D\") == \"#$A^d\");\n    assert (solve(\"#ccc\") == \"#CCC\");\n}\n",
        "cpp_stress_test": "\n#undef NDEBUG\n#include<assert.h>\nint main() {\n    solve(std::string(10000, 'a') + std::string(10000, 'B'));\n    solve(std::string(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\").append(200, 'x').substr(0, 5200));\n    solve([]{ std::string res; for (int i = 0; i < 10000; ++i) res += (i % 2 == 0) ? char(65 + (i % 26)) : char(97 + (i % 26)); return res; }());\n    solve(std::string(9999, 'A') + 'a');\n    solve([]{ std::string res; for (int i = 0; i < 10000; ++i) res += char((i % 26) + 65); return res; }());\n}"
    },
    {
        "task_id": "162",
        "entry_point": "string_to_md5",
        "stress_test": "[{\"input\": \"['\\\\n'.join(['line'] * 9999)]\", \"output\": null}, {\"input\": \"['This is a test string.' * 500]\", \"output\": null}, {\"input\": \"['\\\\t'.join(['tabbed'] * 1500)]\", \"output\": null}, {\"input\": \"['longstring' * 999]\", \"output\": null}, {\"input\": \"['1234567890' * 999]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_to_md5(string text){\nunsigned char md[16];\n    if (text.length()==0) return \"None\";\n    MD5_CTX c;\n    int i;\n   MD5_Init(&c);\n   MD5_Update(&c, (unsigned char*)text.c_str(), text.length());\n    MD5_Final(md, &c);\n    string out_str=\"\";\n    for (int i=0;i<16;i++)\n        {\n            char w;\n            if (md[i]<160) w=48+md[i]/16;\n            else w=87+md[i]/16;\n            out_str=out_str+w;\n            if (md[i]%16<10) w=48+md[i]%16;\n            else w=87+md[i]%16;\n            out_str=out_str+w;\n        }\n    return out_str;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (string_to_md5(\"Hello world\") == \"3e25960a79dbc69b674cd4ec67a72c62\");\n    assert (string_to_md5(\"\") == \"None\");\n    assert (string_to_md5(\"A B C\") == \"0ef78513b0cb8cef12743f5aeb35f888\");\n    assert (string_to_md5(\"password\") == \"5f4dcc3b5aa765d61d8327deb882cf99\");\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include <assert.h>\n#include <string>\n#include <iostream>\nusing namespace std;\nint main(){\n    string test1;\n    for (int i = 0; i < 9999; ++i) test1 += \"line\\n\";\n    string test2;\n    for (int i = 0; i < 500; ++i) test2 += \"This is a test string.\";\n    string test3;\n    for (int i = 0; i < 1500; ++i) test3 += \"tabbed\\t\";\n    string test4;\n    for (int i = 0; i < 999; ++i) test4 += \"longstring\";\n    string test5;\n    for (int i = 0; i < 999; ++i) test5 += \"1234567890\";\n    string_to_md5(test1);\n    string_to_md5(test2);\n    string_to_md5(test3);\n    string_to_md5(test4);\n    string_to_md5(test5);\n    return 0;\n}"
    },
    {
        "task_id": "163",
        "entry_point": "generate_integers",
        "stress_test": "[{\"input\": \"[1, 9998]\", \"output\": null}, {\"input\": \"[1, 10000]\", \"output\": null}, {\"input\": \"[10000, 1]\", \"output\": null}, {\"input\": \"[9998, 1]\", \"output\": null}, {\"input\": \"[9999, 1]\", \"output\": null}]",
        "function_code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> generate_integers(int a,int b){\nint m;\n    if (b<a)\n    {\n        m=a;a=b;b=m;\n    }\n\n    vector<int> out={};\n    for (int i=a;i<=b;i++)\n    if (i<10 and i%2==0) out.push_back(i);\n    return out;\n}",
        "test_code": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(generate_integers(2, 10) , {2, 4, 6, 8}));\n    assert (issame(generate_integers(10, 2) , {2, 4, 6, 8}));\n    assert (issame(generate_integers(132, 2) , {2, 4, 6, 8}));\n    assert (issame(generate_integers(17,89) , {}));\n}\n",
        "cpp_stress_test": "#undef NDEBUG\n#include<assert.h>\n#include<vector>\nusing namespace std;\nbool issame(vector<int> a,vector<int>b){if (a.size()!=b.size()) return false;for (int i=0;i<a.size();i++){if (a[i]!=b[i]) return false;}return true;}\nint main(){issame(generate_integers(1, 9998), {});issame(generate_integers(1, 10000), {});issame(generate_integers(10000, 1), {});issame(generate_integers(9998, 1), {});issame(generate_integers(9999, 1), {});}"
    }
]