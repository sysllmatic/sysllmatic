{
    "0": [
        "package edu.cmu.graphchi;\n\nimport edu.cmu.graphchi.datablocks.BytesToValueConverter;\nimport edu.cmu.graphchi.datablocks.ChiPointer;\nimport edu.cmu.graphchi.datablocks.DataBlockManager;\nimport edu.cmu.graphchi.engine.auxdata.VertexDegree;\nimport sun.misc.Unsafe;\nimport sun.reflect.generics.reflectiveObjects.NotImplementedException;\n\nimport java.lang.reflect.Field;\nimport java.security.AccessController;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n\n\n\npublic class ChiVertex<VertexValue, EdgeValue> {\n\n    \n    private int id;\n    public static DataBlockManager blockManager;\n    public static BytesToValueConverter vertexValueConverter;\n    public static BytesToValueConverter edgeValueConverter;\n    public static boolean disableInedges = false;\n    public static boolean disableOutedges = false;\n\n    private volatile int nInedges = 0;\n    private int[] inEdgeDataArray = null;\n\n    private volatile int nOutedges = 0;\n    private int[] outEdgeDataArray = null;\n\n    \n    public boolean parallelSafe = true;\n\n    \n\n    @SuppressWarnings(\"restriction\")\n    \n    private static Unsafe getUnsafe() {\n        try {\n\n            Field singleoneInstanceField = Unsafe.class.getDeclaredField(\"theUnsafe\");\n            singleoneInstanceField.setAccessible(true);\n            return (Unsafe) singleoneInstanceField.get(null);\n\n        } catch (IllegalArgumentException e) {\n            throw e;\n        } catch (SecurityException e) {\n            throw e;\n        } catch (NoSuchFieldException e) {\n            throw new RuntimeException(e);\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private static final Unsafe unsafe = getUnsafe();\n    private static final long valueOffset_nInedges;\n    private static final long valueOffset_nOutedges;\n\n    static {\n        try {\n            valueOffset_nInedges = unsafe.objectFieldOffset\n                    (ChiVertex.class.getDeclaredField(\"nInedges\"));\n            valueOffset_nOutedges = unsafe.objectFieldOffset\n                    (ChiVertex.class.getDeclaredField(\"nOutedges\"));\n        } catch (Exception ex) { throw new Error(ex); }\n    }\n\n    private ChiPointer vertexPtr;\n\n    public ChiVertex(int id, VertexDegree degree) {\n        this.id = id;\n\n        if (degree != null) {\n            if (!disableInedges) {\n                inEdgeDataArray = new int[degree.inDegree * (edgeValueConverter != null ? 3 : 1)];\n            } else {\n                nInedges =  degree.inDegree;\n            }\n            if (!disableOutedges) {\n                outEdgeDataArray = new int[degree.outDegree * (edgeValueConverter != null ? 3 : 1)];\n            } else {\n                nOutedges = degree.outDegree;\n            }\n        }\n    }\n\n\n    public int getId() {\n        return this.id;\n    }\n\n    public void setDataPtr(ChiPointer vertexPtr) {\n        this.vertexPtr = vertexPtr;\n    }\n\n\n    \n    public VertexValue getValue() {\n        return blockManager.dereference(vertexPtr, (BytesToValueConverter<VertexValue>)\n                vertexValueConverter);\n    }\n\n    \n    public void setValue(VertexValue x) {\n        blockManager.writeValue(vertexPtr, vertexValueConverter, x);\n    }\n\n\n    \n    public int getRandomOutNeighbor() {\n        int i = (int) (Math.random() * numOutEdges());\n        if (edgeValueConverter != null) {\n            int idx = i * 3;\n            return outEdgeDataArray[idx + 2];\n        } else {\n            return outEdgeDataArray[i];\n        }\n    }\n\n    \n    public int getRandomNeighbor() {\n        if (numEdges() == 0) {\n            return -1;\n        }\n        int i = (int) (Math.random() * numEdges());\n        return edge(i).getVertexId();\n    }\n\n\n\n    public int numOutEdges() {\n        return nOutedges;\n    }\n\n\n    public int numInEdges() {\n        return nInedges;\n    }\n\n    \n    public void addInEdge(int chunkId, int offset, int vertexId) {\n        int tmpInEdges;\n        \n        for (;;) {\n            int current = nInedges;\n            tmpInEdges = current + 1;\n            if (unsafe.compareAndSwapInt(this, valueOffset_nInedges, current, tmpInEdges)) {\n                break;\n            }\n        }\n\n        tmpInEdges--;\n        if (edgeValueConverter != null) {\n            int idx = tmpInEdges * 3;\n            inEdgeDataArray[idx] = chunkId;\n            inEdgeDataArray[idx + 1] = offset;\n            inEdgeDataArray[idx + 2] = vertexId;\n        } else {\n            if (inEdgeDataArray != null)\n                inEdgeDataArray[tmpInEdges] = vertexId;\n        }\n    }\n\n\n    \n    public void addOutEdge(int chunkId, int offset,  int vertexId) {\n        int tmpOutEdges;\n        \n        for (;;) {\n            int current = nOutedges;\n            tmpOutEdges = current + 1;\n            if (unsafe.compareAndSwapInt(this, valueOffset_nOutedges, current, tmpOutEdges)) {\n                break;\n            }\n        }\n        tmpOutEdges--;\n        if (edgeValueConverter != null) {\n            int idx = tmpOutEdges * 3;\n            outEdgeDataArray[idx] = chunkId;\n            outEdgeDataArray[idx + 1] = offset;\n            outEdgeDataArray[idx + 2] = vertexId;\n        } else {\n            if (outEdgeDataArray != null)\n                outEdgeDataArray[tmpOutEdges] = vertexId;\n        }\n    }\n\n    \n    public ChiEdge<EdgeValue> inEdge(int i) {\n        if (edgeValueConverter != null) {\n            int idx = i * 3;\n            return new Edge(new ChiPointer(inEdgeDataArray[idx], inEdgeDataArray[idx + 1]), inEdgeDataArray[idx + 2]);\n        } else {\n            return new Edge(null, inEdgeDataArray[i]);\n        }\n    }\n\n    \n    public ChiEdge<EdgeValue>  outEdge(int i) {\n        if (edgeValueConverter != null) {\n            int idx = i * 3;\n            return new Edge(new ChiPointer(outEdgeDataArray[idx], outEdgeDataArray[idx + 1]), outEdgeDataArray[idx + 2]);\n        } else {\n            return new Edge(null, outEdgeDataArray[i]);\n        }\n    }\n\n    \n    public int getOutEdgeId(int i) {\n        if (edgeValueConverter != null) {\n            int idx = i * 3;\n            return outEdgeDataArray[idx + 2];\n        } else {\n            return outEdgeDataArray[i];\n        }\n    }\n\n    \n    public ChiEdge<EdgeValue> edge(int i) {\n        if (i < nInedges) return inEdge(i);\n        else return outEdge(i - nInedges);\n    }\n\n    \n    public int numEdges() {\n        return nInedges + nOutedges;\n    }\n\n    \n    public int[] getOutNeighborArray() {\n        if (edgeValueConverter != null) {\n            int[] nbrs = new int[numOutEdges()];\n            for(int i=0; i<nbrs.length; i++) {\n                nbrs[i] = outEdgeDataArray[(i * 3) + 2];\n            }\n            return nbrs;\n        } else {\n            return outEdgeDataArray.clone();\n        }\n    }\n\n    \n    public EdgeValue getOutEdgeValue(int i) {\n        int idx = i * 3;\n        return blockManager.dereference(new ChiPointer(outEdgeDataArray[idx], outEdgeDataArray[idx + 1]),\n                (BytesToValueConverter<EdgeValue>) edgeValueConverter);\n    }\n\n\n\n\n    class Edge implements ChiEdge<EdgeValue> {\n        Edge(ChiPointer dataPtr, int vertexId) {\n            this.dataPtr = dataPtr;\n            this.vertexId = vertexId;\n        }\n\n        ChiPointer dataPtr;\n        int vertexId;\n\n        public int getVertexId() {\n            return  vertexId;\n        }\n\n\n        public EdgeValue getValue() {\n            return blockManager.dereference(dataPtr, (BytesToValueConverter<EdgeValue>) edgeValueConverter);\n        }\n\n        public void setValue(EdgeValue x) {\n            blockManager.writeValue(dataPtr, edgeValueConverter, x);\n        }\n    }\n\n}\n"
    ],
    "1": [
        "package edu.cmu.graphchi;\n\nimport edu.cmu.graphchi.datablocks.BytesToValueConverter;\nimport edu.cmu.graphchi.datablocks.ChiPointer;\nimport edu.cmu.graphchi.datablocks.DataBlockManager;\nimport edu.cmu.graphchi.engine.auxdata.VertexDegree;\nimport sun.misc.Unsafe;\nimport java.lang.reflect.Field;\nimport java.util.concurrent.ThreadLocalRandom;\n\npublic class ChiVertex<VertexValue, EdgeValue> {\n    private int id;\n    public static DataBlockManager blockManager;\n    public static BytesToValueConverter vertexValueConverter;\n    public static BytesToValueConverter edgeValueConverter;\n    public static boolean disableInedges = false;\n    public static boolean disableOutedges = false;\n\n    private volatile int nInedges = 0;\n    private int[] inEdgeDataArray = null;\n\n    private volatile int nOutedges = 0;\n    private int[] outEdgeDataArray = null;\n\n    public boolean parallelSafe = true;\n\n    private static Unsafe getUnsafe() {\n        try {\n            Field singleoneInstanceField = Unsafe.class.getDeclaredField(\"theUnsafe\");\n            singleoneInstanceField.setAccessible(true);\n            return (Unsafe) singleoneInstanceField.get(null);\n        } catch (IllegalArgumentException e) {\n            throw e;\n        } catch (SecurityException e) {\n            throw e;\n        } catch (NoSuchFieldException e) {\n            throw new RuntimeException(e);\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private static final Unsafe unsafe = getUnsafe();\n    private static final long valueOffset_nInedges;\n    private static final long valueOffset_nOutedges;\n\n    static {\n        try {\n            valueOffset_nInedges = unsafe.objectFieldOffset\n                    (ChiVertex.class.getDeclaredField(\"nInedges\"));\n            valueOffset_nOutedges = unsafe.objectFieldOffset\n                    (ChiVertex.class.getDeclaredField(\"nOutedges\"));\n        } catch (Exception ex) { throw new Error(ex); }\n    }\n\n    private ChiPointer vertexPtr;\n\n    public ChiVertex(int id, VertexDegree degree) {\n        this.id = id;\n        boolean hasEdgeValConv = (edgeValueConverter != null);\n        if (degree != null) {\n            if (!disableInedges) {\n                inEdgeDataArray = new int[degree.inDegree * (hasEdgeValConv ? 3 : 1)];\n            } else {\n                nInedges =  degree.inDegree;\n            }\n            if (!disableOutedges) {\n                outEdgeDataArray = new int[degree.outDegree * (hasEdgeValConv ? 3 : 1)];\n            } else {\n                nOutedges = degree.outDegree;\n            }\n        }\n    }\n\n    public int getId() {\n        return this.id;\n    }\n\n    public void setDataPtr(ChiPointer vertexPtr) {\n        this.vertexPtr = vertexPtr;\n    }\n\n    public VertexValue getValue() {\n        return blockManager.dereference(vertexPtr, (BytesToValueConverter<VertexValue>) vertexValueConverter);\n    }\n\n    public void setValue(VertexValue x) {\n        blockManager.writeValue(vertexPtr, vertexValueConverter, x);\n    }\n\n    public int getRandomOutNeighbor() {\n        int n = numOutEdges();\n        if (n == 0) return -1;\n        int i = ThreadLocalRandom.current().nextInt(n);\n        boolean hasEdgeValConv = (edgeValueConverter != null);\n        if (hasEdgeValConv) {\n            int idx = i * 3;\n            return outEdgeDataArray[idx + 2];\n        } else {\n            return outEdgeDataArray[i];\n        }\n    }\n\n    public int getRandomNeighbor() {\n        int totalEdges = numEdges();\n        if (totalEdges == 0) {\n            return -1;\n        }\n        int i = ThreadLocalRandom.current().nextInt(totalEdges);\n        return edge(i).getVertexId();\n    }\n\n    public int numOutEdges() {\n        return nOutedges;\n    }\n\n    public int numInEdges() {\n        return nInedges;\n    }\n\n    public void addInEdge(int chunkId, int offset, int vertexId) {\n        int tmpInEdges;\n        for (;;) {\n            int current = nInedges;\n            tmpInEdges = current + 1;\n            if (unsafe.compareAndSwapInt(this, valueOffset_nInedges, current, tmpInEdges)) {\n                break;\n            }\n        }\n        tmpInEdges--;\n        boolean hasEdgeValConv = (edgeValueConverter != null);\n        if (hasEdgeValConv) {\n            int idx = tmpInEdges * 3;\n            inEdgeDataArray[idx] = chunkId;\n            inEdgeDataArray[idx + 1] = offset;\n            inEdgeDataArray[idx + 2] = vertexId;\n        } else {\n            if (inEdgeDataArray != null)\n                inEdgeDataArray[tmpInEdges] = vertexId;\n        }\n    }\n\n    public void addOutEdge(int chunkId, int offset,  int vertexId) {\n        int tmpOutEdges;\n        for (;;) {\n            int current = nOutedges;\n            tmpOutEdges = current + 1;\n            if (unsafe.compareAndSwapInt(this, valueOffset_nOutedges, current, tmpOutEdges)) {\n                break;\n            }\n        }\n        tmpOutEdges--;\n        boolean hasEdgeValConv = (edgeValueConverter != null);\n        if (hasEdgeValConv) {\n            int idx = tmpOutEdges * 3;\n            outEdgeDataArray[idx] = chunkId;\n            outEdgeDataArray[idx + 1] = offset;\n            outEdgeDataArray[idx + 2] = vertexId;\n        } else {\n            if (outEdgeDataArray != null)\n                outEdgeDataArray[tmpOutEdges] = vertexId;\n        }\n    }\n\n    public ChiEdge<EdgeValue> inEdge(int i) {\n        boolean hasEdgeValConv = (edgeValueConverter != null);\n        if (hasEdgeValConv) {\n            int idx = i * 3;\n            return new Edge(new ChiPointer(inEdgeDataArray[idx], inEdgeDataArray[idx + 1]), inEdgeDataArray[idx + 2]);\n        } else {\n            return new Edge(null, inEdgeDataArray[i]);\n        }\n    }\n\n    public ChiEdge<EdgeValue> outEdge(int i) {\n        boolean hasEdgeValConv = (edgeValueConverter != null);\n        if (hasEdgeValConv) {\n            int idx = i * 3;\n            return new Edge(new ChiPointer(outEdgeDataArray[idx], outEdgeDataArray[idx + 1]), outEdgeDataArray[idx + 2]);\n        } else {\n            return new Edge(null, outEdgeDataArray[i]);\n        }\n    }\n\n    public int getOutEdgeId(int i) {\n        boolean hasEdgeValConv = (edgeValueConverter != null);\n        if (hasEdgeValConv) {\n            int idx = i * 3;\n            return outEdgeDataArray[idx + 2];\n        } else {\n            return outEdgeDataArray[i];\n        }\n    }\n\n    public ChiEdge<EdgeValue> edge(int i) {\n        if (i < nInedges) return inEdge(i);\n        else return outEdge(i - nInedges);\n    }\n\n    public int numEdges() {\n        return nInedges + nOutedges;\n    }\n\n    public int[] getOutNeighborArray() {\n        boolean hasEdgeValConv = (edgeValueConverter != null);\n        if (hasEdgeValConv) {\n            int n = numOutEdges();\n            int[] nbrs = new int[n];\n            for(int i = 0, j = 2; i < n; i++, j += 3) {\n                nbrs[i] = outEdgeDataArray[j];\n            }\n            return nbrs;\n        } else {\n            int n = numOutEdges();\n            int[] result = new int[n];\n            System.arraycopy(outEdgeDataArray, 0, result, 0, n);\n            return result;\n        }\n    }\n\n    public EdgeValue getOutEdgeValue(int i) {\n        int idx = i * 3;\n        return blockManager.dereference(new ChiPointer(outEdgeDataArray[idx], outEdgeDataArray[idx + 1]),\n                (BytesToValueConverter<EdgeValue>) edgeValueConverter);\n    }\n\n    class Edge implements ChiEdge<EdgeValue> {\n        Edge(ChiPointer dataPtr, int vertexId) {\n            this.dataPtr = dataPtr;\n            this.vertexId = vertexId;\n        }\n\n        ChiPointer dataPtr;\n        int vertexId;\n\n        public int getVertexId() {\n            return  vertexId;\n        }\n\n        public EdgeValue getValue() {\n            return blockManager.dereference(dataPtr, (BytesToValueConverter<EdgeValue>) edgeValueConverter);\n        }\n\n        public void setValue(EdgeValue x) {\n            blockManager.writeValue(dataPtr, edgeValueConverter, x);\n        }\n    }\n}\n"
    ],
    "2": [
        "package edu.cmu.graphchi;\n\nimport edu.cmu.graphchi.datablocks.BytesToValueConverter;\nimport edu.cmu.graphchi.datablocks.ChiPointer;\nimport edu.cmu.graphchi.datablocks.DataBlockManager;\nimport edu.cmu.graphchi.engine.auxdata.VertexDegree;\nimport sun.misc.Unsafe;\nimport java.lang.reflect.Field;\nimport java.util.Arrays;\nimport java.util.concurrent.ThreadLocalRandom;\n\npublic class ChiVertex<VertexValue, EdgeValue> {\n    private int id;\n    public static DataBlockManager blockManager;\n    public static BytesToValueConverter vertexValueConverter;\n    public static BytesToValueConverter edgeValueConverter;\n    public static boolean disableInedges = false;\n    public static boolean disableOutedges = false;\n\n    private volatile int nInedges = 0;\n    private int[] inEdgeDataArray = null;\n\n    private volatile int nOutedges = 0;\n    private int[] outEdgeDataArray = null;\n\n    public boolean parallelSafe = true;\n\n    private static Unsafe getUnsafe() {\n        try {\n            Field singleoneInstanceField = Unsafe.class.getDeclaredField(\"theUnsafe\");\n            singleoneInstanceField.setAccessible(true);\n            return (Unsafe) singleoneInstanceField.get(null);\n        } catch (IllegalArgumentException e) {\n            throw e;\n        } catch (SecurityException e) {\n            throw e;\n        } catch (NoSuchFieldException e) {\n            throw new RuntimeException(e);\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private static final Unsafe unsafe = getUnsafe();\n    private static final long valueOffset_nInedges;\n    private static final long valueOffset_nOutedges;\n\n    static {\n        try {\n            valueOffset_nInedges = unsafe.objectFieldOffset(ChiVertex.class.getDeclaredField(\"nInedges\"));\n            valueOffset_nOutedges = unsafe.objectFieldOffset(ChiVertex.class.getDeclaredField(\"nOutedges\"));\n        } catch (Exception ex) { throw new Error(ex); }\n    }\n\n    private ChiPointer vertexPtr;\n\n    public ChiVertex(int id, VertexDegree degree) {\n        this.id = id;\n        boolean hasEdgeValConv = (edgeValueConverter != null);\n        if (degree != null) {\n            if (!disableInedges) {\n                inEdgeDataArray = new int[Math.max(1, degree.inDegree * (hasEdgeValConv ? 3 : 1))];\n            } else {\n                nInedges =  degree.inDegree;\n            }\n            if (!disableOutedges) {\n                outEdgeDataArray = new int[Math.max(1, degree.outDegree * (hasEdgeValConv ? 3 : 1))];\n            } else {\n                nOutedges = degree.outDegree;\n            }\n        }\n    }\n\n    private void ensureInEdgeCapacity(int minCapacity) {\n        if (inEdgeDataArray == null || inEdgeDataArray.length < minCapacity) {\n            int newCapacity = Math.max(minCapacity, (inEdgeDataArray == null ? 8 : inEdgeDataArray.length * 2));\n            inEdgeDataArray = Arrays.copyOf(inEdgeDataArray == null ? new int[0] : inEdgeDataArray, newCapacity);\n        }\n    }\n\n    private void ensureOutEdgeCapacity(int minCapacity) {\n        if (outEdgeDataArray == null || outEdgeDataArray.length < minCapacity) {\n            int newCapacity = Math.max(minCapacity, (outEdgeDataArray == null ? 8 : outEdgeDataArray.length * 2));\n            outEdgeDataArray = Arrays.copyOf(outEdgeDataArray == null ? new int[0] : outEdgeDataArray, newCapacity);\n        }\n    }\n\n    public int getId() {\n        return this.id;\n    }\n\n    public void setDataPtr(ChiPointer vertexPtr) {\n        this.vertexPtr = vertexPtr;\n    }\n\n    public VertexValue getValue() {\n        return blockManager.dereference(vertexPtr, (BytesToValueConverter<VertexValue>) vertexValueConverter);\n    }\n\n    public void setValue(VertexValue x) {\n        blockManager.writeValue(vertexPtr, vertexValueConverter, x);\n    }\n\n    private static int getEdgeVertexId(int[] arr, int i, boolean hasEdgeValConv) {\n        return hasEdgeValConv ? arr[i * 3 + 2] : arr[i];\n    }\n\n    public int getRandomOutNeighbor() {\n        int n = numOutEdges();\n        if (n == 0) return -1;\n        int i = ThreadLocalRandom.current().nextInt(n);\n        boolean hasEdgeValConv = (edgeValueConverter != null);\n        return getEdgeVertexId(outEdgeDataArray, i, hasEdgeValConv);\n    }\n\n    public int getRandomNeighbor() {\n        int totalEdges = numEdges();\n        if (totalEdges == 0) {\n            return -1;\n        }\n        int i = ThreadLocalRandom.current().nextInt(totalEdges);\n        return edge(i).getVertexId();\n    }\n\n    public int numOutEdges() {\n        return nOutedges;\n    }\n\n    public int numInEdges() {\n        return nInedges;\n    }\n\n    public void addInEdge(int chunkId, int offset, int vertexId) {\n        boolean hasEdgeValConv = (edgeValueConverter != null);\n        int edgeWidth = hasEdgeValConv ? 3 : 1;\n        int tmpInEdges;\n        for (;;) {\n            int current = nInedges;\n            tmpInEdges = current + 1;\n            if (unsafe.compareAndSwapInt(this, valueOffset_nInedges, current, tmpInEdges)) {\n                break;\n            }\n        }\n        tmpInEdges--;\n        int minCapacity = (tmpInEdges + 1) * edgeWidth;\n        ensureInEdgeCapacity(minCapacity);\n        if (hasEdgeValConv) {\n            int idx = tmpInEdges * 3;\n            inEdgeDataArray[idx] = chunkId;\n            inEdgeDataArray[idx + 1] = offset;\n            inEdgeDataArray[idx + 2] = vertexId;\n        } else {\n            inEdgeDataArray[tmpInEdges] = vertexId;\n        }\n    }\n\n    public void addOutEdge(int chunkId, int offset, int vertexId) {\n        boolean hasEdgeValConv = (edgeValueConverter != null);\n        int edgeWidth = hasEdgeValConv ? 3 : 1;\n        int tmpOutEdges;\n        for (;;) {\n            int current = nOutedges;\n            tmpOutEdges = current + 1;\n            if (unsafe.compareAndSwapInt(this, valueOffset_nOutedges, current, tmpOutEdges)) {\n                break;\n            }\n        }\n        tmpOutEdges--;\n        int minCapacity = (tmpOutEdges + 1) * edgeWidth;\n        ensureOutEdgeCapacity(minCapacity);\n        if (hasEdgeValConv) {\n            int idx = tmpOutEdges * 3;\n            outEdgeDataArray[idx] = chunkId;\n            outEdgeDataArray[idx + 1] = offset;\n            outEdgeDataArray[idx + 2] = vertexId;\n        } else {\n            outEdgeDataArray[tmpOutEdges] = vertexId;\n        }\n    }\n\n    public ChiEdge<EdgeValue> inEdge(int i) {\n        boolean hasEdgeValConv = (edgeValueConverter != null);\n        if (hasEdgeValConv) {\n            int idx = i * 3;\n            return new Edge(new ChiPointer(inEdgeDataArray[idx], inEdgeDataArray[idx + 1]), inEdgeDataArray[idx + 2]);\n        } else {\n            return new Edge(null, inEdgeDataArray[i]);\n        }\n    }\n\n    public ChiEdge<EdgeValue> outEdge(int i) {\n        boolean hasEdgeValConv = (edgeValueConverter != null);\n        if (hasEdgeValConv) {\n            int idx = i * 3;\n            return new Edge(new ChiPointer(outEdgeDataArray[idx], outEdgeDataArray[idx + 1]), outEdgeDataArray[idx + 2]);\n        } else {\n            return new Edge(null, outEdgeDataArray[i]);\n        }\n    }\n\n    public int getOutEdgeId(int i) {\n        boolean hasEdgeValConv = (edgeValueConverter != null);\n        return getEdgeVertexId(outEdgeDataArray, i, hasEdgeValConv);\n    }\n\n    public ChiEdge<EdgeValue> edge(int i) {\n        if (i < nInedges) return inEdge(i);\n        else return outEdge(i - nInedges);\n    }\n\n    public int numEdges() {\n        return nInedges + nOutedges;\n    }\n\n    public int[] getOutNeighborArray() {\n        boolean hasEdgeValConv = (edgeValueConverter != null);\n        int n = numOutEdges();\n        int[] nbrs = new int[n];\n        if (hasEdgeValConv) {\n            for (int i = 0, j = 2; i < n; i++, j += 3) {\n                nbrs[i] = outEdgeDataArray[j];\n            }\n        } else {\n            System.arraycopy(outEdgeDataArray, 0, nbrs, 0, n);\n        }\n        return nbrs;\n    }\n\n    public EdgeValue getOutEdgeValue(int i) {\n        int idx = i * 3;\n        return blockManager.dereference(new ChiPointer(outEdgeDataArray[idx], outEdgeDataArray[idx + 1]),\n                (BytesToValueConverter<EdgeValue>) edgeValueConverter);\n    }\n\n    class Edge implements ChiEdge<EdgeValue> {\n        Edge(ChiPointer dataPtr, int vertexId) {\n            this.dataPtr = dataPtr;\n            this.vertexId = vertexId;\n        }\n\n        ChiPointer dataPtr;\n        int vertexId;\n\n        public int getVertexId() { return vertexId; }\n\n        public EdgeValue getValue() {\n            return blockManager.dereference(dataPtr, (BytesToValueConverter<EdgeValue>) edgeValueConverter);\n        }\n\n        public void setValue(EdgeValue x) {\n            blockManager.writeValue(dataPtr, edgeValueConverter, x);\n        }\n    }\n}\n"
    ]
}