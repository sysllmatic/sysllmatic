{
    "0": [
        "package edu.cmu.graphchi.datablocks;\n\nimport java.util.ArrayList;\n\n\n\n\npublic class DataBlockManager {\n\n    private ArrayList<byte[]> blocks = new ArrayList<byte[]>(32678);\n\n    public DataBlockManager() {\n\n    }\n\n    public int allocateBlock(int numBytes) {\n        byte[] dataBlock = new byte[numBytes];\n\n        synchronized(blocks) {\n            int blockId = blocks.size();\n            blocks.add(blockId, dataBlock);\n            return blockId;\n        }\n    }\n\n    public byte[] getRawBlock(int blockId) {\n        byte[] bb = blocks.get(blockId);    \n        if (bb == null) {\n            throw new IllegalStateException(\"Null-reference!\");\n        }\n\n        return bb;\n    }\n\n\n    \n    public void reset() {\n        for(int i=0; i<blocks.size(); i++) {\n            if (blocks.get(i) != null) {\n                throw new RuntimeException(\"Tried to reset block manager, but it was non-empty at index: \" + i);\n            }\n        }\n        blocks.clear();\n    }\n\n    public boolean empty() {\n        for(int i=0; i<blocks.size(); i++) {\n            if (blocks.get(i) != null) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public void release(int blockId) {\n        blocks.set(blockId, null);\n    }\n\n    public <T> T dereference(ChiPointer ptr, BytesToValueConverter<T> conv) {\n        byte[] arr = new byte[conv.sizeOf()];\n\n        if (ptr == null) {\n            throw new IllegalStateException(\"Tried to dereference a null pointer!\");\n        }\n\n        System.arraycopy(getRawBlock(ptr.blockId), ptr.offset, arr, 0, arr.length);\n        return conv.getValue(arr);\n    }\n\n    public <T> void writeValue(ChiPointer ptr, BytesToValueConverter<T> conv, T value) {\n        byte[] arr = new byte[conv.sizeOf()];\n        conv.setValue(arr, value);\n        System.arraycopy(arr, 0, getRawBlock(ptr.blockId), ptr.offset, arr.length);\n    }\n\n    public <T> void writeValue(ChiPointer ptr, byte[] data) {\n        System.arraycopy(data, 0, getRawBlock(ptr.blockId), ptr.offset, data.length);\n    }\n}\n"
    ],
    "1": [
        "package edu.cmu.graphchi.datablocks;\n\nimport java.util.ArrayList;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\npublic class DataBlockManager {\n\n    private final ArrayList<byte[]> blocks = new ArrayList<byte[]>(32678);\n    private final Deque<Integer> freeList = new ArrayDeque<Integer>();\n\n    public DataBlockManager() {\n    }\n\n    public synchronized int allocateBlock(int numBytes) {\n        byte[] dataBlock = new byte[numBytes];\n        int blockId;\n        if (!freeList.isEmpty()) {\n            blockId = freeList.pop();\n            blocks.set(blockId, dataBlock);\n        } else {\n            blockId = blocks.size();\n            blocks.add(dataBlock);\n        }\n        return blockId;\n    }\n\n    public synchronized byte[] getRawBlock(int blockId) {\n        byte[] bb = blocks.get(blockId);\n        if (bb == null) {\n            throw new IllegalStateException(\"Null-reference!\");\n        }\n        return bb;\n    }\n\n    public synchronized void reset() {\n        for (int i = 0; i < blocks.size(); i++) {\n            if (blocks.get(i) != null) {\n                throw new RuntimeException(\"Tried to reset block manager, but it was non-empty at index: \" + i);\n            }\n        }\n        blocks.clear();\n        freeList.clear();\n    }\n\n    public synchronized boolean empty() {\n        for (int i = 0; i < blocks.size(); i++) {\n            if (blocks.get(i) != null) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public synchronized void release(int blockId) {\n        blocks.set(blockId, null);\n        freeList.push(blockId);\n    }\n\n    public synchronized <T> T dereference(ChiPointer ptr, BytesToValueConverter<T> conv) {\n        if (ptr == null) {\n            throw new IllegalStateException(\"Tried to dereference a null pointer!\");\n        }\n        byte[] arr = new byte[conv.sizeOf()];\n        System.arraycopy(getRawBlock(ptr.blockId), ptr.offset, arr, 0, arr.length);\n        return conv.getValue(arr);\n    }\n\n    public synchronized <T> void writeValue(ChiPointer ptr, BytesToValueConverter<T> conv, T value) {\n        byte[] arr = new byte[conv.sizeOf()];\n        conv.setValue(arr, value);\n        System.arraycopy(arr, 0, getRawBlock(ptr.blockId), ptr.offset, arr.length);\n    }\n\n    public synchronized <T> void writeValue(ChiPointer ptr, byte[] data) {\n        System.arraycopy(data, 0, getRawBlock(ptr.blockId), ptr.offset, data.length);\n    }\n}\n"
    ],
    "2": [
        "package edu.cmu.graphchi.datablocks;\n\nimport java.util.ArrayList;\nimport java.util.Deque;\nimport java.util.concurrent.ConcurrentLinkedDeque;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class DataBlockManager {\n\n    private final ArrayList<byte[]> blocks = new ArrayList<byte[]>(32678);\n    private final Deque<Integer> freeList = new ConcurrentLinkedDeque<Integer>();\n    private final Map<Integer, Deque<byte[]>> blockPools = new ConcurrentHashMap<Integer, Deque<byte[]>>();\n    private final AtomicInteger activeBlocks = new AtomicInteger(0);\n\n    public DataBlockManager() {\n    }\n\n    public int allocateBlock(int numBytes) {\n        byte[] dataBlock = null;\n        Deque<byte[]> pool = blockPools.get(Integer.valueOf(numBytes));\n        if (pool != null) {\n            dataBlock = pool.poll();\n        }\n        if (dataBlock == null) {\n            dataBlock = new byte[numBytes];\n        }\n        Integer blockId = freeList.poll();\n        synchronized (blocks) {\n            if (blockId != null) {\n                blocks.set(blockId.intValue(), dataBlock);\n            } else {\n                blockId = Integer.valueOf(blocks.size());\n                blocks.add(dataBlock);\n            }\n        }\n        activeBlocks.incrementAndGet();\n        return blockId.intValue();\n    }\n\n    public byte[] getRawBlock(int blockId) {\n        byte[] bb;\n        synchronized (blocks) {\n            bb = blocks.get(blockId);\n        }\n        if (bb == null) {\n            throw new IllegalStateException(\"Null-reference!\");\n        }\n        return bb;\n    }\n\n    public void reset() {\n        if (activeBlocks.get() != 0) {\n            for (int i = 0; i < blocks.size(); i++) {\n                byte[] b;\n                synchronized (blocks) {\n                    b = blocks.get(i);\n                }\n                if (b != null) {\n                    throw new RuntimeException(\"Tried to reset block manager, but it was non-empty at index: \" + i);\n                }\n            }\n        }\n        synchronized (blocks) {\n            blocks.clear();\n        }\n        freeList.clear();\n        blockPools.clear();\n        activeBlocks.set(0);\n    }\n\n    public boolean empty() {\n        return activeBlocks.get() == 0;\n    }\n\n    public void release(int blockId) {\n        byte[] block;\n        synchronized (blocks) {\n            block = blocks.get(blockId);\n            blocks.set(blockId, null);\n        }\n        if (block != null) {\n            int size = block.length;\n            Integer sizeKey = Integer.valueOf(size);\n            Deque<byte[]> pool = blockPools.get(sizeKey);\n            if (pool == null) {\n                Deque<byte[]> newPool = new ConcurrentLinkedDeque<byte[]>();\n                Deque<byte[]> prev = blockPools.putIfAbsent(sizeKey, newPool);\n                if (prev == null) {\n                    pool = newPool;\n                } else {\n                    pool = prev;\n                }\n            }\n            pool.offer(block);\n        }\n        freeList.offer(Integer.valueOf(blockId));\n        activeBlocks.decrementAndGet();\n    }\n\n    public <T> T dereference(ChiPointer ptr, BytesToValueConverter<T> conv) {\n        if (ptr == null) {\n            throw new IllegalStateException(\"Tried to dereference a null pointer!\");\n        }\n        byte[] arr = new byte[conv.sizeOf()];\n        System.arraycopy(getRawBlock(ptr.blockId), ptr.offset, arr, 0, arr.length);\n        return conv.getValue(arr);\n    }\n\n    public <T> void writeValue(ChiPointer ptr, BytesToValueConverter<T> conv, T value) {\n        byte[] arr = new byte[conv.sizeOf()];\n        conv.setValue(arr, value);\n        System.arraycopy(arr, 0, getRawBlock(ptr.blockId), ptr.offset, arr.length);\n    }\n\n    public <T> void writeValue(ChiPointer ptr, byte[] data) {\n        System.arraycopy(data, 0, getRawBlock(ptr.blockId), ptr.offset, data.length);\n    }\n}\n"
    ]
}