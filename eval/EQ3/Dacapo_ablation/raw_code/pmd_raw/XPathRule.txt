{
    "0": [
        "\n\npackage net.sourceforge.pmd.lang.rule;\n\nimport static net.sourceforge.pmd.lang.rule.xpath.XPathRuleQuery.XPATH_1_0;\nimport static net.sourceforge.pmd.lang.rule.xpath.XPathRuleQuery.XPATH_1_0_COMPATIBILITY;\nimport static net.sourceforge.pmd.lang.rule.xpath.XPathRuleQuery.XPATH_2_0;\n\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\n\nimport org.apache.commons.lang3.StringUtils;\n\nimport net.sourceforge.pmd.Rule;\nimport net.sourceforge.pmd.RuleContext;\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.lang.ast.xpath.internal.DeprecatedAttrLogger;\nimport net.sourceforge.pmd.lang.rule.xpath.JaxenXPathRuleQuery;\nimport net.sourceforge.pmd.lang.rule.xpath.SaxonXPathRuleQuery;\nimport net.sourceforge.pmd.lang.rule.xpath.XPathRuleQuery;\nimport net.sourceforge.pmd.lang.rule.xpath.XPathVersion;\nimport net.sourceforge.pmd.properties.EnumeratedProperty;\nimport net.sourceforge.pmd.properties.StringProperty;\n\n\npublic class XPathRule extends AbstractRule {\n\n    \n    @Deprecated\n    public static final StringProperty XPATH_DESCRIPTOR = StringProperty.named(\"xpath\")\n            .desc(\"XPath expression\")\n            .defaultValue(\"\")\n            .uiOrder(1.0f)\n            .build();\n\n    private static final Map<String, String> XPATH_VERSIONS;\n\n    static {\n        Map<String, String> tmp = new HashMap<>();\n        tmp.put(XPATH_1_0, XPATH_1_0);\n        tmp.put(XPATH_1_0_COMPATIBILITY, XPATH_1_0_COMPATIBILITY);\n        tmp.put(XPATH_2_0, XPATH_2_0);\n        XPATH_VERSIONS = Collections.unmodifiableMap(tmp);\n    }\n\n\n    \n    @Deprecated\n    public static final EnumeratedProperty<String> VERSION_DESCRIPTOR = EnumeratedProperty.<String>named(\"version\")\n            .desc(\"XPath specification version\")\n            .mappings(XPATH_VERSIONS)\n            .defaultValue(XPATH_1_0)\n            .type(String.class)\n            .uiOrder(2.0f)\n            .build();\n\n    \n    private XPathRuleQuery xpathRuleQuery;\n\n    \n    private DeprecatedAttrLogger attrLogger = DeprecatedAttrLogger.create(this);\n\n    \n    public XPathRule() {\n        definePropertyDescriptor(XPATH_DESCRIPTOR);\n        definePropertyDescriptor(VERSION_DESCRIPTOR);\n        \n        super.setTypeResolution(true);\n    }\n\n    \n    public XPathRule(final String xPath) {\n        this();\n        setXPath(xPath);\n    }\n\n    \n    public XPathRule(XPathVersion version, String expression) {\n        this();\n        Objects.requireNonNull(version, \"XPath version is null\");\n        Objects.requireNonNull(expression, \"XPath expression is null\");\n        setXPath(expression);\n        setVersion(version.getXmlName());\n    }\n\n\n    @Override\n    public Rule deepCopy() {\n        XPathRule rule = (XPathRule) super.deepCopy();\n        rule.attrLogger = this.attrLogger;\n        return rule;\n    }\n\n    \n    public XPathVersion getVersion() {\n        return XPathVersion.ofId(getProperty(VERSION_DESCRIPTOR));\n    }\n\n    \n    public String getXPathExpression() {\n        return getProperty(XPATH_DESCRIPTOR);\n    }\n\n    \n    @Deprecated\n    public void setXPath(final String xPath) {\n        setProperty(XPathRule.XPATH_DESCRIPTOR, xPath);\n    }\n\n    \n    @Deprecated\n    public void setVersion(final String version) {\n        setProperty(XPathRule.VERSION_DESCRIPTOR, version);\n    }\n\n    @Override\n    public void apply(List<? extends Node> nodes, RuleContext ctx) {\n        for (Node node : nodes) {\n            evaluate(node, ctx);\n        }\n    }\n\n    \n    @Deprecated\n    public void evaluate(final Node node, final RuleContext data) {\n        if (xPathRuleQueryNeedsInitialization()) {\n            initXPathRuleQuery();\n        }\n\n        List<Node> nodesWithViolation = xpathRuleQuery.evaluate(node, data);\n        for (Node nodeWithViolation : nodesWithViolation) {\n            addViolation(data, nodeWithViolation, nodeWithViolation.getImage());\n        }\n    }\n\n    \n    private void initXPathRuleQuery() {\n        String xpath = getXPathExpression();\n        XPathVersion version = getVersion();\n\n        if (version == null) {\n            throw new IllegalStateException(\"Invalid XPath version, should have been caught by Rule::dysfunctionReason\");\n        }\n\n        if (version == XPathVersion.XPATH_1_0) {\n            xpathRuleQuery = new JaxenXPathRuleQuery(attrLogger);\n        } else {\n            xpathRuleQuery = new SaxonXPathRuleQuery(attrLogger);\n        }\n\n        xpathRuleQuery.setXPath(xpath);\n        xpathRuleQuery.setVersion(version.getXmlName());\n        xpathRuleQuery.setProperties(getPropertiesByPropertyDescriptor());\n    }\n\n    \n    private boolean xPathRuleQueryNeedsInitialization() {\n        return xpathRuleQuery == null;\n    }\n\n    @Override\n    public List<String> getRuleChainVisits() {\n        if (xPathRuleQueryNeedsInitialization()) {\n            initXPathRuleQuery();\n\n            for (String nodeName : xpathRuleQuery.getRuleChainVisits()) {\n                super.addRuleChainVisit(nodeName);\n            }\n        }\n        return super.getRuleChainVisits();\n    }\n\n    @Override\n    public String dysfunctionReason() {\n        if (getVersion() == null) {\n            return \"Invalid XPath version '\" + getProperty(VERSION_DESCRIPTOR) + \"'\";\n        } else if (StringUtils.isBlank(getXPathExpression())) {\n            return \"Missing XPath expression\";\n        }\n        return null;\n    }\n}\n"
    ],
    "1": [
        "package net.sourceforge.pmd.lang.rule;\n\nimport static net.sourceforge.pmd.lang.rule.xpath.XPathRuleQuery.XPATH_1_0;\nimport static net.sourceforge.pmd.lang.rule.xpath.XPathRuleQuery.XPATH_1_0_COMPATIBILITY;\nimport static net.sourceforge.pmd.lang.rule.xpath.XPathRuleQuery.XPATH_2_0;\n\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\n\nimport org.apache.commons.lang3.StringUtils;\n\nimport net.sourceforge.pmd.Rule;\nimport net.sourceforge.pmd.RuleContext;\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.lang.ast.xpath.internal.DeprecatedAttrLogger;\nimport net.sourceforge.pmd.lang.rule.xpath.JaxenXPathRuleQuery;\nimport net.sourceforge.pmd.lang.rule.xpath.SaxonXPathRuleQuery;\nimport net.sourceforge.pmd.lang.rule.xpath.XPathRuleQuery;\nimport net.sourceforge.pmd.lang.rule.xpath.XPathVersion;\nimport net.sourceforge.pmd.properties.EnumeratedProperty;\nimport net.sourceforge.pmd.properties.StringProperty;\n\npublic class XPathRule extends AbstractRule {\n\n    @Deprecated\n    public static final StringProperty XPATH_DESCRIPTOR = StringProperty.named(\"xpath\")\n            .desc(\"XPath expression\")\n            .defaultValue(\"\")\n            .uiOrder(1.0f)\n            .build();\n\n    private static final Map<String, String> XPATH_VERSIONS;\n    static {\n        Map<String, String> tmp = new HashMap<>();\n        tmp.put(XPATH_1_0, XPATH_1_0);\n        tmp.put(XPATH_1_0_COMPATIBILITY, XPATH_1_0_COMPATIBILITY);\n        tmp.put(XPATH_2_0, XPATH_2_0);\n        XPATH_VERSIONS = Collections.unmodifiableMap(tmp);\n    }\n\n    @Deprecated\n    public static final EnumeratedProperty<String> VERSION_DESCRIPTOR = EnumeratedProperty.<String>named(\"version\")\n            .desc(\"XPath specification version\")\n            .mappings(XPATH_VERSIONS)\n            .defaultValue(XPATH_1_0)\n            .type(String.class)\n            .uiOrder(2.0f)\n            .build();\n\n    private XPathRuleQuery xpathRuleQuery;\n    private DeprecatedAttrLogger attrLogger = DeprecatedAttrLogger.create(this);\n\n    public XPathRule() {\n        definePropertyDescriptor(XPATH_DESCRIPTOR);\n        definePropertyDescriptor(VERSION_DESCRIPTOR);\n        super.setTypeResolution(true);\n    }\n\n    public XPathRule(final String xPath) {\n        this();\n        setXPath(xPath);\n    }\n\n    public XPathRule(XPathVersion version, String expression) {\n        this();\n        Objects.requireNonNull(version, \"XPath version is null\");\n        Objects.requireNonNull(expression, \"XPath expression is null\");\n        setXPath(expression);\n        setVersion(version.getXmlName());\n    }\n\n    @Override\n    public Rule deepCopy() {\n        XPathRule rule = (XPathRule) super.deepCopy();\n        rule.attrLogger = this.attrLogger;\n        rule.xpathRuleQuery = null; \n        return rule;\n    }\n\n    public XPathVersion getVersion() {\n        return XPathVersion.ofId(getProperty(VERSION_DESCRIPTOR));\n    }\n\n    public String getXPathExpression() {\n        return getProperty(XPATH_DESCRIPTOR);\n    }\n\n    @Deprecated\n    public void setXPath(final String xPath) {\n        setProperty(XPathRule.XPATH_DESCRIPTOR, xPath);\n        xpathRuleQuery = null; \n    }\n\n    @Deprecated\n    public void setVersion(final String version) {\n        setProperty(XPathRule.VERSION_DESCRIPTOR, version);\n        xpathRuleQuery = null; \n    }\n\n    @Override\n    public void apply(List<? extends Node> nodes, RuleContext ctx) {\n        \n        if (xPathRuleQueryNeedsInitialization()) {\n            initXPathRuleQuery();\n        }\n        for (Node node : nodes) {\n            evaluate(node, ctx);\n        }\n    }\n\n    @Deprecated\n    public void evaluate(final Node node, final RuleContext data) {\n        if (xPathRuleQueryNeedsInitialization()) {\n            initXPathRuleQuery();\n        }\n        List<Node> nodesWithViolation = xpathRuleQuery.evaluate(node, data);\n        for (Node nodeWithViolation : nodesWithViolation) {\n            addViolation(data, nodeWithViolation, nodeWithViolation.getImage());\n        }\n    }\n\n    private void initXPathRuleQuery() {\n        String xpath = getXPathExpression();\n        XPathVersion version = getVersion();\n        if (version == null) {\n            throw new IllegalStateException(\"Invalid XPath version, should have been caught by Rule::dysfunctionReason\");\n        }\n        if (version == XPathVersion.XPATH_1_0) {\n            xpathRuleQuery = new JaxenXPathRuleQuery(attrLogger);\n        } else {\n            xpathRuleQuery = new SaxonXPathRuleQuery(attrLogger);\n        }\n        xpathRuleQuery.setXPath(xpath);\n        xpathRuleQuery.setVersion(version.getXmlName());\n        xpathRuleQuery.setProperties(getPropertiesByPropertyDescriptor());\n    }\n\n    private boolean xPathRuleQueryNeedsInitialization() {\n        return xpathRuleQuery == null;\n    }\n\n    @Override\n    public List<String> getRuleChainVisits() {\n        if (xPathRuleQueryNeedsInitialization()) {\n            initXPathRuleQuery();\n            for (String nodeName : xpathRuleQuery.getRuleChainVisits()) {\n                super.addRuleChainVisit(nodeName);\n            }\n        }\n        return super.getRuleChainVisits();\n    }\n\n    @Override\n    public String dysfunctionReason() {\n        if (getVersion() == null) {\n            return \"Invalid XPath version '\" + getProperty(VERSION_DESCRIPTOR) + \"'\";\n        } else if (StringUtils.isBlank(getXPathExpression())) {\n            return \"Missing XPath expression\";\n        }\n        return null;\n    }\n}\n"
    ],
    "2": [
        "package net.sourceforge.pmd.lang.rule;\n\nimport static net.sourceforge.pmd.lang.rule.xpath.XPathRuleQuery.XPATH_1_0;\nimport static net.sourceforge.pmd.lang.rule.xpath.XPathRuleQuery.XPATH_1_0_COMPATIBILITY;\nimport static net.sourceforge.pmd.lang.rule.xpath.XPathRuleQuery.XPATH_2_0;\n\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\n\nimport org.apache.commons.lang3.StringUtils;\n\nimport net.sourceforge.pmd.Rule;\nimport net.sourceforge.pmd.RuleContext;\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.lang.ast.xpath.internal.DeprecatedAttrLogger;\nimport net.sourceforge.pmd.lang.rule.xpath.JaxenXPathRuleQuery;\nimport net.sourceforge.pmd.lang.rule.xpath.SaxonXPathRuleQuery;\nimport net.sourceforge.pmd.lang.rule.xpath.XPathRuleQuery;\nimport net.sourceforge.pmd.lang.rule.xpath.XPathVersion;\nimport net.sourceforge.pmd.properties.EnumeratedProperty;\nimport net.sourceforge.pmd.properties.StringProperty;\n\npublic class XPathRule extends AbstractRule {\n\n    @Deprecated\n    public static final StringProperty XPATH_DESCRIPTOR = StringProperty.named(\"xpath\")\n            .desc(\"XPath expression\")\n            .defaultValue(\"\")\n            .uiOrder(1.0f)\n            .build();\n\n    private static final Map<String, String> XPATH_VERSIONS;\n    static {\n        Map<String, String> tmp = new HashMap<>();\n        tmp.put(XPATH_1_0, XPATH_1_0);\n        tmp.put(XPATH_1_0_COMPATIBILITY, XPATH_1_0_COMPATIBILITY);\n        tmp.put(XPATH_2_0, XPATH_2_0);\n        XPATH_VERSIONS = Collections.unmodifiableMap(tmp);\n    }\n\n    @Deprecated\n    public static final EnumeratedProperty<String> VERSION_DESCRIPTOR = EnumeratedProperty.<String>named(\"version\")\n            .desc(\"XPath specification version\")\n            .mappings(XPATH_VERSIONS)\n            .defaultValue(XPATH_1_0)\n            .type(String.class)\n            .uiOrder(2.0f)\n            .build();\n\n    private XPathRuleQuery xpathRuleQuery;\n    private DeprecatedAttrLogger attrLogger = DeprecatedAttrLogger.create(this);\n\n    public XPathRule() {\n        definePropertyDescriptor(XPATH_DESCRIPTOR);\n        definePropertyDescriptor(VERSION_DESCRIPTOR);\n        super.setTypeResolution(true);\n    }\n\n    public XPathRule(final String xPath) {\n        this();\n        setXPath(xPath);\n    }\n\n    public XPathRule(XPathVersion version, String expression) {\n        this();\n        Objects.requireNonNull(version, \"XPath version is null\");\n        Objects.requireNonNull(expression, \"XPath expression is null\");\n        setXPath(expression);\n        setVersion(version.getXmlName());\n    }\n\n    @Override\n    public Rule deepCopy() {\n        XPathRule rule = (XPathRule) super.deepCopy();\n        rule.attrLogger = this.attrLogger;\n        rule.xpathRuleQuery = null;\n        return rule;\n    }\n\n    public XPathVersion getVersion() {\n        return XPathVersion.ofId(getProperty(VERSION_DESCRIPTOR));\n    }\n\n    public String getXPathExpression() {\n        return getProperty(XPATH_DESCRIPTOR);\n    }\n\n    @Deprecated\n    public void setXPath(final String xPath) {\n        setProperty(XPathRule.XPATH_DESCRIPTOR, xPath);\n        xpathRuleQuery = null;\n    }\n\n    @Deprecated\n    public void setVersion(final String version) {\n        setProperty(XPathRule.VERSION_DESCRIPTOR, version);\n        xpathRuleQuery = null;\n    }\n\n    @Override\n    public void apply(List<? extends Node> nodes, RuleContext ctx) {\n        if (xPathRuleQueryNeedsInitialization()) {\n            initXPathRuleQuery();\n        }\n\n        \n        \n        for (Node node : nodes) {\n            evaluateInternal(node, ctx);\n        }\n    }\n\n    \n    private void evaluateInternal(final Node node, final RuleContext data) {\n        List<Node> nodesWithViolation = xpathRuleQuery.evaluate(node, data);\n        for (Node nodeWithViolation : nodesWithViolation) {\n            addViolation(data, nodeWithViolation, nodeWithViolation.getImage());\n        }\n    }\n\n    \n    @Deprecated\n    public void evaluate(final Node node, final RuleContext data) {\n        if (xPathRuleQueryNeedsInitialization()) {\n            initXPathRuleQuery();\n        }\n        evaluateInternal(node, data);\n    }\n\n    private void initXPathRuleQuery() {\n        String xpath = getXPathExpression();\n        XPathVersion version = getVersion();\n        if (version == null) {\n            throw new IllegalStateException(\"Invalid XPath version, should have been caught by Rule::dysfunctionReason\");\n        }\n        if (version == XPathVersion.XPATH_1_0) {\n            xpathRuleQuery = new JaxenXPathRuleQuery(attrLogger);\n        } else {\n            xpathRuleQuery = new SaxonXPathRuleQuery(attrLogger);\n        }\n        xpathRuleQuery.setXPath(xpath);\n        xpathRuleQuery.setVersion(version.getXmlName());\n        xpathRuleQuery.setProperties(getPropertiesByPropertyDescriptor());\n    }\n\n    private boolean xPathRuleQueryNeedsInitialization() {\n        return xpathRuleQuery == null;\n    }\n\n    @Override\n    public List<String> getRuleChainVisits() {\n        if (xPathRuleQueryNeedsInitialization()) {\n            initXPathRuleQuery();\n            for (String nodeName : xpathRuleQuery.getRuleChainVisits()) {\n                super.addRuleChainVisit(nodeName);\n            }\n        }\n        return super.getRuleChainVisits();\n    }\n\n    @Override\n    public String dysfunctionReason() {\n        if (getVersion() == null) {\n            return \"Invalid XPath version '\" + getProperty(VERSION_DESCRIPTOR) + \"'\";\n        } else if (StringUtils.isBlank(getXPathExpression())) {\n            return \"Missing XPath expression\";\n        }\n        return null;\n    }\n}\n"
    ]
}