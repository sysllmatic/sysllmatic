{
    "0": [
        "\n\npackage net.sourceforge.pmd.lang.rule.xpath;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\n\nimport net.sourceforge.pmd.RuleContext;\nimport net.sourceforge.pmd.annotation.InternalApi;\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.lang.ast.xpath.internal.AstNodeOwner;\nimport net.sourceforge.pmd.lang.ast.xpath.internal.DeprecatedAttrLogger;\nimport net.sourceforge.pmd.lang.ast.xpath.saxon.DocumentNode;\nimport net.sourceforge.pmd.lang.ast.xpath.saxon.ElementNode;\nimport net.sourceforge.pmd.lang.rule.xpath.internal.RuleChainAnalyzer;\nimport net.sourceforge.pmd.lang.xpath.Initializer;\nimport net.sourceforge.pmd.properties.PropertyDescriptor;\nimport net.sourceforge.pmd.util.DataMap;\nimport net.sourceforge.pmd.util.DataMap.DataKey;\nimport net.sourceforge.pmd.util.DataMap.SimpleDataKey;\n\nimport net.sf.saxon.expr.Expression;\nimport net.sf.saxon.om.Item;\nimport net.sf.saxon.om.NamePool;\nimport net.sf.saxon.om.NamespaceConstant;\nimport net.sf.saxon.om.SequenceIterator;\nimport net.sf.saxon.om.ValueRepresentation;\nimport net.sf.saxon.sxpath.AbstractStaticContext;\nimport net.sf.saxon.sxpath.IndependentContext;\nimport net.sf.saxon.sxpath.XPathDynamicContext;\nimport net.sf.saxon.sxpath.XPathEvaluator;\nimport net.sf.saxon.sxpath.XPathExpression;\nimport net.sf.saxon.sxpath.XPathStaticContext;\nimport net.sf.saxon.sxpath.XPathVariable;\nimport net.sf.saxon.trans.XPathException;\nimport net.sf.saxon.value.AtomicValue;\nimport net.sf.saxon.value.BigIntegerValue;\nimport net.sf.saxon.value.BooleanValue;\nimport net.sf.saxon.value.DoubleValue;\nimport net.sf.saxon.value.EmptySequence;\nimport net.sf.saxon.value.FloatValue;\nimport net.sf.saxon.value.Int64Value;\nimport net.sf.saxon.value.SequenceExtent;\nimport net.sf.saxon.value.StringValue;\nimport net.sf.saxon.value.UntypedAtomicValue;\nimport net.sf.saxon.value.Value;\n\n\n@Deprecated\n@InternalApi\npublic class SaxonXPathRuleQuery extends AbstractXPathRuleQuery {\n\n    \n    static final String AST_ROOT = \"_AST_ROOT_\";\n\n    private static final Logger LOG = Logger.getLogger(SaxonXPathRuleQuery.class.getName());\n\n    private static final NamePool NAME_POOL = new NamePool();\n\n    \n    private static final SimpleDataKey<DocumentNode> SAXON_TREE_CACHE_KEY = DataMap.simpleDataKey(\"saxon.tree\");\n\n    \n    Map<String, List<Expression>> nodeNameToXPaths = new HashMap<>();\n\n    \n    XPathExpression xpathExpression;\n\n    \n    private List<XPathVariable> xpathVariables;\n\n    private final DeprecatedAttrLogger attrCtx;\n\n    @Deprecated\n    public SaxonXPathRuleQuery() {\n        this(DeprecatedAttrLogger.noop());\n    }\n\n    public SaxonXPathRuleQuery(DeprecatedAttrLogger attrCtx) {\n        this.attrCtx = attrCtx;\n    }\n\n    @Override\n    public boolean isSupportedVersion(String version) {\n        return XPATH_1_0_COMPATIBILITY.equals(version) || XPATH_2_0.equals(version);\n    }\n\n    @Override\n    public List<Node> evaluate(final Node node, final RuleContext data) {\n        initializeXPathExpression();\n\n        try {\n            final DocumentNode documentNode = getDocumentNodeForRootNode(node);\n            documentNode.setAttrCtx(attrCtx); \n\n            \n            final ElementNode rootElementNode = documentNode.nodeToElementNode.get(node);\n            assert rootElementNode != null : \"Cannot find \" + node;\n            final XPathDynamicContext xpathDynamicContext = createDynamicContext(rootElementNode);\n\n            final List<Node> results = new LinkedList<>();\n            List<Expression> expressions = getXPathExpressionForNodeOrDefault(node.getXPathNodeName());\n            for (Expression expression : expressions) {\n                SequenceIterator iterator = expression.iterate(xpathDynamicContext.getXPathContextObject());\n                Item current = iterator.next();\n                while (current != null) {\n                    if (current instanceof AstNodeOwner) {\n                        results.add(((AstNodeOwner) current).getUnderlyingNode());\n                    } else {\n                        throw new RuntimeException(\"XPath rule expression returned a non-node (\" + current.getClass() + \"): \" + current);\n                    }\n                    current = iterator.next();\n                }\n            }\n\n            Collections.sort(results, RuleChainAnalyzer.documentOrderComparator());\n            return results;\n        } catch (final XPathException e) {\n            throw new RuntimeException(super.xpath + \" had problem: \" + e.getMessage(), e);\n        }\n    }\n\n    private List<Expression> getXPathExpressionForNodeOrDefault(String nodeName) {\n        if (nodeNameToXPaths.containsKey(nodeName)) {\n            return nodeNameToXPaths.get(nodeName);\n        }\n        return nodeNameToXPaths.get(AST_ROOT);\n    }\n\n    \n    private XPathDynamicContext createDynamicContext(final ElementNode elementNode) throws XPathException {\n        final XPathDynamicContext dynamicContext = xpathExpression.createDynamicContext(elementNode);\n\n        \n        for (final XPathVariable xpathVariable : xpathVariables) {\n            final String variableName = xpathVariable.getVariableQName().getLocalName();\n            for (final Map.Entry<PropertyDescriptor<?>, Object> entry : super.properties.entrySet()) {\n                if (variableName.equals(entry.getKey().name())) {\n                    final ValueRepresentation valueRepresentation = getRepresentation(entry.getKey(), entry.getValue());\n                    dynamicContext.setVariable(xpathVariable, valueRepresentation);\n                }\n            }\n        }\n        return dynamicContext;\n    }\n\n\n    \n    @InternalApi\n    public static ValueRepresentation getRepresentation(final PropertyDescriptor<?> descriptor, final Object value) {\n        if (descriptor.isMultiValue()) {\n            return getSequenceRepresentation((List<?>) value);\n        } else {\n            return getAtomicRepresentation(value);\n        }\n    }\n\n    \n    private DocumentNode getDocumentNodeForRootNode(final Node node) {\n        final Node root = getRootNode(node);\n\n        DataMap<DataKey<?, ?>> userMap = root.getUserMap();\n        DocumentNode docNode = userMap.get(SAXON_TREE_CACHE_KEY);\n        if (docNode == null) {\n            docNode = new DocumentNode(root, getNamePool());\n            userMap.set(SAXON_TREE_CACHE_KEY, docNode);\n        }\n        return docNode;\n    }\n\n    \n    private Node getRootNode(final Node node) {\n        Node root = node;\n        while (root.getParent() != null) {\n            root = root.getParent();\n        }\n        return root;\n    }\n\n    private void addExpressionForNode(String nodeName, Expression expression) {\n        if (!nodeNameToXPaths.containsKey(nodeName)) {\n            nodeNameToXPaths.put(nodeName, new LinkedList<Expression>());\n        }\n        nodeNameToXPaths.get(nodeName).add(expression);\n    }\n\n    \n    private void initializeXPathExpression() {\n        if (xpathExpression != null) {\n            return;\n        }\n        try {\n            final XPathEvaluator xpathEvaluator = new XPathEvaluator();\n            final XPathStaticContext xpathStaticContext = xpathEvaluator.getStaticContext();\n            xpathStaticContext.getConfiguration().setNamePool(getNamePool());\n\n            \n            if (XPATH_1_0_COMPATIBILITY.equals(version)) {\n                ((AbstractStaticContext) xpathStaticContext).setBackwardsCompatibilityMode(true);\n            }\n\n            ((IndependentContext) xpathStaticContext).declareNamespace(\"fn\", NamespaceConstant.FN);\n\n            \n            Initializer.initialize((IndependentContext) xpathStaticContext);\n\n            \n            xpathVariables = new ArrayList<>();\n            for (final PropertyDescriptor<?> propertyDescriptor : super.properties.keySet()) {\n                final String name = propertyDescriptor.name();\n                if (!\"xpath\".equals(name)) {\n                    final XPathVariable xpathVariable = xpathStaticContext.declareVariable(null, name);\n                    xpathVariables.add(xpathVariable);\n                }\n            }\n\n            xpathExpression = xpathEvaluator.createExpression(super.xpath);\n            analyzeXPathForRuleChain(xpathEvaluator);\n        } catch (final XPathException e) {\n            throw new RuntimeException(e);\n        }\n    }\n    \n    private void analyzeXPathForRuleChain(final XPathEvaluator xpathEvaluator) {\n        final Expression expr = xpathExpression.getInternalExpression();\n\n        boolean useRuleChain = true;\n\n        \n        Iterable<Expression> subexpressions = RuleChainAnalyzer.splitUnions(expr);\n\n        \n        for (Expression subexpression : subexpressions) {\n            RuleChainAnalyzer rca = new RuleChainAnalyzer(xpathEvaluator.getConfiguration());\n            Expression modified = rca.visit(subexpression);\n\n            if (rca.getRootElement() != null) {\n                addExpressionForNode(rca.getRootElement(), modified);\n            } else {\n                \n                \n                useRuleChain = false;\n                break;\n            }\n        }\n\n        if (useRuleChain) {\n            super.ruleChainVisits.addAll(nodeNameToXPaths.keySet());\n        } else {\n            nodeNameToXPaths.clear();\n            if (LOG.isLoggable(Level.FINE)) {\n                LOG.log(Level.FINE, \"Unable to use RuleChain for XPath: \" + xpath);\n            }\n        }\n\n        \n        addExpressionForNode(AST_ROOT, xpathExpression.getInternalExpression());\n    }\n\n    \n    public static AtomicValue getAtomicRepresentation(final Object value) {\n\n        \n        if (value == null) {\n            return UntypedAtomicValue.ZERO_LENGTH_UNTYPED;\n        } else if (value instanceof Enum) {\n            \n            return new StringValue(value.toString());\n        } else if (value instanceof String) {\n            return new StringValue((String) value);\n        } else if (value instanceof Boolean) {\n            return BooleanValue.get((Boolean) value);\n        } else if (value instanceof Integer) {\n            return Int64Value.makeIntegerValue((Integer) value);\n        } else if (value instanceof Long) {\n            return new BigIntegerValue((Long) value);\n        } else if (value instanceof Double) {\n            return new DoubleValue((Double) value);\n        } else if (value instanceof Character) {\n            return new StringValue(value.toString());\n        } else if (value instanceof Float) {\n            return new FloatValue((Float) value);\n        } else if (value instanceof Pattern) {\n            return new StringValue(String.valueOf(value));\n        } else {\n            \n            throw new RuntimeException(\"Unable to create ValueRepresentation for value of type: \" + value.getClass());\n        }\n    }\n\n    public static Value getSequenceRepresentation(List<?> list) {\n        if (list == null || list.isEmpty()) {\n            return EmptySequence.getInstance();\n        }\n        final Item[] converted = new Item[list.size()];\n        for (int i = 0; i < list.size(); i++) {\n            converted[i] = getAtomicRepresentation(list.get(i));\n        }\n        return new SequenceExtent(converted);\n    }\n\n    @Override\n    public List<String> getRuleChainVisits() {\n        initializeXPathExpression();\n        return super.getRuleChainVisits();\n    }\n\n    public static NamePool getNamePool() {\n        return NAME_POOL;\n    }\n}\n"
    ],
    "1": [
        "package net.sourceforge.pmd.lang.rule.xpath;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\n\nimport net.sourceforge.pmd.RuleContext;\nimport net.sourceforge.pmd.annotation.InternalApi;\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.lang.ast.xpath.internal.AstNodeOwner;\nimport net.sourceforge.pmd.lang.ast.xpath.internal.DeprecatedAttrLogger;\nimport net.sourceforge.pmd.lang.ast.xpath.saxon.DocumentNode;\nimport net.sourceforge.pmd.lang.ast.xpath.saxon.ElementNode;\nimport net.sourceforge.pmd.lang.rule.xpath.internal.RuleChainAnalyzer;\nimport net.sourceforge.pmd.lang.xpath.Initializer;\nimport net.sourceforge.pmd.properties.PropertyDescriptor;\nimport net.sourceforge.pmd.util.DataMap;\nimport net.sourceforge.pmd.util.DataMap.DataKey;\nimport net.sourceforge.pmd.util.DataMap.SimpleDataKey;\n\nimport net.sf.saxon.expr.Expression;\nimport net.sf.saxon.om.Item;\nimport net.sf.saxon.om.NamePool;\nimport net.sf.saxon.om.NamespaceConstant;\nimport net.sf.saxon.om.SequenceIterator;\nimport net.sf.saxon.om.ValueRepresentation;\nimport net.sf.saxon.sxpath.AbstractStaticContext;\nimport net.sf.saxon.sxpath.IndependentContext;\nimport net.sf.saxon.sxpath.XPathDynamicContext;\nimport net.sf.saxon.sxpath.XPathEvaluator;\nimport net.sf.saxon.sxpath.XPathExpression;\nimport net.sf.saxon.sxpath.XPathStaticContext;\nimport net.sf.saxon.sxpath.XPathVariable;\nimport net.sf.saxon.trans.XPathException;\nimport net.sf.saxon.value.AtomicValue;\nimport net.sf.saxon.value.BigIntegerValue;\nimport net.sf.saxon.value.BooleanValue;\nimport net.sf.saxon.value.DoubleValue;\nimport net.sf.saxon.value.EmptySequence;\nimport net.sf.saxon.value.FloatValue;\nimport net.sf.saxon.value.Int64Value;\nimport net.sf.saxon.value.SequenceExtent;\nimport net.sf.saxon.value.StringValue;\nimport net.sf.saxon.value.UntypedAtomicValue;\nimport net.sf.saxon.value.Value;\n\n@Deprecated\n@InternalApi\npublic class SaxonXPathRuleQuery extends AbstractXPathRuleQuery {\n\n    static final String AST_ROOT = \"_AST_ROOT_\";\n\n    private static final Logger LOG = Logger.getLogger(SaxonXPathRuleQuery.class.getName());\n\n    private static final NamePool NAME_POOL = new NamePool();\n\n    private static final SimpleDataKey<DocumentNode> SAXON_TREE_CACHE_KEY = DataMap.simpleDataKey(\"saxon.tree\");\n\n    Map<String, List<Expression>> nodeNameToXPaths = new HashMap<>();\n\n    XPathExpression xpathExpression;\n\n    private List<XPathVariable> xpathVariables;\n\n    private final DeprecatedAttrLogger attrCtx;\n\n    @Deprecated\n    public SaxonXPathRuleQuery() {\n        this(DeprecatedAttrLogger.noop());\n    }\n\n    public SaxonXPathRuleQuery(DeprecatedAttrLogger attrCtx) {\n        this.attrCtx = attrCtx;\n    }\n\n    @Override\n    public boolean isSupportedVersion(String version) {\n        return XPATH_1_0_COMPATIBILITY.equals(version) || XPATH_2_0.equals(version);\n    }\n\n    @Override\n    public List<Node> evaluate(final Node node, final RuleContext data) {\n        initializeXPathExpression();\n\n        try {\n            final DocumentNode documentNode = getDocumentNodeForRootNode(node);\n            documentNode.setAttrCtx(attrCtx);\n\n            final ElementNode rootElementNode = documentNode.nodeToElementNode.get(node);\n            assert rootElementNode != null : \"Cannot find \" + node;\n            final XPathDynamicContext xpathDynamicContext = createDynamicContext(rootElementNode);\n\n            final List<Node> results = new ArrayList<>();\n            List<Expression> expressions = getXPathExpressionForNodeOrDefault(node.getXPathNodeName());\n            for (Expression expression : expressions) {\n                SequenceIterator iterator = expression.iterate(xpathDynamicContext.getXPathContextObject());\n                Item current = iterator.next();\n                while (current != null) {\n                    if (current instanceof AstNodeOwner) {\n                        results.add(((AstNodeOwner) current).getUnderlyingNode());\n                    } else {\n                        throw new RuntimeException(\"XPath rule expression returned a non-node (\" + current.getClass() + \"): \" + current);\n                    }\n                    current = iterator.next();\n                }\n            }\n\n            Collections.sort(results, RuleChainAnalyzer.documentOrderComparator());\n            return results;\n        } catch (final XPathException e) {\n            throw new RuntimeException(super.xpath + \" had problem: \" + e.getMessage(), e);\n        }\n    }\n\n    private List<Expression> getXPathExpressionForNodeOrDefault(String nodeName) {\n        List<Expression> list = nodeNameToXPaths.get(nodeName);\n        if (list != null) {\n            return list;\n        }\n        return nodeNameToXPaths.get(AST_ROOT);\n    }\n\n    private XPathDynamicContext createDynamicContext(final ElementNode elementNode) throws XPathException {\n        final XPathDynamicContext dynamicContext = xpathExpression.createDynamicContext(elementNode);\n\n        \n        Map<String, Object> propertyMap = new HashMap<>();\n        for (Map.Entry<PropertyDescriptor<?>, Object> entry : super.properties.entrySet()) {\n            propertyMap.put(entry.getKey().name(), entry.getValue());\n        }\n\n        for (final XPathVariable xpathVariable : xpathVariables) {\n            final String variableName = xpathVariable.getVariableQName().getLocalName();\n            Object value = propertyMap.get(variableName);\n            if (value != null) {\n                PropertyDescriptor<?> descriptor = null;\n                for (PropertyDescriptor<?> prop : super.properties.keySet()) {\n                    if (prop.name().equals(variableName)) {\n                        descriptor = prop;\n                        break;\n                    }\n                }\n                if (descriptor != null) {\n                    final ValueRepresentation valueRepresentation = getRepresentation(descriptor, value);\n                    dynamicContext.setVariable(xpathVariable, valueRepresentation);\n                }\n            }\n        }\n        return dynamicContext;\n    }\n\n    @InternalApi\n    public static ValueRepresentation getRepresentation(final PropertyDescriptor<?> descriptor, final Object value) {\n        if (descriptor.isMultiValue()) {\n            return getSequenceRepresentation((List<?>) value);\n        } else {\n            return getAtomicRepresentation(value);\n        }\n    }\n\n    private DocumentNode getDocumentNodeForRootNode(final Node node) {\n        final Node root = getRootNode(node);\n\n        DataMap<DataKey<?, ?>> userMap = root.getUserMap();\n        DocumentNode docNode = userMap.get(SAXON_TREE_CACHE_KEY);\n        if (docNode == null) {\n            docNode = new DocumentNode(root, getNamePool());\n            userMap.set(SAXON_TREE_CACHE_KEY, docNode);\n        }\n        return docNode;\n    }\n\n    private Node getRootNode(final Node node) {\n        Node root = node;\n        while (root.getParent() != null) {\n            root = root.getParent();\n        }\n        return root;\n    }\n\n    private void addExpressionForNode(String nodeName, Expression expression) {\n        List<Expression> list = nodeNameToXPaths.get(nodeName);\n        if (list == null) {\n            list = new ArrayList<>();\n            nodeNameToXPaths.put(nodeName, list);\n        }\n        list.add(expression);\n    }\n\n    private void initializeXPathExpression() {\n        if (xpathExpression != null) {\n            return;\n        }\n        try {\n            final XPathEvaluator xpathEvaluator = new XPathEvaluator();\n            final XPathStaticContext xpathStaticContext = xpathEvaluator.getStaticContext();\n            xpathStaticContext.getConfiguration().setNamePool(getNamePool());\n\n            if (XPATH_1_0_COMPATIBILITY.equals(version)) {\n                ((AbstractStaticContext) xpathStaticContext).setBackwardsCompatibilityMode(true);\n            }\n\n            ((IndependentContext) xpathStaticContext).declareNamespace(\"fn\", NamespaceConstant.FN);\n\n            Initializer.initialize((IndependentContext) xpathStaticContext);\n\n            xpathVariables = new ArrayList<>();\n            for (final PropertyDescriptor<?> propertyDescriptor : super.properties.keySet()) {\n                final String name = propertyDescriptor.name();\n                if (!\"xpath\".equals(name)) {\n                    final XPathVariable xpathVariable = xpathStaticContext.declareVariable(null, name);\n                    xpathVariables.add(xpathVariable);\n                }\n            }\n\n            xpathExpression = xpathEvaluator.createExpression(super.xpath);\n            analyzeXPathForRuleChain(xpathEvaluator);\n        } catch (final XPathException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private void analyzeXPathForRuleChain(final XPathEvaluator xpathEvaluator) {\n        final Expression expr = xpathExpression.getInternalExpression();\n\n        boolean useRuleChain = true;\n\n        Iterable<Expression> subexpressions = RuleChainAnalyzer.splitUnions(expr);\n\n        for (Expression subexpression : subexpressions) {\n            RuleChainAnalyzer rca = new RuleChainAnalyzer(xpathEvaluator.getConfiguration());\n            Expression modified = rca.visit(subexpression);\n\n            if (rca.getRootElement() != null) {\n                addExpressionForNode(rca.getRootElement(), modified);\n            } else {\n                useRuleChain = false;\n                break;\n            }\n        }\n\n        if (useRuleChain) {\n            super.ruleChainVisits.addAll(nodeNameToXPaths.keySet());\n        } else {\n            nodeNameToXPaths.clear();\n            if (LOG.isLoggable(Level.FINE)) {\n                LOG.log(Level.FINE, \"Unable to use RuleChain for XPath: \" + xpath);\n            }\n        }\n\n        addExpressionForNode(AST_ROOT, xpathExpression.getInternalExpression());\n    }\n\n    public static AtomicValue getAtomicRepresentation(final Object value) {\n        if (value == null) {\n            return UntypedAtomicValue.ZERO_LENGTH_UNTYPED;\n        } else if (value instanceof Enum) {\n            return new StringValue(value.toString());\n        } else if (value instanceof String) {\n            return new StringValue((String) value);\n        } else if (value instanceof Boolean) {\n            return BooleanValue.get((Boolean) value);\n        } else if (value instanceof Integer) {\n            return Int64Value.makeIntegerValue((Integer) value);\n        } else if (value instanceof Long) {\n            return new BigIntegerValue((Long) value);\n        } else if (value instanceof Double) {\n            return new DoubleValue((Double) value);\n        } else if (value instanceof Character) {\n            return new StringValue(value.toString());\n        } else if (value instanceof Float) {\n            return new FloatValue((Float) value);\n        } else if (value instanceof Pattern) {\n            return new StringValue(String.valueOf(value));\n        } else {\n            throw new RuntimeException(\"Unable to create ValueRepresentation for value of type: \" + value.getClass());\n        }\n    }\n\n    public static Value getSequenceRepresentation(List<?> list) {\n        if (list == null || list.isEmpty()) {\n            return EmptySequence.getInstance();\n        }\n        \n        List<?> arrayList = (list instanceof ArrayList) ? list : new ArrayList<>(list);\n        final Item[] converted = new Item[arrayList.size()];\n        for (int i = 0; i < arrayList.size(); i++) {\n            converted[i] = getAtomicRepresentation(arrayList.get(i));\n        }\n        return new SequenceExtent(converted);\n    }\n\n    @Override\n    public List<String> getRuleChainVisits() {\n        initializeXPathExpression();\n        return super.getRuleChainVisits();\n    }\n\n    public static NamePool getNamePool() {\n        return NAME_POOL;\n    }\n}\n"
    ],
    "2": [
        "package net.sourceforge.pmd.lang.rule.xpath;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\n\nimport net.sourceforge.pmd.RuleContext;\nimport net.sourceforge.pmd.annotation.InternalApi;\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.lang.ast.xpath.internal.AstNodeOwner;\nimport net.sourceforge.pmd.lang.ast.xpath.internal.DeprecatedAttrLogger;\nimport net.sourceforge.pmd.lang.ast.xpath.saxon.DocumentNode;\nimport net.sourceforge.pmd.lang.ast.xpath.saxon.ElementNode;\nimport net.sourceforge.pmd.lang.rule.xpath.internal.RuleChainAnalyzer;\nimport net.sourceforge.pmd.lang.xpath.Initializer;\nimport net.sourceforge.pmd.properties.PropertyDescriptor;\nimport net.sourceforge.pmd.util.DataMap;\nimport net.sourceforge.pmd.util.DataMap.DataKey;\nimport net.sourceforge.pmd.util.DataMap.SimpleDataKey;\n\nimport net.sf.saxon.expr.Expression;\nimport net.sf.saxon.om.Item;\nimport net.sf.saxon.om.NamePool;\nimport net.sf.saxon.om.NamespaceConstant;\nimport net.sf.saxon.om.SequenceIterator;\nimport net.sf.saxon.om.ValueRepresentation;\nimport net.sf.saxon.sxpath.AbstractStaticContext;\nimport net.sf.saxon.sxpath.IndependentContext;\nimport net.sf.saxon.sxpath.XPathDynamicContext;\nimport net.sf.saxon.sxpath.XPathEvaluator;\nimport net.sf.saxon.sxpath.XPathExpression;\nimport net.sf.saxon.sxpath.XPathStaticContext;\nimport net.sf.saxon.sxpath.XPathVariable;\nimport net.sf.saxon.trans.XPathException;\nimport net.sf.saxon.value.AtomicValue;\nimport net.sf.saxon.value.BigIntegerValue;\nimport net.sf.saxon.value.BooleanValue;\nimport net.sf.saxon.value.DoubleValue;\nimport net.sf.saxon.value.EmptySequence;\nimport net.sf.saxon.value.FloatValue;\nimport net.sf.saxon.value.Int64Value;\nimport net.sf.saxon.value.SequenceExtent;\nimport net.sf.saxon.value.StringValue;\nimport net.sf.saxon.value.UntypedAtomicValue;\nimport net.sf.saxon.value.Value;\n\n@Deprecated\n@InternalApi\npublic class SaxonXPathRuleQuery extends AbstractXPathRuleQuery {\n\n    static final String AST_ROOT = \"_AST_ROOT_\";\n\n    private static final Logger LOG = Logger.getLogger(SaxonXPathRuleQuery.class.getName());\n\n    private static final NamePool NAME_POOL = new NamePool();\n\n    private static final SimpleDataKey<DocumentNode> SAXON_TREE_CACHE_KEY = DataMap.simpleDataKey(\"saxon.tree\");\n\n    Map<String, List<Expression>> nodeNameToXPaths = new HashMap<>();\n\n    XPathExpression xpathExpression;\n\n    private List<XPathVariable> xpathVariables;\n    \n    private Map<String, PropertyDescriptor<?>> variableDescriptorMap;\n\n    private final DeprecatedAttrLogger attrCtx;\n\n    @Deprecated\n    public SaxonXPathRuleQuery() {\n        this(DeprecatedAttrLogger.noop());\n    }\n\n    public SaxonXPathRuleQuery(DeprecatedAttrLogger attrCtx) {\n        this.attrCtx = attrCtx;\n    }\n\n    @Override\n    public boolean isSupportedVersion(String version) {\n        return XPATH_1_0_COMPATIBILITY.equals(version) || XPATH_2_0.equals(version);\n    }\n\n    @Override\n    public List<Node> evaluate(final Node node, final RuleContext data) {\n        initializeXPathExpression();\n\n        try {\n            final DocumentNode documentNode = getDocumentNodeForRootNode(node);\n            documentNode.setAttrCtx(attrCtx);\n\n            final ElementNode rootElementNode = documentNode.nodeToElementNode.get(node);\n            assert rootElementNode != null : \"Cannot find \" + node;\n            final XPathDynamicContext xpathDynamicContext = createDynamicContext(rootElementNode);\n\n            final List<Node> results = new ArrayList<>();\n            List<Expression> expressions = getXPathExpressionForNodeOrDefault(node.getXPathNodeName());\n            for (Expression expression : expressions) {\n                SequenceIterator iterator = expression.iterate(xpathDynamicContext.getXPathContextObject());\n                Item current = iterator.next();\n                while (current != null) {\n                    if (current instanceof AstNodeOwner) {\n                        results.add(((AstNodeOwner) current).getUnderlyingNode());\n                    } else {\n                        throw new RuntimeException(\"XPath rule expression returned a non-node (\" + current.getClass() + \"): \" + current);\n                    }\n                    current = iterator.next();\n                }\n            }\n\n            if (results.size() > 1) {\n                Collections.sort(results, RuleChainAnalyzer.documentOrderComparator());\n            }\n            return results;\n        } catch (final XPathException e) {\n            throw new RuntimeException(super.xpath + \" had problem: \" + e.getMessage(), e);\n        }\n    }\n\n    private List<Expression> getXPathExpressionForNodeOrDefault(String nodeName) {\n        List<Expression> list = nodeNameToXPaths.get(nodeName);\n        if (list != null) {\n            return list;\n        }\n        return nodeNameToXPaths.get(AST_ROOT);\n    }\n\n    private XPathDynamicContext createDynamicContext(final ElementNode elementNode) throws XPathException {\n        final XPathDynamicContext dynamicContext = xpathExpression.createDynamicContext(elementNode);\n\n        \n        for (final XPathVariable xpathVariable : xpathVariables) {\n            final String variableName = xpathVariable.getVariableQName().getLocalName();\n            PropertyDescriptor<?> descriptor = variableDescriptorMap.get(variableName);\n            if (descriptor != null) {\n                Object value = super.properties.get(descriptor);\n                if (value != null) {\n                    final ValueRepresentation valueRepresentation = getRepresentation(descriptor, value);\n                    dynamicContext.setVariable(xpathVariable, valueRepresentation);\n                }\n            }\n        }\n        return dynamicContext;\n    }\n\n    @InternalApi\n    public static ValueRepresentation getRepresentation(final PropertyDescriptor<?> descriptor, final Object value) {\n        if (descriptor.isMultiValue()) {\n            return getSequenceRepresentation((List<?>) value);\n        } else {\n            return getAtomicRepresentation(value);\n        }\n    }\n\n    private DocumentNode getDocumentNodeForRootNode(final Node node) {\n        final Node root = getRootNode(node);\n\n        DataMap<DataKey<?, ?>> userMap = root.getUserMap();\n        DocumentNode docNode = userMap.get(SAXON_TREE_CACHE_KEY);\n        if (docNode == null) {\n            docNode = new DocumentNode(root, getNamePool());\n            userMap.set(SAXON_TREE_CACHE_KEY, docNode);\n        }\n        return docNode;\n    }\n\n    private Node getRootNode(final Node node) {\n        Node root = node;\n        while (root.getParent() != null) {\n            root = root.getParent();\n        }\n        return root;\n    }\n\n    private void addExpressionForNode(String nodeName, Expression expression) {\n        List<Expression> list = nodeNameToXPaths.get(nodeName);\n        if (list == null) {\n            list = new ArrayList<>();\n            nodeNameToXPaths.put(nodeName, list);\n        }\n        list.add(expression);\n    }\n\n    private void initializeXPathExpression() {\n        if (xpathExpression != null) {\n            return;\n        }\n        try {\n            final XPathEvaluator xpathEvaluator = new XPathEvaluator();\n            final XPathStaticContext xpathStaticContext = xpathEvaluator.getStaticContext();\n            xpathStaticContext.getConfiguration().setNamePool(getNamePool());\n\n            if (XPATH_1_0_COMPATIBILITY.equals(version)) {\n                ((AbstractStaticContext) xpathStaticContext).setBackwardsCompatibilityMode(true);\n            }\n\n            ((IndependentContext) xpathStaticContext).declareNamespace(\"fn\", NamespaceConstant.FN);\n\n            Initializer.initialize((IndependentContext) xpathStaticContext);\n\n            xpathVariables = new ArrayList<>();\n            variableDescriptorMap = new HashMap<>();\n            for (final PropertyDescriptor<?> propertyDescriptor : super.properties.keySet()) {\n                final String name = propertyDescriptor.name();\n                if (!\"xpath\".equals(name)) {\n                    final XPathVariable xpathVariable = xpathStaticContext.declareVariable(null, name);\n                    xpathVariables.add(xpathVariable);\n                    variableDescriptorMap.put(name, propertyDescriptor);\n                }\n            }\n\n            xpathExpression = xpathEvaluator.createExpression(super.xpath);\n            analyzeXPathForRuleChain(xpathEvaluator);\n        } catch (final XPathException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private void analyzeXPathForRuleChain(final XPathEvaluator xpathEvaluator) {\n        final Expression expr = xpathExpression.getInternalExpression();\n\n        boolean useRuleChain = true;\n\n        Iterable<Expression> subexpressions = RuleChainAnalyzer.splitUnions(expr);\n\n        for (Expression subexpression : subexpressions) {\n            RuleChainAnalyzer rca = new RuleChainAnalyzer(xpathEvaluator.getConfiguration());\n            Expression modified = rca.visit(subexpression);\n\n            if (rca.getRootElement() != null) {\n                addExpressionForNode(rca.getRootElement(), modified);\n            } else {\n                useRuleChain = false;\n                break;\n            }\n        }\n\n        if (useRuleChain) {\n            super.ruleChainVisits.addAll(nodeNameToXPaths.keySet());\n        } else {\n            nodeNameToXPaths.clear();\n            if (LOG.isLoggable(Level.FINE)) {\n                LOG.log(Level.FINE, \"Unable to use RuleChain for XPath: \" + xpath);\n            }\n        }\n\n        addExpressionForNode(AST_ROOT, xpathExpression.getInternalExpression());\n    }\n\n    public static AtomicValue getAtomicRepresentation(final Object value) {\n        if (value == null) {\n            return UntypedAtomicValue.ZERO_LENGTH_UNTYPED;\n        } else if (value instanceof Enum) {\n            return new StringValue(value.toString());\n        } else if (value instanceof String) {\n            return new StringValue((String) value);\n        } else if (value instanceof Boolean) {\n            return BooleanValue.get((Boolean) value);\n        } else if (value instanceof Integer) {\n            return Int64Value.makeIntegerValue((Integer) value);\n        } else if (value instanceof Long) {\n            return new BigIntegerValue((Long) value);\n        } else if (value instanceof Double) {\n            return new DoubleValue((Double) value);\n        } else if (value instanceof Character) {\n            return new StringValue(value.toString());\n        } else if (value instanceof Float) {\n            return new FloatValue((Float) value);\n        } else if (value instanceof Pattern) {\n            return new StringValue(String.valueOf(value));\n        } else {\n            throw new RuntimeException(\"Unable to create ValueRepresentation for value of type: \" + value.getClass());\n        }\n    }\n\n    public static Value getSequenceRepresentation(List<?> list) {\n        if (list == null || list.isEmpty()) {\n            return EmptySequence.getInstance();\n        }\n        \n        final List<?> accessList = (list instanceof java.util.RandomAccess) ? list : new ArrayList<>(list);\n        final Item[] converted = new Item[accessList.size()];\n        for (int i = 0; i < accessList.size(); i++) {\n            converted[i] = getAtomicRepresentation(accessList.get(i));\n        }\n        return new SequenceExtent(converted);\n    }\n\n    @Override\n    public List<String> getRuleChainVisits() {\n        initializeXPathExpression();\n        return super.getRuleChainVisits();\n    }\n\n    public static NamePool getNamePool() {\n        return NAME_POOL;\n    }\n}\n"
    ]
}