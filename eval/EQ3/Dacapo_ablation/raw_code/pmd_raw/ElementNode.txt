{
    "0": [
        "\n\npackage net.sourceforge.pmd.lang.ast.xpath.saxon;\n\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\n\nimport net.sourceforge.pmd.annotation.InternalApi;\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.lang.ast.xpath.Attribute;\nimport net.sourceforge.pmd.lang.ast.xpath.internal.AstNodeOwner;\nimport net.sourceforge.pmd.lang.rule.xpath.SaxonXPathRuleQuery;\n\nimport net.sf.saxon.om.Axis;\nimport net.sf.saxon.om.AxisIterator;\nimport net.sf.saxon.om.DocumentInfo;\nimport net.sf.saxon.om.EmptyIterator;\nimport net.sf.saxon.om.NamePool;\nimport net.sf.saxon.om.Navigator;\nimport net.sf.saxon.om.Navigator.BaseEnumeration;\nimport net.sf.saxon.om.NodeArrayIterator;\nimport net.sf.saxon.om.NodeInfo;\nimport net.sf.saxon.om.SequenceIterator;\nimport net.sf.saxon.om.SingleNodeIterator;\nimport net.sf.saxon.om.SingletonIterator;\nimport net.sf.saxon.pattern.NameTest;\nimport net.sf.saxon.pattern.NodeTest;\nimport net.sf.saxon.type.Type;\nimport net.sf.saxon.value.AtomicValue;\nimport net.sf.saxon.value.StringValue;\nimport net.sf.saxon.value.UntypedAtomicValue;\nimport net.sf.saxon.value.Value;\n\n\n@Deprecated\n@InternalApi\npublic class ElementNode extends BaseNodeInfo implements AstNodeOwner {\n\n    protected final DocumentNode document;\n    protected final ElementNode parent;\n    protected final Node node;\n    protected final int id;\n    protected final int siblingPosition;\n    protected final NodeInfo[] children;\n\n    private Map<Integer, AttributeNode> attributes;\n\n    @Deprecated\n    public ElementNode(DocumentNode document, IdGenerator idGenerator, ElementNode parent, Node node, int siblingPosition) {\n        this(document, idGenerator, parent, node, siblingPosition, SaxonXPathRuleQuery.getNamePool());\n    }\n\n    public ElementNode(DocumentNode document,\n                       IdGenerator idGenerator,\n                       ElementNode parent,\n                       Node node,\n                       int siblingPosition,\n                       NamePool namePool) {\n        super(determineType(node), namePool, node.getXPathNodeName(), parent);\n\n        this.document = document;\n        this.parent = parent;\n        this.node = node;\n        this.id = idGenerator.getNextId();\n        this.siblingPosition = siblingPosition;\n\n        if (node.getNumChildren() > 0) {\n            this.children = new NodeInfo[node.getNumChildren()];\n            for (int i = 0; i < children.length; i++) {\n                children[i] = new ElementNode(document, idGenerator, this, node.getChild(i), i, namePool);\n            }\n        } else {\n            this.children = null;\n        }\n        document.nodeToElementNode.put(node, this);\n    }\n\n    private static int determineType(Node node) {\n        \n        \n        \n        String name = node.getXPathNodeName();\n        if (\"#text\".equals(name)) {\n            return Type.TEXT;\n        } else if (\"#comment\".equals(name)) {\n            return Type.COMMENT;\n        }\n        return Type.ELEMENT;\n    }\n\n    private Map<Integer, AttributeNode> getAttributes() {\n        if (attributes == null) {\n            attributes = new HashMap<>();\n            Iterator<Attribute> iter = node.getXPathAttributesIterator();\n            int idx = 0;\n            while (iter.hasNext()) {\n                Attribute next = iter.next();\n                AttributeNode attrNode = new AttributeNode(this, next, idx++);\n                attributes.put(attrNode.getFingerprint(), attrNode);\n            }\n        }\n        return attributes;\n    }\n\n    @Override\n    public Node getUnderlyingNode() {\n        return node;\n    }\n\n    @Override\n    public int getSiblingPosition() {\n        return siblingPosition;\n    }\n\n    @Override\n    public int getColumnNumber() {\n        return node.getBeginColumn();\n    }\n\n    @Override\n    public int getLineNumber() {\n        return node.getBeginLine();\n    }\n\n    @Override\n    public boolean hasChildNodes() {\n        return children != null;\n    }\n\n    @Override\n    public DocumentInfo getDocumentRoot() {\n        return document;\n    }\n\n    @Override\n    public String getLocalPart() {\n        return node.getXPathNodeName();\n    }\n\n\n    @Override\n    public SequenceIterator getTypedValue() {\n        return SingletonIterator.makeIterator((AtomicValue) atomize());\n    }\n\n    @Override\n    public Value atomize() {\n        switch (getNodeKind()) {\n        case Type.COMMENT:\n        case Type.PROCESSING_INSTRUCTION:\n            return new StringValue(getStringValueCS());\n        default:\n            return new UntypedAtomicValue(getStringValueCS());\n        }\n    }\n\n    @Override\n    public String getStringValue() {\n        if (getNodeKind() == Type.TEXT || getNodeKind() == Type.COMMENT) {\n            return getUnderlyingNode().getImage();\n        }\n        return \"\";\n    }\n\n    @Override\n    public CharSequence getStringValueCS() {\n        return getStringValue();\n    }\n\n    @Override\n    public int compareOrder(NodeInfo other) {\n        int result;\n        if (this.isSameNodeInfo(other)) {\n            result = 0;\n        } else {\n            result = Integer.signum(this.getLineNumber() - other.getLineNumber());\n            if (result == 0) {\n                result = Integer.signum(this.getColumnNumber() - other.getColumnNumber());\n            }\n            if (result == 0) {\n                if (this.getParent().equals(other.getParent())) {\n                    result = Integer.signum(this.getSiblingPosition() - ((ElementNode) other).getSiblingPosition());\n                } else {\n                    \n                    \n                    result = 1;\n                }\n            }\n        }\n        return result;\n    }\n\n\n    @Override\n    public String getDisplayName() {\n        return getLocalPart();\n    }\n\n\n    @Override\n    public AxisIterator iterateAxis(byte axisNumber, NodeTest nodeTest) {\n        if (axisNumber == Axis.ATTRIBUTE) {\n            if (nodeTest instanceof NameTest) {\n                if ((nodeTest.getNodeKindMask() & (1 << Type.ATTRIBUTE)) == 0) {\n                    return EmptyIterator.getInstance();\n                } else {\n                    int fp = nodeTest.getFingerprint();\n                    if (fp != -1) {\n                        return SingleNodeIterator.makeIterator(getAttributes().get(fp));\n                    }\n                }\n            }\n        }\n        return super.iterateAxis(axisNumber, nodeTest);\n    }\n\n    @SuppressWarnings(\"PMD.MissingBreakInSwitch\")\n    @Override\n    public AxisIterator iterateAxis(final byte axisNumber) {\n        switch (axisNumber) {\n        case Axis.ANCESTOR:\n            return new Navigator.AncestorEnumeration(this, false);\n        case Axis.ANCESTOR_OR_SELF:\n            return new Navigator.AncestorEnumeration(this, true);\n        case Axis.ATTRIBUTE:\n            return new AttributeEnumeration();\n        case Axis.CHILD:\n            if (children == null) {\n                return EmptyIterator.getInstance();\n            } else {\n                return new NodeArrayIterator(children);\n            }\n        case Axis.DESCENDANT:\n            return new Navigator.DescendantEnumeration(this, false, true);\n        case Axis.DESCENDANT_OR_SELF:\n            return new Navigator.DescendantEnumeration(this, true, true);\n        case Axis.FOLLOWING:\n            return new Navigator.FollowingEnumeration(this);\n        case Axis.FOLLOWING_SIBLING:\n            if (parent == null || siblingPosition == parent.children.length - 1) {\n                return EmptyIterator.getInstance();\n            } else {\n                return new NodeArrayIterator(parent.children, siblingPosition + 1, parent.children.length);\n            }\n        case Axis.NAMESPACE:\n            return super.iterateAxis(axisNumber);\n        case Axis.PARENT:\n            return SingleNodeIterator.makeIterator(parent);\n        case Axis.PRECEDING:\n            return new Navigator.PrecedingEnumeration(this, false);\n        case Axis.PRECEDING_SIBLING:\n            if (parent == null || siblingPosition == 0) {\n                return EmptyIterator.getInstance();\n            } else {\n                return new NodeArrayIterator(parent.children, 0, siblingPosition);\n            }\n        case Axis.SELF:\n            return SingleNodeIterator.makeIterator(this);\n        case Axis.PRECEDING_OR_ANCESTOR:\n            return new Navigator.PrecedingEnumeration(this, true);\n        default:\n            return super.iterateAxis(axisNumber);\n        }\n    }\n\n    private class AttributeEnumeration extends BaseEnumeration {\n\n        private final Iterator<AttributeNode> iter = getAttributes().values().iterator();\n\n        @Override\n        public void advance() {\n            if (iter.hasNext()) {\n                current = iter.next();\n            } else {\n                current = null;\n            }\n        }\n\n        @Override\n        public SequenceIterator getAnother() {\n            return new AttributeEnumeration();\n        }\n    }\n}\n"
    ],
    "1": [
        "package net.sourceforge.pmd.lang.ast.xpath.saxon;\n\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\n\nimport net.sourceforge.pmd.annotation.InternalApi;\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.lang.ast.xpath.Attribute;\nimport net.sourceforge.pmd.lang.ast.xpath.internal.AstNodeOwner;\nimport net.sourceforge.pmd.lang.rule.xpath.SaxonXPathRuleQuery;\n\nimport net.sf.saxon.om.Axis;\nimport net.sf.saxon.om.AxisIterator;\nimport net.sf.saxon.om.DocumentInfo;\nimport net.sf.saxon.om.EmptyIterator;\nimport net.sf.saxon.om.NamePool;\nimport net.sf.saxon.om.Navigator;\nimport net.sf.saxon.om.Navigator.BaseEnumeration;\nimport net.sf.saxon.om.NodeArrayIterator;\nimport net.sf.saxon.om.NodeInfo;\nimport net.sf.saxon.om.SequenceIterator;\nimport net.sf.saxon.om.SingleNodeIterator;\nimport net.sf.saxon.om.SingletonIterator;\nimport net.sf.saxon.pattern.NameTest;\nimport net.sf.saxon.pattern.NodeTest;\nimport net.sf.saxon.type.Type;\nimport net.sf.saxon.value.AtomicValue;\nimport net.sf.saxon.value.StringValue;\nimport net.sf.saxon.value.UntypedAtomicValue;\nimport net.sf.saxon.value.Value;\n\n@Deprecated\n@InternalApi\npublic class ElementNode extends BaseNodeInfo implements AstNodeOwner {\n\n    protected final DocumentNode document;\n    protected final ElementNode parent;\n    protected final Node node;\n    protected final int id;\n    protected final int siblingPosition;\n    protected final NodeInfo[] children;\n    private Map<Integer, AttributeNode> attributes;\n\n    @Deprecated\n    public ElementNode(DocumentNode document, IdGenerator idGenerator, ElementNode parent, Node node, int siblingPosition) {\n        this(document, idGenerator, parent, node, siblingPosition, SaxonXPathRuleQuery.getNamePool());\n    }\n\n    public ElementNode(DocumentNode document,\n                       IdGenerator idGenerator,\n                       ElementNode parent,\n                       Node node,\n                       int siblingPosition,\n                       NamePool namePool) {\n        super(determineType(node), namePool, node.getXPathNodeName(), parent);\n        this.document = document;\n        this.parent = parent;\n        this.node = node;\n        this.id = idGenerator.getNextId();\n        this.siblingPosition = siblingPosition;\n        int numChildren = node.getNumChildren();\n        if (numChildren > 0) {\n            NodeInfo[] tmpChildren = new NodeInfo[numChildren];\n            for (int i = 0; i < numChildren; i++) {\n                tmpChildren[i] = new ElementNode(document, idGenerator, this, node.getChild(i), i, namePool);\n            }\n            this.children = tmpChildren;\n        } else {\n            this.children = null;\n        }\n        document.nodeToElementNode.put(node, this);\n    }\n\n    private static int determineType(Node node) {\n        String name = node.getXPathNodeName();\n        if (\"#text\".equals(name)) {\n            return Type.TEXT;\n        } else if (\"#comment\".equals(name)) {\n            return Type.COMMENT;\n        }\n        return Type.ELEMENT;\n    }\n\n    private Map<Integer, AttributeNode> getAttributes() {\n        if (attributes == null) {\n            attributes = new HashMap<>();\n            Iterator<Attribute> iter = node.getXPathAttributesIterator();\n            int idx = 0;\n            while (iter.hasNext()) {\n                Attribute next = iter.next();\n                AttributeNode attrNode = new AttributeNode(this, next, idx++);\n                attributes.put(attrNode.getFingerprint(), attrNode);\n            }\n        }\n        return attributes;\n    }\n\n    @Override\n    public Node getUnderlyingNode() {\n        return node;\n    }\n\n    @Override\n    public int getSiblingPosition() {\n        return siblingPosition;\n    }\n\n    @Override\n    public int getColumnNumber() {\n        return node.getBeginColumn();\n    }\n\n    @Override\n    public int getLineNumber() {\n        return node.getBeginLine();\n    }\n\n    @Override\n    public boolean hasChildNodes() {\n        return children != null;\n    }\n\n    @Override\n    public DocumentInfo getDocumentRoot() {\n        return document;\n    }\n\n    @Override\n    public String getLocalPart() {\n        return node.getXPathNodeName();\n    }\n\n    @Override\n    public SequenceIterator getTypedValue() {\n        return SingletonIterator.makeIterator((AtomicValue) atomize());\n    }\n\n    @Override\n    public Value atomize() {\n        switch (getNodeKind()) {\n        case Type.COMMENT:\n        case Type.PROCESSING_INSTRUCTION:\n            return new StringValue(getStringValueCS());\n        default:\n            return new UntypedAtomicValue(getStringValueCS());\n        }\n    }\n\n    @Override\n    public String getStringValue() {\n        if (getNodeKind() == Type.TEXT || getNodeKind() == Type.COMMENT) {\n            return getUnderlyingNode().getImage();\n        }\n        return \"\";\n    }\n\n    @Override\n    public CharSequence getStringValueCS() {\n        return getStringValue();\n    }\n\n    @Override\n    public int compareOrder(NodeInfo other) {\n        int result;\n        if (this.isSameNodeInfo(other)) {\n            result = 0;\n        } else {\n            result = Integer.signum(this.getLineNumber() - other.getLineNumber());\n            if (result == 0) {\n                result = Integer.signum(this.getColumnNumber() - other.getColumnNumber());\n            }\n            if (result == 0) {\n                if (this.getParent().equals(other.getParent())) {\n                    result = Integer.signum(this.getSiblingPosition() - ((ElementNode) other).getSiblingPosition());\n                } else {\n                    result = 1;\n                }\n            }\n        }\n        return result;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return getLocalPart();\n    }\n\n    @Override\n    public AxisIterator iterateAxis(byte axisNumber, NodeTest nodeTest) {\n        if (axisNumber == Axis.ATTRIBUTE) {\n            if (nodeTest instanceof NameTest) {\n                if ((nodeTest.getNodeKindMask() & (1 << Type.ATTRIBUTE)) == 0) {\n                    return EmptyIterator.getInstance();\n                } else {\n                    int fp = nodeTest.getFingerprint();\n                    if (fp != -1) {\n                        return SingleNodeIterator.makeIterator(getAttributes().get(fp));\n                    }\n                }\n            }\n        }\n        return super.iterateAxis(axisNumber, nodeTest);\n    }\n\n    @SuppressWarnings(\"PMD.MissingBreakInSwitch\")\n    @Override\n    public AxisIterator iterateAxis(final byte axisNumber) {\n        switch (axisNumber) {\n        case Axis.ANCESTOR:\n            return new Navigator.AncestorEnumeration(this, false);\n        case Axis.ANCESTOR_OR_SELF:\n            return new Navigator.AncestorEnumeration(this, true);\n        case Axis.ATTRIBUTE:\n            return new AttributeEnumeration();\n        case Axis.CHILD:\n            if (children == null) {\n                return EmptyIterator.getInstance();\n            } else {\n                return new NodeArrayIterator(children);\n            }\n        case Axis.DESCENDANT:\n            return new Navigator.DescendantEnumeration(this, false, true);\n        case Axis.DESCENDANT_OR_SELF:\n            return new Navigator.DescendantEnumeration(this, true, true);\n        case Axis.FOLLOWING:\n            return new Navigator.FollowingEnumeration(this);\n        case Axis.FOLLOWING_SIBLING:\n            if (parent == null || siblingPosition == parent.children.length - 1) {\n                return EmptyIterator.getInstance();\n            } else {\n                return new NodeArrayIterator(parent.children, siblingPosition + 1, parent.children.length);\n            }\n        case Axis.NAMESPACE:\n            return super.iterateAxis(axisNumber);\n        case Axis.PARENT:\n            return SingleNodeIterator.makeIterator(parent);\n        case Axis.PRECEDING:\n            return new Navigator.PrecedingEnumeration(this, false);\n        case Axis.PRECEDING_SIBLING:\n            if (parent == null || siblingPosition == 0) {\n                return EmptyIterator.getInstance();\n            } else {\n                return new NodeArrayIterator(parent.children, 0, siblingPosition);\n            }\n        case Axis.SELF:\n            return SingleNodeIterator.makeIterator(this);\n        case Axis.PRECEDING_OR_ANCESTOR:\n            return new Navigator.PrecedingEnumeration(this, true);\n        default:\n            return super.iterateAxis(axisNumber);\n        }\n    }\n\n    private class AttributeEnumeration extends BaseEnumeration {\n        private final Iterator<AttributeNode> iter = getAttributes().values().iterator();\n\n        @Override\n        public void advance() {\n            if (iter.hasNext()) {\n                current = iter.next();\n            } else {\n                current = null;\n            }\n        }\n\n        @Override\n        public SequenceIterator getAnother() {\n            return new AttributeEnumeration();\n        }\n    }\n}\n"
    ],
    "2": [
        "package net.sourceforge.pmd.lang.ast.xpath.saxon;\n\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\n\nimport net.sourceforge.pmd.annotation.InternalApi;\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.lang.ast.xpath.Attribute;\nimport net.sourceforge.pmd.lang.ast.xpath.internal.AstNodeOwner;\nimport net.sourceforge.pmd.lang.rule.xpath.SaxonXPathRuleQuery;\n\nimport net.sf.saxon.om.Axis;\nimport net.sf.saxon.om.AxisIterator;\nimport net.sf.saxon.om.DocumentInfo;\nimport net.sf.saxon.om.EmptyIterator;\nimport net.sf.saxon.om.NamePool;\nimport net.sf.saxon.om.Navigator;\nimport net.sf.saxon.om.Navigator.BaseEnumeration;\nimport net.sf.saxon.om.NodeArrayIterator;\nimport net.sf.saxon.om.NodeInfo;\nimport net.sf.saxon.om.SequenceIterator;\nimport net.sf.saxon.om.SingleNodeIterator;\nimport net.sf.saxon.om.SingletonIterator;\nimport net.sf.saxon.pattern.NameTest;\nimport net.sf.saxon.pattern.NodeTest;\nimport net.sf.saxon.type.Type;\nimport net.sf.saxon.value.AtomicValue;\nimport net.sf.saxon.value.StringValue;\nimport net.sf.saxon.value.UntypedAtomicValue;\nimport net.sf.saxon.value.Value;\n\n@Deprecated\n@InternalApi\npublic class ElementNode extends BaseNodeInfo implements AstNodeOwner {\n\n    protected final DocumentNode document;\n    protected final ElementNode parent;\n    protected final Node node;\n    protected final int id;\n    protected final int siblingPosition;\n    protected final NodeInfo[] children;\n    private final String nodeName;\n    private Map<Integer, AttributeNode> attributes;\n\n    @Deprecated\n    public ElementNode(DocumentNode document, IdGenerator idGenerator, ElementNode parent, Node node, int siblingPosition) {\n        this(document, idGenerator, parent, node, siblingPosition, SaxonXPathRuleQuery.getNamePool());\n    }\n\n    public ElementNode(DocumentNode document,\n                       IdGenerator idGenerator,\n                       ElementNode parent,\n                       Node node,\n                       int siblingPosition,\n                       NamePool namePool) {\n        super(determineType(node.getXPathNodeName()), namePool, node.getXPathNodeName(), parent);\n        this.document = document;\n        this.parent = parent;\n        this.node = node;\n        this.nodeName = node.getXPathNodeName();\n        this.id = idGenerator.getNextId();\n        this.siblingPosition = siblingPosition;\n        int numChildren = node.getNumChildren();\n        if (numChildren > 0) {\n            NodeInfo[] tmpChildren = new NodeInfo[numChildren];\n            for (int i = 0; i < numChildren; i++) {\n                tmpChildren[i] = new ElementNode(document, idGenerator, this, node.getChild(i), i, namePool);\n            }\n            this.children = tmpChildren;\n        } else {\n            this.children = null;\n        }\n        document.nodeToElementNode.put(node, this);\n    }\n\n    private static int determineType(String name) {\n        if (\"#text\".equals(name)) {\n            return Type.TEXT;\n        } else if (\"#comment\".equals(name)) {\n            return Type.COMMENT;\n        }\n        return Type.ELEMENT;\n    }\n\n    private Map<Integer, AttributeNode> getAttributes() {\n        if (attributes == null) {\n            Iterator<Attribute> iter = node.getXPathAttributesIterator();\n            if (!iter.hasNext()) {\n                attributes = Collections.emptyMap();\n            } else {\n                Map<Integer, AttributeNode> map = new HashMap<>();\n                int idx = 0;\n                while (iter.hasNext()) {\n                    Attribute next = iter.next();\n                    AttributeNode attrNode = new AttributeNode(this, next, idx++);\n                    map.put(attrNode.getFingerprint(), attrNode);\n                }\n                attributes = map;\n            }\n        }\n        return attributes;\n    }\n\n    @Override\n    public Node getUnderlyingNode() {\n        return node;\n    }\n\n    @Override\n    public int getSiblingPosition() {\n        return siblingPosition;\n    }\n\n    @Override\n    public int getColumnNumber() {\n        return node.getBeginColumn();\n    }\n\n    @Override\n    public int getLineNumber() {\n        return node.getBeginLine();\n    }\n\n    @Override\n    public boolean hasChildNodes() {\n        return children != null;\n    }\n\n    @Override\n    public DocumentInfo getDocumentRoot() {\n        return document;\n    }\n\n    @Override\n    public String getLocalPart() {\n        return nodeName;\n    }\n\n    @Override\n    public SequenceIterator getTypedValue() {\n        return SingletonIterator.makeIterator((AtomicValue) atomize());\n    }\n\n    @Override\n    public Value atomize() {\n        switch (getNodeKind()) {\n        case Type.COMMENT:\n        case Type.PROCESSING_INSTRUCTION:\n            return new StringValue(getStringValueCS());\n        default:\n            return new UntypedAtomicValue(getStringValueCS());\n        }\n    }\n\n    @Override\n    public String getStringValue() {\n        if (getNodeKind() == Type.TEXT || getNodeKind() == Type.COMMENT) {\n            return getUnderlyingNode().getImage();\n        }\n        return \"\";\n    }\n\n    @Override\n    public CharSequence getStringValueCS() {\n        return getStringValue();\n    }\n\n    @Override\n    public int compareOrder(NodeInfo other) {\n        int result;\n        if (this.isSameNodeInfo(other)) {\n            result = 0;\n        } else {\n            result = Integer.signum(this.getLineNumber() - other.getLineNumber());\n            if (result == 0) {\n                result = Integer.signum(this.getColumnNumber() - other.getColumnNumber());\n            }\n            if (result == 0) {\n                if (this.getParent().equals(other.getParent())) {\n                    result = Integer.signum(this.getSiblingPosition() - ((ElementNode) other).getSiblingPosition());\n                } else {\n                    result = 1;\n                }\n            }\n        }\n        return result;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return getLocalPart();\n    }\n\n    @Override\n    public AxisIterator iterateAxis(byte axisNumber, NodeTest nodeTest) {\n        if (axisNumber == Axis.ATTRIBUTE) {\n            if (nodeTest instanceof NameTest) {\n                if ((nodeTest.getNodeKindMask() & (1 << Type.ATTRIBUTE)) == 0) {\n                    return EmptyIterator.getInstance();\n                } else {\n                    int fp = nodeTest.getFingerprint();\n                    if (fp != -1) {\n                        return SingleNodeIterator.makeIterator(getAttributes().get(fp));\n                    }\n                }\n            }\n        }\n        return super.iterateAxis(axisNumber, nodeTest);\n    }\n\n    @SuppressWarnings(\"PMD.MissingBreakInSwitch\")\n    @Override\n    public AxisIterator iterateAxis(final byte axisNumber) {\n        switch (axisNumber) {\n        case Axis.ANCESTOR:\n            return new Navigator.AncestorEnumeration(this, false);\n        case Axis.ANCESTOR_OR_SELF:\n            return new Navigator.AncestorEnumeration(this, true);\n        case Axis.ATTRIBUTE:\n            return new AttributeEnumeration();\n        case Axis.CHILD:\n            if (children == null) {\n                return EmptyIterator.getInstance();\n            } else {\n                return new NodeArrayIterator(children);\n            }\n        case Axis.DESCENDANT:\n            return new Navigator.DescendantEnumeration(this, false, true);\n        case Axis.DESCENDANT_OR_SELF:\n            return new Navigator.DescendantEnumeration(this, true, true);\n        case Axis.FOLLOWING:\n            return new Navigator.FollowingEnumeration(this);\n        case Axis.FOLLOWING_SIBLING:\n            if (parent == null || siblingPosition == parent.children.length - 1) {\n                return EmptyIterator.getInstance();\n            } else {\n                return new NodeArrayIterator(parent.children, siblingPosition + 1, parent.children.length);\n            }\n        case Axis.NAMESPACE:\n            return super.iterateAxis(axisNumber);\n        case Axis.PARENT:\n            return SingleNodeIterator.makeIterator(parent);\n        case Axis.PRECEDING:\n            return new Navigator.PrecedingEnumeration(this, false);\n        case Axis.PRECEDING_SIBLING:\n            if (parent == null || siblingPosition == 0) {\n                return EmptyIterator.getInstance();\n            } else {\n                return new NodeArrayIterator(parent.children, 0, siblingPosition);\n            }\n        case Axis.SELF:\n            return SingleNodeIterator.makeIterator(this);\n        case Axis.PRECEDING_OR_ANCESTOR:\n            return new Navigator.PrecedingEnumeration(this, true);\n        default:\n            return super.iterateAxis(axisNumber);\n        }\n    }\n\n    private class AttributeEnumeration extends BaseEnumeration {\n        private final Iterator<AttributeNode> iter = getAttributes().values().iterator();\n\n        @Override\n        public void advance() {\n            if (iter.hasNext()) {\n                current = iter.next();\n            } else {\n                current = null;\n            }\n        }\n\n        @Override\n        public SequenceIterator getAnother() {\n            return new AttributeEnumeration();\n        }\n    }\n}\n"
    ]
}