{
    "0": [
        "\n\npackage net.sourceforge.pmd.lang.ast.xpath;\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\nimport net.sourceforge.pmd.annotation.InternalApi;\nimport net.sourceforge.pmd.lang.ast.Node;\n\n\n\n@Deprecated\n@InternalApi\npublic class AttributeAxisIterator implements Iterator<Attribute> {\n\n    \n    private static final ConcurrentMap<Class<?>, MethodWrapper[]> METHOD_CACHE = new ConcurrentHashMap<>();\n\n    \n    private static final Set<Class<?>> CONSIDERED_RETURN_TYPES\n            = new HashSet<>(Arrays.<Class<?>>asList(Integer.TYPE, Boolean.TYPE, Double.TYPE, String.class,\n                    Long.TYPE, Character.TYPE, Float.TYPE));\n    private static final Set<String> FILTERED_OUT_NAMES\n            = new HashSet<>(Arrays.asList(\"toString\", \"getNumChildren\", \"getIndexInParent\", \"getParent\", \"getClass\", \"getXPathNodeName\", \"getTypeNameNode\", \"hashCode\", \"getImportedNameNode\", \"getScope\"));\n\n    \n    private Attribute currObj;\n    private MethodWrapper[] methodWrappers;\n    private int position;\n    private Node node;\n\n\n    \n    public AttributeAxisIterator(Node contextNode) {\n        this.node = contextNode;\n        if (!METHOD_CACHE.containsKey(contextNode.getClass())) {\n            Method[] preFilter = contextNode.getClass().getMethods();\n            List<MethodWrapper> postFilter = new ArrayList<>();\n            for (Method element : preFilter) {\n                if (isAttributeAccessor(element)) {\n                    postFilter.add(new MethodWrapper(element));\n                }\n            }\n            METHOD_CACHE.putIfAbsent(contextNode.getClass(), postFilter.toArray(new MethodWrapper[0]));\n        }\n        this.methodWrappers = METHOD_CACHE.get(contextNode.getClass());\n\n        this.position = 0;\n        this.currObj = getNextAttribute();\n    }\n\n    \n    protected boolean isAttributeAccessor(Method method) {\n        String methodName = method.getName();\n\n        return !methodName.startsWith(\"jjt\")\n                && !FILTERED_OUT_NAMES.contains(methodName)\n                && method.getParameterTypes().length == 0\n                && isConsideredReturnType(method);\n    }\n\n    private boolean isConsideredReturnType(Method method) {\n        return isSimpleType(method.getReturnType()) || isSequence(method.getGenericReturnType());\n    }\n\n    private boolean isSimpleType(Class<?> klass) {\n        return CONSIDERED_RETURN_TYPES.contains(klass) || klass.isEnum();\n    }\n\n    \n    \n    @Deprecated\n    private boolean isSequence(Type returnType) {\n        if (returnType instanceof ParameterizedType && ((ParameterizedType) returnType).getRawType() == List.class) {\n            Type[] actualTypeArguments = ((ParameterizedType) returnType).getActualTypeArguments();\n            return actualTypeArguments.length == 1\n                    && actualTypeArguments[0] instanceof Class\n                    && isSimpleType((Class<?>) actualTypeArguments[0]);\n        }\n        return false;\n    }\n\n    @Override\n    public Attribute next() {\n        if (!hasNext()) {\n            throw new IndexOutOfBoundsException();\n        }\n        Attribute ret = currObj;\n        currObj = getNextAttribute();\n        return ret;\n    }\n\n\n    @Override\n    public boolean hasNext() {\n        return currObj != null;\n    }\n\n\n    @Override\n    public void remove() {\n        throw new UnsupportedOperationException();\n    }\n\n\n    private Attribute getNextAttribute() {\n        if (methodWrappers == null || position == methodWrappers.length) {\n            return null;\n        }\n        MethodWrapper m = methodWrappers[position++];\n        return new Attribute(node, m.name, m.method);\n    }\n\n\n    \n    private static class MethodWrapper {\n        public Method method;\n        public String name;\n\n\n        MethodWrapper(Method m) {\n            this.method = m;\n            this.name = truncateMethodName(m.getName());\n        }\n\n\n        \n        private String truncateMethodName(String n) {\n            \n            \n            if (n.startsWith(\"get\")) {\n                return n.substring(\"get\".length());\n            }\n            if (n.startsWith(\"is\")) {\n                return n.substring(\"is\".length());\n            }\n            if (n.startsWith(\"has\")) {\n                return n.substring(\"has\".length());\n            }\n            if (n.startsWith(\"uses\")) {\n                return n.substring(\"uses\".length());\n            }\n            if (\"size\".equals(n)) {\n                return \"Size\";\n            }\n\n            return n;\n        }\n    }\n}\n"
    ],
    "1": [
        "package net.sourceforge.pmd.lang.ast.xpath;\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\nimport net.sourceforge.pmd.annotation.InternalApi;\nimport net.sourceforge.pmd.lang.ast.Node;\n\n@Deprecated\n@InternalApi\npublic class AttributeAxisIterator implements Iterator<Attribute> {\n\n    private static final ConcurrentMap<Class<?>, MethodWrapper[]> METHOD_CACHE = new ConcurrentHashMap<Class<?>, MethodWrapper[]>();\n\n    private static final Set<Class<?>> CONSIDERED_RETURN_TYPES = Collections.unmodifiableSet(\n            new HashSet<Class<?>>(Arrays.asList(\n                    Integer.TYPE, Boolean.TYPE, Double.TYPE, String.class,\n                    Long.TYPE, Character.TYPE, Float.TYPE)));\n    private static final Set<String> FILTERED_OUT_NAMES = Collections.unmodifiableSet(\n            new HashSet<String>(Arrays.asList(\n                    \"toString\", \"getNumChildren\", \"getIndexInParent\", \"getParent\", \"getClass\",\n                    \"getXPathNodeName\", \"getTypeNameNode\", \"hashCode\", \"getImportedNameNode\", \"getScope\")));\n\n    private Attribute currObj;\n    private MethodWrapper[] methodWrappers;\n    private int position;\n    private Node node;\n\n    public AttributeAxisIterator(Node contextNode) {\n        this.node = contextNode;\n        Class<?> clazz = contextNode.getClass();\n        MethodWrapper[] cachedWrappers = METHOD_CACHE.get(clazz);\n        if (cachedWrappers == null) {\n            Method[] methods = clazz.getMethods();\n            ArrayList<MethodWrapper> wrappers = new ArrayList<MethodWrapper>(methods.length);\n            for (Method m : methods) {\n                if (isAttributeAccessor(m)) {\n                    wrappers.add(new MethodWrapper(m));\n                }\n            }\n            MethodWrapper[] arr = wrappers.toArray(new MethodWrapper[wrappers.size()]);\n            MethodWrapper[] existing = METHOD_CACHE.putIfAbsent(clazz, arr);\n            \n            cachedWrappers = existing != null ? existing : arr;\n        }\n        this.methodWrappers = cachedWrappers;\n        this.position = 0;\n        this.currObj = getNextAttribute();\n    }\n\n    protected boolean isAttributeAccessor(Method method) {\n        String methodName = method.getName();\n        return !methodName.startsWith(\"jjt\")\n                && !FILTERED_OUT_NAMES.contains(methodName)\n                && method.getParameterTypes().length == 0\n                && isConsideredReturnType(method);\n    }\n\n    private boolean isConsideredReturnType(Method method) {\n        return isSimpleType(method.getReturnType()) || isSequence(method.getGenericReturnType());\n    }\n\n    private boolean isSimpleType(Class<?> klass) {\n        return CONSIDERED_RETURN_TYPES.contains(klass) || klass.isEnum();\n    }\n\n    @Deprecated\n    private boolean isSequence(Type returnType) {\n        if (returnType instanceof ParameterizedType) {\n            ParameterizedType pt = (ParameterizedType) returnType;\n            if (pt.getRawType() == List.class) {\n                Type[] actualTypeArguments = pt.getActualTypeArguments();\n                return actualTypeArguments.length == 1\n                        && actualTypeArguments[0] instanceof Class\n                        && isSimpleType((Class<?>) actualTypeArguments[0]);\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public Attribute next() {\n        if (!hasNext()) {\n            throw new IndexOutOfBoundsException();\n        }\n        Attribute ret = currObj;\n        currObj = getNextAttribute();\n        return ret;\n    }\n\n    @Override\n    public boolean hasNext() {\n        return currObj != null;\n    }\n\n    @Override\n    public void remove() {\n        throw new UnsupportedOperationException();\n    }\n\n    private Attribute getNextAttribute() {\n        if (methodWrappers == null || position >= methodWrappers.length) {\n            return null;\n        }\n        MethodWrapper m = methodWrappers[position++];\n        return new Attribute(node, m.name, m.method);\n    }\n\n    private static class MethodWrapper {\n        public final Method method;\n        public final String name;\n\n        MethodWrapper(Method m) {\n            this.method = m;\n            this.name = truncateMethodName(m.getName());\n        }\n\n        private static String truncateMethodName(String n) {\n            \n            if (n.startsWith(\"get\")) return n.substring(3);\n            if (n.startsWith(\"is\")) return n.substring(2);\n            if (n.startsWith(\"has\")) return n.substring(3);\n            if (n.startsWith(\"uses\")) return n.substring(4);\n            if (\"size\".equals(n)) return \"Size\";\n            return n;\n        }\n    }\n}\n"
    ],
    "2": [
        "package net.sourceforge.pmd.lang.ast.xpath;\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\nimport net.sourceforge.pmd.annotation.InternalApi;\nimport net.sourceforge.pmd.lang.ast.Node;\n\n\n@Deprecated\n@InternalApi\npublic class AttributeAxisIterator implements Iterator<Attribute> {\n    \n    private static final ConcurrentMap<Class<?>, MethodWrapper[]> METHOD_CACHE = new ConcurrentHashMap<Class<?>, MethodWrapper[]>();\n\n    \n    private static final Class<?>[] CONSIDERED_RETURN_TYPES = {\n            Integer.TYPE, Boolean.TYPE, Double.TYPE, String.class,\n            Long.TYPE, Character.TYPE, Float.TYPE\n    };\n    private static final String[] FILTERED_OUT_NAMES = {\n            \"toString\", \"getNumChildren\", \"getIndexInParent\", \"getParent\", \"getClass\",\n            \"getXPathNodeName\", \"getTypeNameNode\", \"hashCode\", \"getImportedNameNode\", \"getScope\"\n    };\n\n    private Attribute currObj;\n    private final MethodWrapper[] methodWrappers;\n    private int position;\n    private final Node node;\n\n    \n    public AttributeAxisIterator(Node contextNode) {\n        this.node = contextNode;\n        final Class<?> clazz = contextNode.getClass();\n        MethodWrapper[] cachedWrappers = METHOD_CACHE.get(clazz);\n        if (cachedWrappers == null) {\n            Method[] methods;\n            try {\n                methods = clazz.getMethods();\n            } catch (SecurityException se) {\n                methods = new Method[0]; \n            }\n            \n            Arrays.sort(methods, new Comparator<Method>() {\n                public int compare(Method m1, Method m2) {\n                    return m1.getName().compareTo(m2.getName());\n                }\n            });\n            final ArrayList<MethodWrapper> wrappers = new ArrayList<MethodWrapper>(methods.length);\n            for (int i = 0; i < methods.length; ++i) {\n                Method m = methods[i];\n                if (isAttributeAccessor(m)) {\n                    wrappers.add(new MethodWrapper(m));\n                }\n            }\n            final MethodWrapper[] arr = wrappers.toArray(new MethodWrapper[wrappers.size()]);\n            MethodWrapper[] existing = METHOD_CACHE.putIfAbsent(clazz, arr);\n            cachedWrappers = existing != null ? existing : arr;\n        }\n        this.methodWrappers = cachedWrappers;\n        this.position = 0;\n        this.currObj = getNextAttribute();\n    }\n\n    \n    protected boolean isAttributeAccessor(Method method) {\n        final String methodName = method.getName();\n        return !methodName.startsWith(\"jjt\")\n                && !filteredOutName(methodName)\n                && method.getParameterTypes().length == 0\n                && isConsideredReturnType(method);\n    }\n\n    \n    private static boolean filteredOutName(String name) {\n        \n        for (int i = 0; i < FILTERED_OUT_NAMES.length; ++i) {\n            if (FILTERED_OUT_NAMES[i].equals(name)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean isConsideredReturnType(Method method) {\n        return isSimpleType(method.getReturnType()) || isSequence(method.getGenericReturnType());\n    }\n\n    \n    private static boolean isSimpleType(Class<?> klass) {\n        for (int i = 0; i < CONSIDERED_RETURN_TYPES.length; ++i) {\n            if (CONSIDERED_RETURN_TYPES[i] == klass) {\n                return true;\n            }\n        }\n        return klass.isEnum();\n    }\n\n    @Deprecated\n    private boolean isSequence(Type returnType) {\n        if (returnType instanceof ParameterizedType) {\n            ParameterizedType pt = (ParameterizedType) returnType;\n            if (pt.getRawType() == List.class) {\n                Type[] actualTypeArguments = pt.getActualTypeArguments();\n                return actualTypeArguments.length == 1\n                        && actualTypeArguments[0] instanceof Class\n                        && isSimpleType((Class<?>) actualTypeArguments[0]);\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public Attribute next() {\n        if (!hasNext()) {\n            throw new IndexOutOfBoundsException();\n        }\n        final Attribute ret = currObj;\n        currObj = getNextAttribute();\n        return ret;\n    }\n\n    @Override\n    public boolean hasNext() {\n        return currObj != null;\n    }\n\n    @Override\n    public void remove() {\n        throw new UnsupportedOperationException();\n    }\n\n    private Attribute getNextAttribute() {\n        if (methodWrappers == null || position >= methodWrappers.length) {\n            return null;\n        }\n        final MethodWrapper m = methodWrappers[position++];\n        return new Attribute(node, m.name, m.method);\n    }\n\n    \n    private static class MethodWrapper {\n        public final Method method;\n        public final String name;\n\n        MethodWrapper(Method m) {\n            this.method = m;\n            this.name = truncateMethodName(m.getName());\n        }\n\n        private static String truncateMethodName(String n) {\n            if (n.startsWith(\"get\")) {\n                return n.substring(3);\n            } else if (n.startsWith(\"is\")) {\n                return n.substring(2);\n            } else if (n.startsWith(\"has\")) {\n                return n.substring(3);\n            } else if (n.startsWith(\"uses\")) {\n                return n.substring(4);\n            } else if (\"size\".equals(n)) {\n                return \"Size\";\n            } else {\n                return n;\n            }\n        }\n    }\n}\n"
    ]
}