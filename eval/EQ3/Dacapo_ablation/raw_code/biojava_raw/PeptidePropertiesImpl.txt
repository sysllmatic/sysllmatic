{
    "0": [
        "\npackage org.biojava.nbio.aaproperties;\n\nimport org.biojava.nbio.aaproperties.xml.AminoAcidCompositionTable;\nimport org.biojava.nbio.aaproperties.xml.ElementTable;\nimport org.biojava.nbio.aaproperties.xml.MyValidationEventHandler;\nimport org.biojava.nbio.core.sequence.ProteinSequence;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompound;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompoundSet;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport jakarta.xml.bind.JAXBContext;\nimport jakarta.xml.bind.JAXBException;\nimport jakarta.xml.bind.Unmarshaller;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.util.HashMap;\nimport java.util.Map;\n\n\npublic class PeptidePropertiesImpl implements IPeptideProperties{\n\n\tprivate final static Logger logger = LoggerFactory.getLogger(PeptidePropertiesImpl.class);\n\n\t\n\tprivate double getWaterMoleculeWeight(){\n\t\tfinal double hydrogenMW = 1.0079;\n\t\tfinal double hydroxideMW = 17.0073;\n\t\t\n\t\treturn hydrogenMW + hydroxideMW;\n\t}\n\n\tprivate char[] getSequence(String sequence, boolean ignoreCase){\n\t\tif(ignoreCase){\n\t\t\treturn sequence.toUpperCase().toCharArray();\n\t\t}else{\n\t\t\treturn sequence.toCharArray();\n\t\t}\n\t}\n\n\t@Override\n\tpublic double getMolecularWeight(ProteinSequence sequence) {\n\t\tdouble value = 0.0;\n\t\tAminoAcidCompoundSet aaSet = new AminoAcidCompoundSet();\n\t\tchar[] seq = getSequence(sequence.toString(), true);\n\t\tfor(char aa:seq){\n\t\t\tAminoAcidCompound c = aaSet.getCompoundForString(String.valueOf(aa));\n\t\t\tif(Constraints.aa2MolecularWeight.containsKey(c)){\n\t\t\t\tvalue += Constraints.aa2MolecularWeight.get(c);\n\t\t\t}\n\t\t}\n\t\tif(value == 0)\n\t\t\treturn value;\n\t\telse\n\t\t\treturn value + getWaterMoleculeWeight();\n\t}\n\n\t@Override\n\tpublic double getMolecularWeight(ProteinSequence sequence, File aminoAcidCompositionFile) throws JAXBException, FileNotFoundException {\n\t\tFile elementMassFile = new File(\"./src/main/resources/ElementMass.xml\");\n\t\tif(!elementMassFile.exists()){\n\t\t\tthrow new FileNotFoundException(\"Cannot locate ElementMass.xml. \" +\n\t\t\t\t\t\"Please use getMolecularWeight(ProteinSequence, File, File) to specify ElementMass.xml location.\");\n\t\t}\n\t\treturn getMolecularWeightBasedOnXML(sequence, obtainAminoAcidCompositionTable(elementMassFile, aminoAcidCompositionFile));\n\t}\n\n\t@Override\n\tpublic double getMolecularWeight(ProteinSequence sequence, File elementMassFile, File aminoAcidCompositionFile)\n\t\t\tthrows JAXBException, FileNotFoundException{\n\t\treturn getMolecularWeightBasedOnXML(sequence, obtainAminoAcidCompositionTable(elementMassFile, aminoAcidCompositionFile));\n\t}\n\n\t@Override\n\tpublic double getMolecularWeightBasedOnXML(ProteinSequence sequence, AminoAcidCompositionTable aminoAcidCompositionTable){\n\t\tdouble value = 0.0;\n\t\tchar[] seq = sequence.toString().toCharArray();\n\t\tfor(char aa:seq){\n\t\t\tDouble weight = aminoAcidCompositionTable.getMolecularWeight(aa);\n\t\t\tif(weight != null){\n\t\t\t\tvalue += weight;\n\t\t\t}\n\t\t}\n\t\tif(value == 0.0)\n\t\t\treturn value;\n\t\telse\n\t\t\treturn value + getWaterMoleculeWeight();\n\t}\n\n\t@Override\n\tpublic AminoAcidCompositionTable obtainAminoAcidCompositionTable(File aminoAcidCompositionFile)\n\t\tthrows JAXBException, FileNotFoundException{\n\t\tFile elementMassFile = new File(\"./src/main/resources/ElementMass.xml\");\n\t\tif(!elementMassFile.exists()){\n\t\t\tthrow new FileNotFoundException(\"Cannot locate ElementMass.xml. \" +\n\t\t\t\t\t\"Please use getMolecularWeight(ProteinSequence, File, File) to specify ElementMass.xml location.\");\n\t\t}\n\t\treturn obtainAminoAcidCompositionTable(elementMassFile, aminoAcidCompositionFile);\n\t}\n\n\t@Override\n\tpublic AminoAcidCompositionTable obtainAminoAcidCompositionTable(File elementMassFile, File aminoAcidCompositionFile)\n\t\tthrows JAXBException, FileNotFoundException{\n\t\t\n\t\tElementTable iTable = new ElementTable();\n\t\t\n\t\tJAXBContext jc = JAXBContext.newInstance(iTable.getClass());\n\t\tUnmarshaller u = jc.createUnmarshaller();\n\t\tu.setEventHandler(new MyValidationEventHandler());\n\t\tiTable = (ElementTable)u.unmarshal(new FileInputStream(elementMassFile));\n\t\tiTable.populateMaps();\n\n\t\t\n\t\tAminoAcidCompositionTable aTable = new AminoAcidCompositionTable();\n\t\t\n\t\tJAXBContext jc2 = JAXBContext.newInstance(aTable.getClass());\n\t\tUnmarshaller u2 = jc2.createUnmarshaller();\n\t\tu2.setEventHandler(new MyValidationEventHandler());\n\t\taTable = (AminoAcidCompositionTable)u2.unmarshal(new FileInputStream(aminoAcidCompositionFile));\n\t\taTable.computeMolecularWeight(iTable);\n\t\treturn aTable;\n\t}\n\n\t@Override\n\tpublic double getExtinctionCoefficient(ProteinSequence sequence, boolean assumeCysReduced) {\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tAminoAcidCompoundSet aaSet = new AminoAcidCompoundSet();\n\t\tMap<AminoAcidCompound, Integer> extinctAA2Count = this.getExtinctAACount(sequence);\n\n\t\tdouble eProt;\n\t\tif(!assumeCysReduced){\n\t\t\teProt = extinctAA2Count.get(aaSet.getCompoundForString(\"Y\")) *\n\t\t\t\tConstraints.aa2ExtinctionCoefficient.get(aaSet.getCompoundForString(\"Y\")) +\n\t\t\t\textinctAA2Count.get(aaSet.getCompoundForString(\"W\")) *\n\t\t\t\tConstraints.aa2ExtinctionCoefficient.get(aaSet.getCompoundForString(\"W\")) +\n\t\t\t\textinctAA2Count.get(aaSet.getCompoundForString(\"C\")) *\n\t\t\t\tConstraints.aa2ExtinctionCoefficient.get(aaSet.getCompoundForString(\"C\"));\n\t\t}else\n\t\t\teProt = extinctAA2Count.get(aaSet.getCompoundForString(\"Y\")) *\n\t\t\t\tConstraints.aa2ExtinctionCoefficient.get(aaSet.getCompoundForString(\"Y\")) +\n\t\t\t\textinctAA2Count.get(aaSet.getCompoundForString(\"W\")) *\n\t\t\t\tConstraints.aa2ExtinctionCoefficient.get(aaSet.getCompoundForString(\"W\"));\n\n\t\treturn eProt;\n\t}\n\n\t@Override\n\tpublic double getAbsorbance(ProteinSequence sequence, boolean assumeCysReduced){\n\t\t\n\t\tdouble mw = this.getMolecularWeight(sequence);\n\t\tdouble eProt = this.getExtinctionCoefficient(sequence, assumeCysReduced);\n\t\tif (mw == 0.0) {\n\t\t\tlogger.warn(\"Molecular weight is 0.0, can't divide by 0: setting absorbance to 0.0\");\n\t\t\treturn 0.0;\n\t\t}\n\t\treturn eProt / mw;\n\t}\n\n\tprivate Map<AminoAcidCompound, Integer> getExtinctAACount(ProteinSequence sequence){\n\t\t\n\t\tint numW = 0;\n\t\tint smallW = 0;\n\t\tdouble numC = 0;\n\t\tdouble smallC = 0;\n\t\tint numY = 0;\n\t\tint smallY = 0;\n\t\tfor(char aa:sequence.getSequenceAsString().toCharArray()){\n\t\t\tswitch(aa){\n\t\t\tcase 'W': numW++; break;\n\t\t\tcase 'w': smallW++; break;\n\t\t\tcase 'C': numC += 0.5; break;\n\t\t\tcase 'c': smallC += 0.5; break;\n\t\t\tcase 'Y': numY++; break;\n\t\t\tcase 'y': smallY++; break;\n\t\t\t}\n\t\t}\n\t\tAminoAcidCompoundSet aaSet = new AminoAcidCompoundSet();\n\t\tMap<AminoAcidCompound, Integer> extinctAA2Count = new HashMap<AminoAcidCompound, Integer>();\n\t\t\n\t\textinctAA2Count.put(aaSet.getCompoundForString(\"W\"), numW + smallW);\n\t\textinctAA2Count.put(aaSet.getCompoundForString(\"C\"), (int) (numC + smallC));\n\t\textinctAA2Count.put(aaSet.getCompoundForString(\"Y\"), numY + smallY);\n\t\treturn extinctAA2Count;\n\t}\n\n\t@Override\n\tpublic double getInstabilityIndex(ProteinSequence sequence) {\n\t\tdouble sum = 0.0;\n\t\tString s = sequence.getSequenceAsString().toUpperCase();\n\t\tfor(int i = 0; i < sequence.getLength() - 1; i++){\n\t\t\tString dipeptide = s.substring(i, i+2);\n\t\t\tif(Constraints.diAA2Instability.containsKey(dipeptide)){\n\t\t\t\tsum += Constraints.diAA2Instability.get(dipeptide);\n\t\t\t}\n\t\t}\n\t\tint denominator = s.length() - Utils.getNumberOfInvalidChar(s, null, true);\n\n\t\tif (denominator==0) {\n\t\t\tlogger.warn(\"Valid length of sequence is 0, can't divide by 0 to calculate instability index: setting instability index value to 0.0\");\n\t\t\treturn 0.0;\n\t\t}\n\t\treturn sum * 10.0 / denominator;\n\t}\n\n\t@Override\n\tpublic double getApliphaticIndex(ProteinSequence sequence) {\n\n\n\n\n\n\n\t\tAminoAcidCompoundSet aaSet = new AminoAcidCompoundSet();\n\t\tMap<AminoAcidCompound, Double> aa2Composition = getAAComposition(sequence);\n\t\tfinal double a = 2.9;\n\t\tfinal double b = 3.9;\n\t\tdouble xAla = aa2Composition.get(aaSet.getCompoundForString(\"A\"));\n\t\tdouble xVal = aa2Composition.get(aaSet.getCompoundForString(\"V\"));\n\t\tdouble xIle = aa2Composition.get(aaSet.getCompoundForString(\"I\"));\n\t\tdouble xLeu = aa2Composition.get(aaSet.getCompoundForString(\"L\"));\n\t\treturn (xAla + (a * xVal) + (b * (xIle + xLeu))) * 100;\n\t}\n\n\t@Override\n\tpublic double getAvgHydropathy(ProteinSequence sequence) {\n\t\tint validLength = 0;\n\t\tdouble total = 0.0;\n\t\tAminoAcidCompoundSet aaSet = new AminoAcidCompoundSet();\n\t\tchar[] seq = this.getSequence(sequence.toString(), true);\n\t\tfor(char aa:seq){\n\t\t\tAminoAcidCompound c = aaSet.getCompoundForString(String.valueOf(aa));\n\t\t\tif(Constraints.aa2Hydrophathicity.containsKey(c)){\n\t\t\t\ttotal += Constraints.aa2Hydrophathicity.get(c);\n\t\t\t\tvalidLength++;\n\t\t\t}\n\t\t}\n\t\tif (validLength==0) {\n\t\t\tlogger.warn(\"Valid length of sequence is 0, can't divide by 0 to calculate average hydropathy: setting average hydropathy to 0\");\n\t\t\treturn 0.0;\n\t\t}\n\n\t\treturn total / validLength;\n\t}\n\n\t@Override\n\tpublic double getIsoelectricPoint(ProteinSequence sequence, boolean useExpasyValues) {\n\t\tif(useExpasyValues){\n\t\t\treturn this.getIsoelectricPointExpasy(sequence.toString().toUpperCase());\n\t\t}else{\n\t\t\treturn this.getIsoelectricPointInnovagen(sequence);\n\t\t}\n\t}\n\n\tprivate double getIsoelectricPointInnovagen(ProteinSequence sequence){\n\t\tdouble currentPH = 7.0;\n\t\tdouble changeSize = 7.0;\n\t\tString sequenceString = sequence.toString();\n\t\tchar nTerminalChar = sequenceString.charAt(0);\n\t\tchar cTerminalChar = sequenceString.charAt(sequenceString.length() - 1);\n\n\t\tMap<AminoAcidCompound, Integer> chargedAA2Count = this.getChargedAACount(sequence);\n\t\tdouble margin;\n\t\tfinal double difference = 0.0001;\n\n\t\twhile(true){\n\t\t\tmargin = this.getNetChargeInnovagen(chargedAA2Count, currentPH, nTerminalChar, cTerminalChar);\n\t\t\t\n\t\t\tif(margin <= difference && margin >= -difference) break;\n\t\t\tchangeSize /= 2.0;\n\t\t\tif(margin > 0){\n\t\t\t\tcurrentPH += changeSize;\n\t\t\t}else{\n\t\t\t\tcurrentPH -= changeSize;\n\t\t\t}\n\t\t}\n\t\treturn currentPH;\n\t}\n\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tprivate final double[][] cPk = {\n\t\t\t{3.55, 7.59, 0.0},  \n\t\t\t{3.55, 7.50, 0.0},  \n\t\t\t{3.55, 7.50, 9.00}, \n\n\n\t\t\t{3.55, 7.50, 4.05}, \n\t\t\t{3.55, 7.70, 4.45}, \n\t\t\t{3.55, 7.50, 0}, \n\t\t\t{3.55, 7.50, 0}, \n\t\t\t{3.55, 7.50, 5.98}, \n\t\t\t{3.55, 7.50, 0.0}, \n\t\t\t{0.0, 0.0, 0.0}, \n\t\t\t{3.55, 7.50, 10.00}, \n\t\t\t{3.55, 7.50, 0.0}, \n\t\t\t{3.55, 7.00, 0.0},\n\t\t\t{3.55, 7.50, 0.0},\n\t\t\t{0.00, 0.00, 0.0},\n\t\t\t{3.55, 8.36, 0.0},\n\t\t\t{3.55, 7.50, 0.0}, \n\t\t\t{3.55, 7.50, 12.0},\n\t\t\t{3.55, 6.93, 0.0},\n\t\t\t{3.55, 6.82, 0.0}, \n\t\t\t{0.00, 0.00, 0.0}, \n\t\t\t{3.55, 7.44, 0.0},\n\t\t\t{3.55, 7.50, 0.0},\n\t\t\t{3.55, 7.50, 0.0},\n\t\t\t{3.55, 7.50, 10.00},\n\t\t\t{3.55, 7.50, 0.0}}; \n\n\tprivate final double PH_MIN = 0.0; \n\tprivate final double PH_MAX = 14.0; \n\tprivate final double MAXLOOP = 2000.0; \n\tprivate final double EPSI = 0.0001; \n\n\tprivate double exp10(double pka){\n\t\treturn Math.pow(10, pka);\n\t}\n\n\tprivate double getIsoelectricPointExpasy(String sequence){\n\t\t\n\t\t\n\t\t\n\t\tint[] comp = new int[26];\n\t\tfor(int i = 0; i < sequence.length(); i++){\n\t\t\tint index = sequence.charAt(i) - 'A';\n\t\t\tif(index < 0 || index >= 26) continue;\n\t\t\tcomp[index]++;\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tint nTermResidue = -1;\n\t\tint index = 0;\n\t\twhile((nTermResidue < 0 || nTermResidue >= 26) && index < 25){\n\t\t\tnTermResidue = sequence.charAt(index++) - 'A';\n\t\t}\n\n\t\tint cTermResidue = -1;\n\t\tindex = 1;\n\t\twhile((cTermResidue < 0 || cTermResidue >= 26) && index < 25){\n\t\t\tcTermResidue = sequence.charAt(sequence.length() - index++) - 'A';\n\t\t}\n\n\t\tdouble phMin = PH_MIN;\n\t\tdouble phMax = PH_MAX;\n\n\t\tdouble phMid = 0.0;\n\t\tdouble charge = 1.0;\n\t\tfor (int i = 0; i < MAXLOOP && (phMax - phMin) > EPSI; i++){\n\t\t\tphMid = phMin + (phMax - phMin) / 2.0;\n\n\t\t\tcharge = getNetChargeExpasy(comp, nTermResidue, cTermResidue, phMid);\n\n\t\t\tif (charge > 0.0) phMin = phMid;\n\t\t\telse phMax = phMid;\n\t\t}\n\t\treturn phMid;\n\t}\n\n\t@Override\n\tpublic double getIsoelectricPoint(ProteinSequence sequence){\n\t\treturn getIsoelectricPoint(sequence, true);\n\t}\n\n\t@Override\n\tpublic double getNetCharge(ProteinSequence sequence) {\n\t\treturn getNetCharge(sequence, true);\n\t}\n\n\t@Override\n\tpublic double getNetCharge(ProteinSequence sequence, boolean useExpasyValues){\n\t\treturn getNetCharge(sequence, true, 7.0);\n\t}\n\n\t@Override\n\tpublic double getNetCharge(ProteinSequence sequence, boolean useExpasyValues, double pHPoint){\n\t\tif(useExpasyValues){\n\t\t\treturn getNetChargeExpasy(sequence.toString().toUpperCase(), pHPoint);\n\t\t}else{\n\t\t\treturn getNetChargeInnovagen(sequence, pHPoint);\n\t\t}\n\t}\n\n\tprivate double getNetChargeExpasy(String sequence, double pHPoint){\n\t\t\n\t\t\n\t\t\n\t\tint[] comp = new int[26];\n\t\tfor(int i = 0; i < sequence.length(); i++){\n\t\t\tint index = sequence.charAt(i) - 'A';\n\t\t\tif(index < 0 || index >= 26) continue;\n\t\t\tcomp[index]++;\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tint nTermResidue = sequence.charAt(0) - 'A';\n\t\tint cTermResidue = sequence.charAt(sequence.length() - 1) - 'A';\n\t\treturn getNetChargeExpasy(comp, nTermResidue, cTermResidue, pHPoint);\n\t}\n\n\tprivate double getNetChargeExpasy(int[] comp, int nTermResidue, int cTermResidue, double ph){\n\t\tdouble cter = 0.0;\n\t\tif(cTermResidue >= 0 && cTermResidue < 26) cter = exp10(-cPk[cTermResidue][0]) / (exp10(-cPk[cTermResidue][0]) + exp10(-ph));\n\t\tdouble nter = 0.0;\n\t\tif(nTermResidue >= 0 && nTermResidue < 26) nter = exp10(-ph) / (exp10(-cPk[nTermResidue][1]) + exp10(-ph));\n\n\t\tdouble carg = comp['R' - 'A'] * exp10(-ph) / (exp10(-cPk['R' - 'A'][2]) + exp10(-ph));\n\t\tdouble chis = comp['H' - 'A'] * exp10(-ph) / (exp10(-cPk['H' - 'A'][2]) + exp10(-ph));\n\t\tdouble clys = comp['K' - 'A'] * exp10(-ph) / (exp10(-cPk['K' - 'A'][2]) + exp10(-ph));\n\n\t\tdouble casp = comp['D' - 'A'] * exp10(-cPk['D' - 'A'][2]) / (exp10(-cPk['D' - 'A'][2]) + exp10(-ph));\n\t\tdouble cglu = comp['E' - 'A'] * exp10(-cPk['E' - 'A'][2]) / (exp10(-cPk['E' - 'A'][2]) + exp10(-ph));\n\n\t\tdouble ccys = comp['C' - 'A'] * exp10(-cPk['C' - 'A'][2]) / (exp10(-cPk['C' - 'A'][2]) + exp10(-ph));\n\t\tdouble ctyr = comp['Y' - 'A'] * exp10(-cPk['Y' - 'A'][2]) / (exp10(-cPk['Y' - 'A'][2]) + exp10(-ph));\n\n\t\treturn (carg + clys + chis + nter) - (casp + cglu + ctyr + ccys + cter);\n\t}\n\n\tprivate double getNetChargeInnovagen(ProteinSequence sequence, double pHPoint) {\n\t\tMap<AminoAcidCompound, Integer> chargedAA2Count = this.getChargedAACount(sequence);\n\t\tString sequenceString = sequence.getSequenceAsString();\n\t\treturn getNetChargeInnovagen(chargedAA2Count, pHPoint, sequenceString.charAt(0), sequenceString.charAt(sequenceString.length() - 1));\n\t}\n\n\tprivate double getNetChargeInnovagen(Map<AminoAcidCompound, Integer> chargedAA2Count, double ph, char nTerminalChar, char cTerminalChar){\n\t\t\n\n\t\t\n\t\t\n\t\tAminoAcidCompoundSet aaSet = new AminoAcidCompoundSet();\n\n\t\tdouble nTerminalCharge = 0.0;\n\t\tAminoAcidCompound nTermCompound = aaSet.getCompoundForString(String.valueOf(nTerminalChar));\n\t\tif(Constraints.aa2NTerminalPka.containsKey(nTermCompound)){\n\t\t\tnTerminalCharge = this.getPosCharge(Constraints.aa2NTerminalPka.get(nTermCompound), ph);\n\t\t}\n\n\t\tdouble cTerminalCharge = 0.0;\n\t\tAminoAcidCompound cTermCompound = aaSet.getCompoundForString(String.valueOf(cTerminalChar));\n\t\tif(Constraints.aa2CTerminalPka.containsKey(cTermCompound)){\n\t\t\tcTerminalCharge = this.getNegCharge(Constraints.aa2CTerminalPka.get(cTermCompound), ph);\n\t\t}\n\n\t\tdouble kCharge = chargedAA2Count.get(aaSet.getCompoundForString(\"K\")) * this.getPosCharge(Constraints.aa2PKa.get(aaSet.getCompoundForString(\"K\")), ph);\n\t\tdouble rCharge = chargedAA2Count.get(aaSet.getCompoundForString(\"R\")) * this.getPosCharge(Constraints.aa2PKa.get(aaSet.getCompoundForString(\"R\")), ph);\n\t\tdouble hCharge = chargedAA2Count.get(aaSet.getCompoundForString(\"H\")) * this.getPosCharge(Constraints.aa2PKa.get(aaSet.getCompoundForString(\"H\")), ph);\n\t\tdouble dCharge = chargedAA2Count.get(aaSet.getCompoundForString(\"D\")) * this.getNegCharge(Constraints.aa2PKa.get(aaSet.getCompoundForString(\"D\")), ph);\n\t\tdouble eCharge = chargedAA2Count.get(aaSet.getCompoundForString(\"E\")) * this.getNegCharge(Constraints.aa2PKa.get(aaSet.getCompoundForString(\"E\")), ph);\n\t\tdouble cCharge = chargedAA2Count.get(aaSet.getCompoundForString(\"C\")) * this.getNegCharge(Constraints.aa2PKa.get(aaSet.getCompoundForString(\"C\")), ph);\n\t\tdouble yCharge = chargedAA2Count.get(aaSet.getCompoundForString(\"Y\")) * this.getNegCharge(Constraints.aa2PKa.get(aaSet.getCompoundForString(\"Y\")), ph);\n\n\n\n\t\treturn (nTerminalCharge + kCharge + rCharge + hCharge) - (dCharge + eCharge + cCharge + yCharge + cTerminalCharge);\n\t}\n\n\tprivate double getPosCharge(double pka, double ph){\n\t\treturn Math.pow(10, pka) / (Math.pow(10, pka) + Math.pow(10, ph));\n\t}\n\n\tprivate double getNegCharge(double pka, double ph){\n\t\treturn Math.pow(10, ph) / (Math.pow(10, pka) + Math.pow(10, ph));\n\t}\n\n\tprivate Map<AminoAcidCompound, Integer> getChargedAACount(ProteinSequence sequence){\n\t\t\n\t\t\n\t\tint numK = 0;\n\t\tint numR = 0;\n\t\tint numH = 0;\n\t\tint numD = 0;\n\t\tint numE = 0;\n\t\tint numC = 0;\n\t\tint numY = 0;\n\t\tchar[] seq = this.getSequence(sequence.getSequenceAsString(), true);\n\t\tfor(char aa:seq){\n\t\t\tswitch(aa){\n\t\t\tcase 'K': numK++; break;\n\t\t\tcase 'R': numR++; break;\n\t\t\tcase 'H': numH++; break;\n\t\t\tcase 'D': numD++; break;\n\t\t\tcase 'E': numE++; break;\n\t\t\tcase 'C': numC++; break;\n\t\t\tcase 'Y': numY++; break;\n\t\t\t}\n\t\t}\n\t\tAminoAcidCompoundSet aaSet = new AminoAcidCompoundSet();\n\t\tMap<AminoAcidCompound, Integer> chargedAA2Count = new HashMap<AminoAcidCompound, Integer>();\n\t\tchargedAA2Count.put(aaSet.getCompoundForString(\"K\"), numK);\n\t\tchargedAA2Count.put(aaSet.getCompoundForString(\"R\"), numR);\n\t\tchargedAA2Count.put(aaSet.getCompoundForString(\"H\"), numH);\n\t\tchargedAA2Count.put(aaSet.getCompoundForString(\"D\"), numD);\n\t\tchargedAA2Count.put(aaSet.getCompoundForString(\"E\"), numE);\n\t\tchargedAA2Count.put(aaSet.getCompoundForString(\"C\"), numC);\n\t\tchargedAA2Count.put(aaSet.getCompoundForString(\"Y\"), numY);\n\t\treturn chargedAA2Count;\n\t}\n\n\t@Override\n\tpublic double getEnrichment(ProteinSequence sequence, AminoAcidCompound aminoAcidCode) {\n\t\tdouble counter = 0.0;\n\t\tchar[] seq = this.getSequence(sequence.getSequenceAsString(), true);\n\t\tfor(char aa:seq){\n\t\t\tif(aminoAcidCode.getShortName().equals(String.valueOf(aa))){\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t}\n\t\treturn counter/sequence.getLength();\n\t}\n\n\t@Override\n\tpublic Map<AminoAcidCompound, Double> getAAComposition(ProteinSequence sequence) {\n\t\tint validLength = 0;\n\t\tMap<AminoAcidCompound, Double> aa2Composition = new HashMap<AminoAcidCompound, Double>();\n\t\tAminoAcidCompoundSet aaSet = new AminoAcidCompoundSet();\n\t\tfor(AminoAcidCompound aa:aaSet.getAllCompounds()){\n\t\t\taa2Composition.put(aa, 0.0);\n\t\t}\n\t\tchar[] seq = this.getSequence(sequence.toString(), true);\n\t\tfor(char aa:seq){\n\t\t\tif(PeptideProperties.standardAASet.contains(aa)){\n\t\t\t\tAminoAcidCompound compound = aaSet.getCompoundForString(String.valueOf(aa));\n\t\t\t\taa2Composition.put(compound, aa2Composition.get(compound) + 1.0);\n\t\t\t\tvalidLength++;\n\t\t\t}\n\t\t}\n\t\tif(validLength > 0){\n\t\t\tfor(AminoAcidCompound aa:aaSet.getAllCompounds()){\n\t\t\t\taa2Composition.put(aa, aa2Composition.get(aa) / validLength);\n\t\t\t}\n\t\t}else{\n\t\t\tfor(AminoAcidCompound aa:aaSet.getAllCompounds()){\n\t\t\t\taa2Composition.put(aa, 0.0);\n\t\t\t}\n\t\t}\n\t\treturn aa2Composition;\n\t}\n\n\n\t@Override\n\tpublic double getAromaticity(ProteinSequence sequence) {\n\t\tint validLength = sequence.getSequenceAsString().length();\n\n\t\tif (validLength == 0) {\n\t\t\tlogger.warn(\"Valid length of sequence is 0, can't divide by 0 to calculate aromaticity: setting aromaticity to 0\");\n\t\t\treturn 0.0;\n\t\t}\n\n\t\t\n\t\tint totalF = 0;\n\t\t\n\t\tint totalY = 0;\n\t\t\n\t\tint totalW = 0;\n\n\t\tchar[] seq = this.getSequence(sequence.toString(), true);\n\t\tfor (char aa : seq) {\n\t\t\tchar amino = Character.toUpperCase(aa);\n\t\t\tswitch (amino) {\n\t\t\t\tcase 'F':\n\t\t\t\t\ttotalF++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Y':\n\t\t\t\t\ttotalY++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'W':\n\t\t\t\t\ttotalW++;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn (totalF + totalY + totalW) / (double) (validLength);\n\t}\n}\n\n"
    ],
    "1": [
        "package org.biojava.nbio.aaproperties;\n\nimport org.biojava.nbio.aaproperties.xml.AminoAcidCompositionTable;\nimport org.biojava.nbio.aaproperties.xml.ElementTable;\nimport org.biojava.nbio.aaproperties.xml.MyValidationEventHandler;\nimport org.biojava.nbio.core.sequence.ProteinSequence;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompound;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompoundSet;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport jakarta.xml.bind.JAXBContext;\nimport jakarta.xml.bind.JAXBException;\nimport jakarta.xml.bind.Unmarshaller;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class PeptidePropertiesImpl implements IPeptideProperties {\n\n    private final static Logger logger = LoggerFactory.getLogger(PeptidePropertiesImpl.class);\n\n    \n    private static final AminoAcidCompoundSet AA_SET = new AminoAcidCompoundSet();\n    private static final Map<Character, AminoAcidCompound> AA_CHAR_TO_COMPOUND = new HashMap<>();\n    static {\n        for(char aa : PeptideProperties.standardAASet) {\n            AA_CHAR_TO_COMPOUND.put(aa, AA_SET.getCompoundForString(String.valueOf(aa)));\n            AA_CHAR_TO_COMPOUND.put(Character.toLowerCase(aa), AA_SET.getCompoundForString(String.valueOf(aa)));\n        }\n    }\n\n    private double getWaterMoleculeWeight(){\n        final double hydrogenMW = 1.0079;\n        final double hydroxideMW = 17.0073;\n        return hydrogenMW + hydroxideMW;\n    }\n\n    private char[] getSequence(String sequence, boolean ignoreCase){\n        if(ignoreCase){\n            return sequence.toUpperCase().toCharArray();\n        }else{\n            return sequence.toCharArray();\n        }\n    }\n\n    @Override\n    public double getMolecularWeight(ProteinSequence sequence) {\n        double value = 0.0;\n        char[] seq = getSequence(sequence.toString(), true);\n        for(char aa:seq){\n            AminoAcidCompound c = AA_CHAR_TO_COMPOUND.get(aa);\n            if(c != null && Constraints.aa2MolecularWeight.containsKey(c)){\n                value += Constraints.aa2MolecularWeight.get(c);\n            }\n        }\n        if(value == 0)\n            return value;\n        else\n            return value + getWaterMoleculeWeight();\n    }\n\n    @Override\n    public double getMolecularWeight(ProteinSequence sequence, File aminoAcidCompositionFile) throws JAXBException, FileNotFoundException {\n        File elementMassFile = new File(\"./src/main/resources/ElementMass.xml\");\n        if(!elementMassFile.exists()){\n            throw new FileNotFoundException(\"Cannot locate ElementMass.xml. \" +\n                    \"Please use getMolecularWeight(ProteinSequence, File, File) to specify ElementMass.xml location.\");\n        }\n        return getMolecularWeightBasedOnXML(sequence, obtainAminoAcidCompositionTable(elementMassFile, aminoAcidCompositionFile));\n    }\n\n    @Override\n    public double getMolecularWeight(ProteinSequence sequence, File elementMassFile, File aminoAcidCompositionFile)\n            throws JAXBException, FileNotFoundException{\n        return getMolecularWeightBasedOnXML(sequence, obtainAminoAcidCompositionTable(elementMassFile, aminoAcidCompositionFile));\n    }\n\n    @Override\n    public double getMolecularWeightBasedOnXML(ProteinSequence sequence, AminoAcidCompositionTable aminoAcidCompositionTable){\n        double value = 0.0;\n        char[] seq = sequence.toString().toCharArray();\n        for(char aa:seq){\n            Double weight = aminoAcidCompositionTable.getMolecularWeight(aa);\n            if(weight != null){\n                value += weight;\n            }\n        }\n        if(value == 0.0)\n            return value;\n        else\n            return value + getWaterMoleculeWeight();\n    }\n\n    @Override\n    public AminoAcidCompositionTable obtainAminoAcidCompositionTable(File aminoAcidCompositionFile)\n        throws JAXBException, FileNotFoundException{\n        File elementMassFile = new File(\"./src/main/resources/ElementMass.xml\");\n        if(!elementMassFile.exists()){\n            throw new FileNotFoundException(\"Cannot locate ElementMass.xml. \" +\n                    \"Please use getMolecularWeight(ProteinSequence, File, File) to specify ElementMass.xml location.\");\n        }\n        return obtainAminoAcidCompositionTable(elementMassFile, aminoAcidCompositionFile);\n    }\n\n    @Override\n    public AminoAcidCompositionTable obtainAminoAcidCompositionTable(File elementMassFile, File aminoAcidCompositionFile)\n        throws JAXBException, FileNotFoundException{\n        ElementTable iTable = new ElementTable();\n        JAXBContext jc = JAXBContext.newInstance(iTable.getClass());\n        Unmarshaller u = jc.createUnmarshaller();\n        u.setEventHandler(new MyValidationEventHandler());\n        iTable = (ElementTable)u.unmarshal(new FileInputStream(elementMassFile));\n        iTable.populateMaps();\n        AminoAcidCompositionTable aTable = new AminoAcidCompositionTable();\n        JAXBContext jc2 = JAXBContext.newInstance(aTable.getClass());\n        Unmarshaller u2 = jc2.createUnmarshaller();\n        u2.setEventHandler(new MyValidationEventHandler());\n        aTable = (AminoAcidCompositionTable)u2.unmarshal(new FileInputStream(aminoAcidCompositionFile));\n        aTable.computeMolecularWeight(iTable);\n        return aTable;\n    }\n\n    @Override\n    public double getExtinctionCoefficient(ProteinSequence sequence, boolean assumeCysReduced) {\n        Map<AminoAcidCompound, Integer> extinctAA2Count = this.getExtinctAACount(sequence);\n        double eProt;\n        if(!assumeCysReduced){\n            eProt = extinctAA2Count.get(AA_CHAR_TO_COMPOUND.get('Y')) *\n                Constraints.aa2ExtinctionCoefficient.get(AA_CHAR_TO_COMPOUND.get('Y')) +\n                extinctAA2Count.get(AA_CHAR_TO_COMPOUND.get('W')) *\n                Constraints.aa2ExtinctionCoefficient.get(AA_CHAR_TO_COMPOUND.get('W')) +\n                extinctAA2Count.get(AA_CHAR_TO_COMPOUND.get('C')) *\n                Constraints.aa2ExtinctionCoefficient.get(AA_CHAR_TO_COMPOUND.get('C'));\n        }else {\n            eProt = extinctAA2Count.get(AA_CHAR_TO_COMPOUND.get('Y')) *\n                Constraints.aa2ExtinctionCoefficient.get(AA_CHAR_TO_COMPOUND.get('Y')) +\n                extinctAA2Count.get(AA_CHAR_TO_COMPOUND.get('W')) *\n                Constraints.aa2ExtinctionCoefficient.get(AA_CHAR_TO_COMPOUND.get('W'));\n        }\n        return eProt;\n    }\n\n    @Override\n    public double getAbsorbance(ProteinSequence sequence, boolean assumeCysReduced){\n        double mw = this.getMolecularWeight(sequence);\n        double eProt = this.getExtinctionCoefficient(sequence, assumeCysReduced);\n        if (mw == 0.0) {\n            logger.warn(\"Molecular weight is 0.0, can't divide by 0: setting absorbance to 0.0\");\n            return 0.0;\n        }\n        return eProt / mw;\n    }\n\n    \n    private Map<AminoAcidCompound, Integer> getExtinctAACount(ProteinSequence sequence){\n        int numW = 0;\n        int smallW = 0;\n        double numC = 0;\n        double smallC = 0;\n        int numY = 0;\n        int smallY = 0;\n        for(char aa:sequence.getSequenceAsString().toCharArray()){\n            switch(aa){\n                case 'W': numW++; break;\n                case 'w': smallW++; break;\n                case 'C': numC += 0.5; break;\n                case 'c': smallC += 0.5; break;\n                case 'Y': numY++; break;\n                case 'y': smallY++; break;\n            }\n        }\n        Map<AminoAcidCompound, Integer> extinctAA2Count = new HashMap<>();\n        extinctAA2Count.put(AA_CHAR_TO_COMPOUND.get('W'), numW + smallW);\n        extinctAA2Count.put(AA_CHAR_TO_COMPOUND.get('C'), (int)(numC + smallC));\n        extinctAA2Count.put(AA_CHAR_TO_COMPOUND.get('Y'), numY + smallY);\n        return extinctAA2Count;\n    }\n\n    @Override\n    public double getInstabilityIndex(ProteinSequence sequence) {\n        double sum = 0.0;\n        String s = sequence.getSequenceAsString().toUpperCase();\n        for(int i = 0; i < sequence.getLength() - 1; i++){\n            String dipeptide = s.substring(i, i+2);\n            if(Constraints.diAA2Instability.containsKey(dipeptide)){\n                sum += Constraints.diAA2Instability.get(dipeptide);\n            }\n        }\n        int denominator = s.length() - Utils.getNumberOfInvalidChar(s, null, true);\n        if (denominator==0) {\n            logger.warn(\"Valid length of sequence is 0, can't divide by 0 to calculate instability index: setting instability index value to 0.0\");\n            return 0.0;\n        }\n        return sum * 10.0 / denominator;\n    }\n\n    @Override\n    public double getApliphaticIndex(ProteinSequence sequence) {\n        Map<AminoAcidCompound, Double> aa2Composition = getAAComposition(sequence);\n        final double a = 2.9;\n        final double b = 3.9;\n        double xAla = aa2Composition.get(AA_CHAR_TO_COMPOUND.get('A'));\n        double xVal = aa2Composition.get(AA_CHAR_TO_COMPOUND.get('V'));\n        double xIle = aa2Composition.get(AA_CHAR_TO_COMPOUND.get('I'));\n        double xLeu = aa2Composition.get(AA_CHAR_TO_COMPOUND.get('L'));\n        return (xAla + (a * xVal) + (b * (xIle + xLeu))) * 100;\n    }\n\n    @Override\n    public double getAvgHydropathy(ProteinSequence sequence) {\n        int validLength = 0;\n        double total = 0.0;\n        char[] seq = this.getSequence(sequence.toString(), true);\n        for(char aa:seq){\n            AminoAcidCompound c = AA_CHAR_TO_COMPOUND.get(aa);\n            if(c != null && Constraints.aa2Hydrophathicity.containsKey(c)){\n                total += Constraints.aa2Hydrophathicity.get(c);\n                validLength++;\n            }\n        }\n        if (validLength==0) {\n            logger.warn(\"Valid length of sequence is 0, can't divide by 0 to calculate average hydropathy: setting average hydropathy to 0\");\n            return 0.0;\n        }\n        return total / validLength;\n    }\n\n    @Override\n    public double getIsoelectricPoint(ProteinSequence sequence, boolean useExpasyValues) {\n        if(useExpasyValues){\n            return this.getIsoelectricPointExpasy(sequence.toString().toUpperCase());\n        }else{\n            return this.getIsoelectricPointInnovagen(sequence);\n        }\n    }\n\n    \n\n    private final double[][] cPk = {\n        {3.55, 7.59, 0.0},  {3.55, 7.50, 0.0},  {3.55, 7.50, 9.00},\n        {3.55, 7.50, 4.05}, {3.55, 7.70, 4.45}, {3.55, 7.50, 0},\n        {3.55, 7.50, 0},    {3.55, 7.50, 5.98},{3.55, 7.50, 0.0},\n        {0.0, 0.0, 0.0},    {3.55, 7.50, 10.00},{3.55, 7.50, 0.0},\n        {3.55, 7.00, 0.0},  {3.55, 7.50, 0.0},  {0.00, 0.00, 0.0},\n        {3.55, 8.36, 0.0},  {3.55, 7.50, 0.0},  {3.55, 7.50, 12.0},\n        {3.55, 6.93, 0.0},  {3.55, 6.82, 0.0},  {0.00, 0.00, 0.0},\n        {3.55, 7.44, 0.0},  {3.55, 7.50, 0.0},  {3.55, 7.50, 0.0},\n        {3.55, 7.50, 10.00},{3.55, 7.50, 0.0}\n    };\n    private final double PH_MIN = 0.0;\n    private final double PH_MAX = 14.0;\n    private final double MAXLOOP = 2000.0;\n    private final double EPSI = 0.0001;\n\n    private double exp10(double pka){\n        return Math.pow(10, pka);\n    }\n\n    private double getIsoelectricPointExpasy(String sequence){\n        int[] comp = new int[26];\n        for(int i = 0; i < sequence.length(); i++){\n            int index = sequence.charAt(i) - 'A';\n            if(index < 0 || index >= 26) continue;\n            comp[index]++;\n        }\n        int nTermResidue = -1;\n        int index = 0;\n        while((nTermResidue < 0 || nTermResidue >= 26) && index < 25){\n            nTermResidue = sequence.charAt(index++) - 'A';\n        }\n        int cTermResidue = -1;\n        index = 1;\n        while((cTermResidue < 0 || cTermResidue >= 26) && index < 25){\n            cTermResidue = sequence.charAt(sequence.length() - index++) - 'A';\n        }\n        double phMin = PH_MIN;\n        double phMax = PH_MAX;\n        double phMid = 0.0;\n        double charge = 1.0;\n        for (int i = 0; i < MAXLOOP && (phMax - phMin) > EPSI; i++){\n            phMid = phMin + (phMax - phMin) / 2.0;\n            charge = getNetChargeExpasy(comp, nTermResidue, cTermResidue, phMid);\n            if (charge > 0.0) phMin = phMid;\n            else phMax = phMid;\n        }\n        return phMid;\n    }\n\n    private double getIsoelectricPointInnovagen(ProteinSequence sequence){\n        double currentPH = 7.0;\n        double changeSize = 7.0;\n        String sequenceString = sequence.toString();\n        char nTerminalChar = sequenceString.charAt(0);\n        char cTerminalChar = sequenceString.charAt(sequenceString.length() - 1);\n        Map<AminoAcidCompound, Integer> chargedAA2Count = this.getChargedAACount(sequence);\n        double margin;\n        final double difference = 0.0001;\n        while(true){\n            margin = this.getNetChargeInnovagen(chargedAA2Count, currentPH, nTerminalChar, cTerminalChar);\n            if(margin <= difference && margin >= -difference) break;\n            changeSize /= 2.0;\n            if(margin > 0){\n                currentPH += changeSize;\n            }else{\n                currentPH -= changeSize;\n            }\n        }\n        return currentPH;\n    }\n\n    @Override\n    public double getIsoelectricPoint(ProteinSequence sequence){\n        return getIsoelectricPoint(sequence, true);\n    }\n\n    @Override\n    public double getNetCharge(ProteinSequence sequence) {\n        return getNetCharge(sequence, true);\n    }\n\n    @Override\n    public double getNetCharge(ProteinSequence sequence, boolean useExpasyValues){\n        return getNetCharge(sequence, true, 7.0);\n    }\n\n    @Override\n    public double getNetCharge(ProteinSequence sequence, boolean useExpasyValues, double pHPoint){\n        if(useExpasyValues){\n            return getNetChargeExpasy(sequence.toString().toUpperCase(), pHPoint);\n        }else{\n            return getNetChargeInnovagen(sequence, pHPoint);\n        }\n    }\n\n    private double getNetChargeExpasy(String sequence, double pHPoint){\n        int[] comp = new int[26];\n        for(int i = 0; i < sequence.length(); i++){\n            int index = sequence.charAt(i) - 'A';\n            if(index < 0 || index >= 26) continue;\n            comp[index]++;\n        }\n        int nTermResidue = sequence.charAt(0) - 'A';\n        int cTermResidue = sequence.charAt(sequence.length() - 1) - 'A';\n        return getNetChargeExpasy(comp, nTermResidue, cTermResidue, pHPoint);\n    }\n\n    private double getNetChargeExpasy(int[] comp, int nTermResidue, int cTermResidue, double ph){\n        double cter = 0.0;\n        if(cTermResidue >= 0 && cTermResidue < 26) cter = exp10(-cPk[cTermResidue][0]) / (exp10(-cPk[cTermResidue][0]) + exp10(-ph));\n        double nter = 0.0;\n        if(nTermResidue >= 0 && nTermResidue < 26) nter = exp10(-ph) / (exp10(-cPk[nTermResidue][1]) + exp10(-ph));\n        double carg = comp['R' - 'A'] * exp10(-ph) / (exp10(-cPk['R' - 'A'][2]) + exp10(-ph));\n        double chis = comp['H' - 'A'] * exp10(-ph) / (exp10(-cPk['H' - 'A'][2]) + exp10(-ph));\n        double clys = comp['K' - 'A'] * exp10(-ph) / (exp10(-cPk['K' - 'A'][2]) + exp10(-ph));\n        double casp = comp['D' - 'A'] * exp10(-cPk['D' - 'A'][2]) / (exp10(-cPk['D' - 'A'][2]) + exp10(-ph));\n        double cglu = comp['E' - 'A'] * exp10(-cPk['E' - 'A'][2]) / (exp10(-cPk['E' - 'A'][2]) + exp10(-ph));\n        double ccys = comp['C' - 'A'] * exp10(-cPk['C' - 'A'][2]) / (exp10(-cPk['C' - 'A'][2]) + exp10(-ph));\n        double ctyr = comp['Y' - 'A'] * exp10(-cPk['Y' - 'A'][2]) / (exp10(-cPk['Y' - 'A'][2]) + exp10(-ph));\n        return (carg + clys + chis + nter) - (casp + cglu + ctyr + ccys + cter);\n    }\n\n    private double getNetChargeInnovagen(ProteinSequence sequence, double pHPoint) {\n        Map<AminoAcidCompound, Integer> chargedAA2Count = this.getChargedAACount(sequence);\n        String sequenceString = sequence.getSequenceAsString();\n        return getNetChargeInnovagen(chargedAA2Count, pHPoint, sequenceString.charAt(0), sequenceString.charAt(sequenceString.length() - 1));\n    }\n\n    private double getNetChargeInnovagen(Map<AminoAcidCompound, Integer> chargedAA2Count, double ph, char nTerminalChar, char cTerminalChar){\n        AminoAcidCompound nTermCompound = AA_CHAR_TO_COMPOUND.get(nTerminalChar);\n        double nTerminalCharge = 0.0;\n        if(nTermCompound != null && Constraints.aa2NTerminalPka.containsKey(nTermCompound)){\n            nTerminalCharge = this.getPosCharge(Constraints.aa2NTerminalPka.get(nTermCompound), ph);\n        }\n        AminoAcidCompound cTermCompound = AA_CHAR_TO_COMPOUND.get(cTerminalChar);\n        double cTerminalCharge = 0.0;\n        if(cTermCompound != null && Constraints.aa2CTerminalPka.containsKey(cTermCompound)){\n            cTerminalCharge = this.getNegCharge(Constraints.aa2CTerminalPka.get(cTermCompound), ph);\n        }\n        double kCharge = chargedAA2Count.get(AA_CHAR_TO_COMPOUND.get('K')) * this.getPosCharge(Constraints.aa2PKa.get(AA_CHAR_TO_COMPOUND.get('K')), ph);\n        double rCharge = chargedAA2Count.get(AA_CHAR_TO_COMPOUND.get('R')) * this.getPosCharge(Constraints.aa2PKa.get(AA_CHAR_TO_COMPOUND.get('R')), ph);\n        double hCharge = chargedAA2Count.get(AA_CHAR_TO_COMPOUND.get('H')) * this.getPosCharge(Constraints.aa2PKa.get(AA_CHAR_TO_COMPOUND.get('H')), ph);\n        double dCharge = chargedAA2Count.get(AA_CHAR_TO_COMPOUND.get('D')) * this.getNegCharge(Constraints.aa2PKa.get(AA_CHAR_TO_COMPOUND.get('D')), ph);\n        double eCharge = chargedAA2Count.get(AA_CHAR_TO_COMPOUND.get('E')) * this.getNegCharge(Constraints.aa2PKa.get(AA_CHAR_TO_COMPOUND.get('E')), ph);\n        double cCharge = chargedAA2Count.get(AA_CHAR_TO_COMPOUND.get('C')) * this.getNegCharge(Constraints.aa2PKa.get(AA_CHAR_TO_COMPOUND.get('C')), ph);\n        double yCharge = chargedAA2Count.get(AA_CHAR_TO_COMPOUND.get('Y')) * this.getNegCharge(Constraints.aa2PKa.get(AA_CHAR_TO_COMPOUND.get('Y')), ph);\n        return (nTerminalCharge + kCharge + rCharge + hCharge) - (dCharge + eCharge + cCharge + yCharge + cTerminalCharge);\n    }\n\n    private double getPosCharge(double pka, double ph){\n        return Math.pow(10, pka) / (Math.pow(10, pka) + Math.pow(10, ph));\n    }\n\n    private double getNegCharge(double pka, double ph){\n        return Math.pow(10, ph) / (Math.pow(10, pka) + Math.pow(10, ph));\n    }\n\n    private Map<AminoAcidCompound, Integer> getChargedAACount(ProteinSequence sequence){\n        int numK = 0, numR = 0, numH = 0, numD = 0, numE = 0, numC = 0, numY = 0;\n        char[] seq = this.getSequence(sequence.getSequenceAsString(), true);\n        for(char aa:seq){\n            switch(aa){\n                case 'K': numK++; break;\n                case 'R': numR++; break;\n                case 'H': numH++; break;\n                case 'D': numD++; break;\n                case 'E': numE++; break;\n                case 'C': numC++; break;\n                case 'Y': numY++; break;\n            }\n        }\n        Map<AminoAcidCompound, Integer> chargedAA2Count = new HashMap<>();\n        chargedAA2Count.put(AA_CHAR_TO_COMPOUND.get('K'), numK);\n        chargedAA2Count.put(AA_CHAR_TO_COMPOUND.get('R'), numR);\n        chargedAA2Count.put(AA_CHAR_TO_COMPOUND.get('H'), numH);\n        chargedAA2Count.put(AA_CHAR_TO_COMPOUND.get('D'), numD);\n        chargedAA2Count.put(AA_CHAR_TO_COMPOUND.get('E'), numE);\n        chargedAA2Count.put(AA_CHAR_TO_COMPOUND.get('C'), numC);\n        chargedAA2Count.put(AA_CHAR_TO_COMPOUND.get('Y'), numY);\n        return chargedAA2Count;\n    }\n\n    @Override\n    public double getEnrichment(ProteinSequence sequence, AminoAcidCompound aminoAcidCode) {\n        double counter = 0.0;\n        char[] seq = this.getSequence(sequence.getSequenceAsString(), true);\n        String aaShort = aminoAcidCode.getShortName();\n        for(char aa:seq){\n            if(aaShort.equals(String.valueOf(aa))){\n                counter++;\n            }\n        }\n        return counter/sequence.getLength();\n    }\n\n    @Override\n    public Map<AminoAcidCompound, Double> getAAComposition(ProteinSequence sequence) {\n        int validLength = 0;\n        double[] counts = new double[26]; \n        char[] seq = this.getSequence(sequence.toString(), true);\n        for(char aa: seq){\n            if(PeptideProperties.standardAASet.contains(aa)){\n                int idx = Character.toUpperCase(aa) - 'A';\n                if(idx >= 0 && idx < counts.length) {\n                    counts[idx]++;\n                    validLength++;\n                }\n            }\n        }\n        Map<AminoAcidCompound, Double> aa2Composition = new HashMap<>();\n        for(char aa : PeptideProperties.standardAASet) {\n            AminoAcidCompound compound = AA_CHAR_TO_COMPOUND.get(aa);\n            int idx = Character.toUpperCase(aa) - 'A';\n            double v = (validLength > 0) ? counts[idx] / validLength : 0.0;\n            aa2Composition.put(compound, v);\n        }\n        return aa2Composition;\n    }\n\n    @Override\n    public double getAromaticity(ProteinSequence sequence) {\n        int validLength = sequence.getSequenceAsString().length();\n        if (validLength == 0) {\n            logger.warn(\"Valid length of sequence is 0, can't divide by 0 to calculate aromaticity: setting aromaticity to 0\");\n            return 0.0;\n        }\n        int totalF = 0, totalY = 0, totalW = 0;\n        char[] seq = this.getSequence(sequence.toString(), true);\n        for (char aa : seq) {\n            switch (Character.toUpperCase(aa)) {\n                case 'F': totalF++; break;\n                case 'Y': totalY++; break;\n                case 'W': totalW++; break;\n            }\n        }\n        return (totalF + totalY + totalW) / (double) (validLength);\n    }\n\n}\n"
    ],
    "2": [
        "package org.biojava.nbio.aaproperties;\n\nimport org.biojava.nbio.aaproperties.xml.AminoAcidCompositionTable;\nimport org.biojava.nbio.aaproperties.xml.ElementTable;\nimport org.biojava.nbio.aaproperties.xml.MyValidationEventHandler;\nimport org.biojava.nbio.core.sequence.ProteinSequence;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompound;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompoundSet;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport jakarta.xml.bind.JAXBContext;\nimport jakarta.xml.bind.JAXBException;\nimport jakarta.xml.bind.Unmarshaller;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class PeptidePropertiesImpl implements IPeptideProperties {\n\n    private final static Logger logger = LoggerFactory.getLogger(PeptidePropertiesImpl.class);\n\n    private static final AminoAcidCompoundSet AA_SET = new AminoAcidCompoundSet();\n    private static final Map<Character, AminoAcidCompound> AA_CHAR_TO_COMPOUND = new HashMap<>();\n    static {\n        for(char aa : PeptideProperties.standardAASet) {\n            AA_CHAR_TO_COMPOUND.put(aa, AA_SET.getCompoundForString(String.valueOf(aa)));\n            AA_CHAR_TO_COMPOUND.put(Character.toLowerCase(aa), AA_SET.getCompoundForString(String.valueOf(aa)));\n        }\n    }\n    \n    private static final double[] AA_MOLECULAR_WEIGHT = new double[26];\n    private static final double[] AA_HYDROPATHY = new double[26];\n    private static final double[] AA_EXTINCTION_COEFF = new double[26];\n    private static final double[][] DIPEPTIDE_INSTABILITY = new double[26][26];\n    static {\n        \n        for(char aa : PeptideProperties.standardAASet) {\n            AminoAcidCompound comp = AA_CHAR_TO_COMPOUND.get(aa);\n            int idx = Character.toUpperCase(aa) - 'A';\n            AA_MOLECULAR_WEIGHT[idx] = Constraints.aa2MolecularWeight.getOrDefault(comp, 0.0);\n            AA_HYDROPATHY[idx] = Constraints.aa2Hydrophathicity.getOrDefault(comp, 0.0);\n            AA_EXTINCTION_COEFF[idx] = Constraints.aa2ExtinctionCoefficient.getOrDefault(comp, 0.0);\n        }\n        \n        for(Map.Entry<String, Double> entry : Constraints.diAA2Instability.entrySet()) {\n            String key = entry.getKey();\n            if(key.length() == 2) {\n                char a1 = key.charAt(0);\n                char a2 = key.charAt(1);\n                int i = Character.toUpperCase(a1) - 'A';\n                int j = Character.toUpperCase(a2) - 'A';\n                if(i >= 0 && i < 26 && j >= 0 && j < 26) {\n                    DIPEPTIDE_INSTABILITY[i][j] = entry.getValue();\n                }\n            }\n        }\n    }\n\n    private double getWaterMoleculeWeight(){\n        final double hydrogenMW = 1.0079;\n        final double hydroxideMW = 17.0073;\n        return hydrogenMW + hydroxideMW;\n    }\n\n    private char[] getSequence(String sequence, boolean ignoreCase){\n        if(ignoreCase){\n            return sequence.toUpperCase().toCharArray();\n        }else{\n            return sequence.toCharArray();\n        }\n    }\n\n    @Override\n    public double getMolecularWeight(ProteinSequence sequence) {\n        double value = 0.0;\n        char[] seq = getSequence(sequence.toString(), true);\n        for(char aa:seq){\n            int idx = Character.toUpperCase(aa) - 'A';\n            if(idx >= 0 && idx < 26){\n                value += AA_MOLECULAR_WEIGHT[idx];\n            }\n        }\n        if(value == 0)\n            return value;\n        else\n            return value + getWaterMoleculeWeight();\n    }\n\n    @Override\n    public double getMolecularWeight(ProteinSequence sequence, File aminoAcidCompositionFile) throws JAXBException, FileNotFoundException {\n        File elementMassFile = new File(\"./src/main/resources/ElementMass.xml\");\n        if(!elementMassFile.exists()){\n            throw new FileNotFoundException(\"Cannot locate ElementMass.xml. \" +\n                    \"Please use getMolecularWeight(ProteinSequence, File, File) to specify ElementMass.xml location.\");\n        }\n        return getMolecularWeightBasedOnXML(sequence, obtainAminoAcidCompositionTable(elementMassFile, aminoAcidCompositionFile));\n    }\n\n    @Override\n    public double getMolecularWeight(ProteinSequence sequence, File elementMassFile, File aminoAcidCompositionFile)\n            throws JAXBException, FileNotFoundException{\n        return getMolecularWeightBasedOnXML(sequence, obtainAminoAcidCompositionTable(elementMassFile, aminoAcidCompositionFile));\n    }\n\n    @Override\n    public double getMolecularWeightBasedOnXML(ProteinSequence sequence, AminoAcidCompositionTable aminoAcidCompositionTable){\n        double value = 0.0;\n        char[] seq = sequence.toString().toCharArray();\n        for(char aa:seq){\n            Double weight = aminoAcidCompositionTable.getMolecularWeight(aa);\n            if(weight != null){\n                value += weight;\n            }\n        }\n        if(value == 0.0)\n            return value;\n        else\n            return value + getWaterMoleculeWeight();\n    }\n\n    @Override\n    public AminoAcidCompositionTable obtainAminoAcidCompositionTable(File aminoAcidCompositionFile)\n        throws JAXBException, FileNotFoundException{\n        File elementMassFile = new File(\"./src/main/resources/ElementMass.xml\");\n        if(!elementMassFile.exists()){\n            throw new FileNotFoundException(\"Cannot locate ElementMass.xml. \" +\n                    \"Please use getMolecularWeight(ProteinSequence, File, File) to specify ElementMass.xml location.\");\n        }\n        return obtainAminoAcidCompositionTable(elementMassFile, aminoAcidCompositionFile);\n    }\n\n    @Override\n    public AminoAcidCompositionTable obtainAminoAcidCompositionTable(File elementMassFile, File aminoAcidCompositionFile)\n        throws JAXBException, FileNotFoundException{\n        ElementTable iTable = new ElementTable();\n        JAXBContext jc = JAXBContext.newInstance(iTable.getClass());\n        Unmarshaller u = jc.createUnmarshaller();\n        u.setEventHandler(new MyValidationEventHandler());\n        iTable = (ElementTable)u.unmarshal(new FileInputStream(elementMassFile));\n        iTable.populateMaps();\n        AminoAcidCompositionTable aTable = new AminoAcidCompositionTable();\n        JAXBContext jc2 = JAXBContext.newInstance(aTable.getClass());\n        Unmarshaller u2 = jc2.createUnmarshaller();\n        u2.setEventHandler(new MyValidationEventHandler());\n        aTable = (AminoAcidCompositionTable)u2.unmarshal(new FileInputStream(aminoAcidCompositionFile));\n        aTable.computeMolecularWeight(iTable);\n        return aTable;\n    }\n\n    @Override\n    public double getExtinctionCoefficient(ProteinSequence sequence, boolean assumeCysReduced) {\n        Map<AminoAcidCompound, Integer> extinctAA2Count = this.getExtinctAACount(sequence);\n        double eProt;\n        if(!assumeCysReduced){\n            eProt = extinctAA2Count.get(AA_CHAR_TO_COMPOUND.get('Y')) *\n                AA_EXTINCTION_COEFF['Y'-'A'] +\n                extinctAA2Count.get(AA_CHAR_TO_COMPOUND.get('W')) *\n                AA_EXTINCTION_COEFF['W'-'A'] +\n                extinctAA2Count.get(AA_CHAR_TO_COMPOUND.get('C')) *\n                AA_EXTINCTION_COEFF['C'-'A'];\n        }else {\n            eProt = extinctAA2Count.get(AA_CHAR_TO_COMPOUND.get('Y')) *\n                AA_EXTINCTION_COEFF['Y'-'A'] +\n                extinctAA2Count.get(AA_CHAR_TO_COMPOUND.get('W')) *\n                AA_EXTINCTION_COEFF['W'-'A'];\n        }\n        return eProt;\n    }\n\n    @Override\n    public double getAbsorbance(ProteinSequence sequence, boolean assumeCysReduced){\n        double mw = this.getMolecularWeight(sequence);\n        double eProt = this.getExtinctionCoefficient(sequence, assumeCysReduced);\n        if (mw == 0.0) {\n            logger.warn(\"Molecular weight is 0.0, can't divide by 0: setting absorbance to 0.0\");\n            return 0.0;\n        }\n        return eProt / mw;\n    }\n\n    \n    private Map<AminoAcidCompound, Integer> getExtinctAACount(ProteinSequence sequence){\n        int numW = 0;\n        int smallW = 0;\n        double numC = 0;\n        double smallC = 0;\n        int numY = 0;\n        int smallY = 0;\n        char[] seq = sequence.getSequenceAsString().toCharArray();\n        for(char aa:seq){\n            switch(aa){\n                case 'W': numW++; break;\n                case 'w': smallW++; break;\n                case 'C': numC += 0.5; break;\n                case 'c': smallC += 0.5; break;\n                case 'Y': numY++; break;\n                case 'y': smallY++; break;\n            }\n        }\n        Map<AminoAcidCompound, Integer> extinctAA2Count = new HashMap<>();\n        extinctAA2Count.put(AA_CHAR_TO_COMPOUND.get('W'), numW + smallW);\n        extinctAA2Count.put(AA_CHAR_TO_COMPOUND.get('C'), (int)(numC + smallC));\n        extinctAA2Count.put(AA_CHAR_TO_COMPOUND.get('Y'), numY + smallY);\n        return extinctAA2Count;\n    }\n\n    @Override\n    public double getInstabilityIndex(ProteinSequence sequence) {\n        double sum = 0.0;\n        String s = sequence.getSequenceAsString().toUpperCase();\n        int n = s.length();\n        for(int i = 0; i < n - 1; i++){\n            char aa1 = s.charAt(i);\n            char aa2 = s.charAt(i+1);\n            int idx1 = aa1 - 'A';\n            int idx2 = aa2 - 'A';\n            if(idx1 >= 0 && idx1 < 26 && idx2 >= 0 && idx2 < 26){\n                sum += DIPEPTIDE_INSTABILITY[idx1][idx2];\n            }\n        }\n        int denominator = n - Utils.getNumberOfInvalidChar(s, null, true);\n        if (denominator==0) {\n            logger.warn(\"Valid length of sequence is 0, can't divide by 0 to calculate instability index: setting instability index value to 0.0\");\n            return 0.0;\n        }\n        return sum * 10.0 / denominator;\n    }\n\n    @Override\n    public double getApliphaticIndex(ProteinSequence sequence) {\n        Map<AminoAcidCompound, Double> aa2Composition = getAAComposition(sequence);\n        final double a = 2.9;\n        final double b = 3.9;\n        double xAla = aa2Composition.get(AA_CHAR_TO_COMPOUND.get('A'));\n        double xVal = aa2Composition.get(AA_CHAR_TO_COMPOUND.get('V'));\n        double xIle = aa2Composition.get(AA_CHAR_TO_COMPOUND.get('I'));\n        double xLeu = aa2Composition.get(AA_CHAR_TO_COMPOUND.get('L'));\n        return (xAla + (a * xVal) + (b * (xIle + xLeu))) * 100;\n    }\n\n    @Override\n    public double getAvgHydropathy(ProteinSequence sequence) {\n        int validLength = 0;\n        double total = 0.0;\n        char[] seq = this.getSequence(sequence.toString(), true);\n        for(char aa:seq){\n            int idx = Character.toUpperCase(aa) - 'A';\n            if(idx >= 0 && idx < 26){\n                total += AA_HYDROPATHY[idx];\n                validLength++;\n            }\n        }\n        if (validLength==0) {\n            logger.warn(\"Valid length of sequence is 0, can't divide by 0 to calculate average hydropathy: setting average hydropathy to 0\");\n            return 0.0;\n        }\n        return total / validLength;\n    }\n\n    @Override\n    public double getIsoelectricPoint(ProteinSequence sequence, boolean useExpasyValues) {\n        if(useExpasyValues){\n            return this.getIsoelectricPointExpasy(sequence.toString().toUpperCase());\n        }else{\n            return this.getIsoelectricPointInnovagen(sequence);\n        }\n    }\n\n    \n    private final double[][] cPk = {\n        {3.55, 7.59, 0.0},  {3.55, 7.50, 0.0},  {3.55, 7.50, 9.00},\n        {3.55, 7.50, 4.05}, {3.55, 7.70, 4.45}, {3.55, 7.50, 0},\n        {3.55, 7.50, 0},    {3.55, 7.50, 5.98},{3.55, 7.50, 0.0},\n        {0.0, 0.0, 0.0},    {3.55, 7.50, 10.00},{3.55, 7.50, 0.0},\n        {3.55, 7.00, 0.0},  {3.55, 7.50, 0.0},  {0.00, 0.00, 0.0},\n        {3.55, 8.36, 0.0},  {3.55, 7.50, 0.0},  {3.55, 7.50, 12.0},\n        {3.55, 6.93, 0.0},  {3.55, 6.82, 0.0},  {0.00, 0.00, 0.0},\n        {3.55, 7.44, 0.0},  {3.55, 7.50, 0.0},  {3.55, 7.50, 0.0},\n        {3.55, 7.50, 10.00},{3.55, 7.50, 0.0}\n    };\n    private final double PH_MIN = 0.0;\n    private final double PH_MAX = 14.0;\n    private final double MAXLOOP = 2000.0;\n    private final double EPSI = 0.0001;\n    private double exp10(double pka){\n        return Math.pow(10, pka);\n    }\n    private double getIsoelectricPointExpasy(String sequence){\n        int[] comp = new int[26];\n        for(int i = 0; i < sequence.length(); i++){\n            int index = sequence.charAt(i) - 'A';\n            if(index < 0 || index >= 26) continue;\n            comp[index]++;\n        }\n        int nTermResidue = -1;\n        int index = 0;\n        while((nTermResidue < 0 || nTermResidue >= 26) && index < 25){\n            nTermResidue = sequence.charAt(index++) - 'A';\n        }\n        int cTermResidue = -1;\n        index = 1;\n        while((cTermResidue < 0 || cTermResidue >= 26) && index < 25){\n            cTermResidue = sequence.charAt(sequence.length() - index++) - 'A';\n        }\n        double phMin = PH_MIN;\n        double phMax = PH_MAX;\n        double phMid = 0.0;\n        double charge = 1.0;\n        for (int i = 0; i < MAXLOOP && (phMax - phMin) > EPSI; i++){\n            phMid = phMin + (phMax - phMin) / 2.0;\n            charge = getNetChargeExpasy(comp, nTermResidue, cTermResidue, phMid);\n            if (charge > 0.0) phMin = phMid;\n            else phMax = phMid;\n        }\n        return phMid;\n    }\n    private double getIsoelectricPointInnovagen(ProteinSequence sequence){\n        double currentPH = 7.0;\n        double changeSize = 7.0;\n        String sequenceString = sequence.toString();\n        char nTerminalChar = sequenceString.charAt(0);\n        char cTerminalChar = sequenceString.charAt(sequenceString.length() - 1);\n        Map<AminoAcidCompound, Integer> chargedAA2Count = this.getChargedAACount(sequence);\n        double margin;\n        final double difference = 0.0001;\n        while(true){\n            margin = this.getNetChargeInnovagen(chargedAA2Count, currentPH, nTerminalChar, cTerminalChar);\n            if(margin <= difference && margin >= -difference) break;\n            changeSize /= 2.0;\n            if(margin > 0){\n                currentPH += changeSize;\n            }else{\n                currentPH -= changeSize;\n            }\n        }\n        return currentPH;\n    }\n    @Override\n    public double getIsoelectricPoint(ProteinSequence sequence){\n        return getIsoelectricPoint(sequence, true);\n    }\n    @Override\n    public double getNetCharge(ProteinSequence sequence) {\n        return getNetCharge(sequence, true);\n    }\n    @Override\n    public double getNetCharge(ProteinSequence sequence, boolean useExpasyValues){\n        return getNetCharge(sequence, true, 7.0);\n    }\n    @Override\n    public double getNetCharge(ProteinSequence sequence, boolean useExpasyValues, double pHPoint){\n        if(useExpasyValues){\n            return getNetChargeExpasy(sequence.toString().toUpperCase(), pHPoint);\n        }else{\n            return getNetChargeInnovagen(sequence, pHPoint);\n        }\n    }\n    private double getNetChargeExpasy(String sequence, double pHPoint){\n        int[] comp = new int[26];\n        for(int i = 0; i < sequence.length(); i++){\n            int index = sequence.charAt(i) - 'A';\n            if(index < 0 || index >= 26) continue;\n            comp[index]++;\n        }\n        int nTermResidue = sequence.charAt(0) - 'A';\n        int cTermResidue = sequence.charAt(sequence.length() - 1) - 'A';\n        return getNetChargeExpasy(comp, nTermResidue, cTermResidue, pHPoint);\n    }\n    private double getNetChargeExpasy(int[] comp, int nTermResidue, int cTermResidue, double ph){\n        double cter = 0.0;\n        if(cTermResidue >= 0 && cTermResidue < 26) cter = exp10(-cPk[cTermResidue][0]) / (exp10(-cPk[cTermResidue][0]) + exp10(-ph));\n        double nter = 0.0;\n        if(nTermResidue >= 0 && nTermResidue < 26) nter = exp10(-ph) / (exp10(-cPk[nTermResidue][1]) + exp10(-ph));\n        double carg = comp['R' - 'A'] * exp10(-ph) / (exp10(-cPk['R' - 'A'][2]) + exp10(-ph));\n        double chis = comp['H' - 'A'] * exp10(-ph) / (exp10(-cPk['H' - 'A'][2]) + exp10(-ph));\n        double clys = comp['K' - 'A'] * exp10(-ph) / (exp10(-cPk['K' - 'A'][2]) + exp10(-ph));\n        double casp = comp['D' - 'A'] * exp10(-cPk['D' - 'A'][2]) / (exp10(-cPk['D' - 'A'][2]) + exp10(-ph));\n        double cglu = comp['E' - 'A'] * exp10(-cPk['E' - 'A'][2]) / (exp10(-cPk['E' - 'A'][2]) + exp10(-ph));\n        double ccys = comp['C' - 'A'] * exp10(-cPk['C' - 'A'][2]) / (exp10(-cPk['C' - 'A'][2]) + exp10(-ph));\n        double ctyr = comp['Y' - 'A'] * exp10(-cPk['Y' - 'A'][2]) / (exp10(-cPk['Y' - 'A'][2]) + exp10(-ph));\n        return (carg + clys + chis + nter) - (casp + cglu + ctyr + ccys + cter);\n    }\n    private double getNetChargeInnovagen(ProteinSequence sequence, double pHPoint) {\n        Map<AminoAcidCompound, Integer> chargedAA2Count = this.getChargedAACount(sequence);\n        String sequenceString = sequence.getSequenceAsString();\n        return getNetChargeInnovagen(chargedAA2Count, pHPoint, sequenceString.charAt(0), sequenceString.charAt(sequenceString.length() - 1));\n    }\n    private double getNetChargeInnovagen(Map<AminoAcidCompound, Integer> chargedAA2Count, double ph, char nTerminalChar, char cTerminalChar){\n        AminoAcidCompound nTermCompound = AA_CHAR_TO_COMPOUND.get(nTerminalChar);\n        double nTerminalCharge = 0.0;\n        if(nTermCompound != null && Constraints.aa2NTerminalPka.containsKey(nTermCompound)){\n            nTerminalCharge = this.getPosCharge(Constraints.aa2NTerminalPka.get(nTermCompound), ph);\n        }\n        AminoAcidCompound cTermCompound = AA_CHAR_TO_COMPOUND.get(cTerminalChar);\n        double cTerminalCharge = 0.0;\n        if(cTermCompound != null && Constraints.aa2CTerminalPka.containsKey(cTermCompound)){\n            cTerminalCharge = this.getNegCharge(Constraints.aa2CTerminalPka.get(cTermCompound), ph);\n        }\n        double kCharge = chargedAA2Count.get(AA_CHAR_TO_COMPOUND.get('K')) * this.getPosCharge(Constraints.aa2PKa.get(AA_CHAR_TO_COMPOUND.get('K')), ph);\n        double rCharge = chargedAA2Count.get(AA_CHAR_TO_COMPOUND.get('R')) * this.getPosCharge(Constraints.aa2PKa.get(AA_CHAR_TO_COMPOUND.get('R')), ph);\n        double hCharge = chargedAA2Count.get(AA_CHAR_TO_COMPOUND.get('H')) * this.getPosCharge(Constraints.aa2PKa.get(AA_CHAR_TO_COMPOUND.get('H')), ph);\n        double dCharge = chargedAA2Count.get(AA_CHAR_TO_COMPOUND.get('D')) * this.getNegCharge(Constraints.aa2PKa.get(AA_CHAR_TO_COMPOUND.get('D')), ph);\n        double eCharge = chargedAA2Count.get(AA_CHAR_TO_COMPOUND.get('E')) * this.getNegCharge(Constraints.aa2PKa.get(AA_CHAR_TO_COMPOUND.get('E')), ph);\n        double cCharge = chargedAA2Count.get(AA_CHAR_TO_COMPOUND.get('C')) * this.getNegCharge(Constraints.aa2PKa.get(AA_CHAR_TO_COMPOUND.get('C')), ph);\n        double yCharge = chargedAA2Count.get(AA_CHAR_TO_COMPOUND.get('Y')) * this.getNegCharge(Constraints.aa2PKa.get(AA_CHAR_TO_COMPOUND.get('Y')), ph);\n        return (nTerminalCharge + kCharge + rCharge + hCharge) - (dCharge + eCharge + cCharge + yCharge + cTerminalCharge);\n    }\n    private double getPosCharge(double pka, double ph){\n        return Math.pow(10, pka) / (Math.pow(10, pka) + Math.pow(10, ph));\n    }\n    private double getNegCharge(double pka, double ph){\n        return Math.pow(10, ph) / (Math.pow(10, pka) + Math.pow(10, ph));\n    }\n    private Map<AminoAcidCompound, Integer> getChargedAACount(ProteinSequence sequence){\n        int numK = 0, numR = 0, numH = 0, numD = 0, numE = 0, numC = 0, numY = 0;\n        char[] seq = this.getSequence(sequence.getSequenceAsString(), true);\n        for(char aa:seq){\n            switch(aa){\n                case 'K': numK++; break;\n                case 'R': numR++; break;\n                case 'H': numH++; break;\n                case 'D': numD++; break;\n                case 'E': numE++; break;\n                case 'C': numC++; break;\n                case 'Y': numY++; break;\n            }\n        }\n        Map<AminoAcidCompound, Integer> chargedAA2Count = new HashMap<>();\n        chargedAA2Count.put(AA_CHAR_TO_COMPOUND.get('K'), numK);\n        chargedAA2Count.put(AA_CHAR_TO_COMPOUND.get('R'), numR);\n        chargedAA2Count.put(AA_CHAR_TO_COMPOUND.get('H'), numH);\n        chargedAA2Count.put(AA_CHAR_TO_COMPOUND.get('D'), numD);\n        chargedAA2Count.put(AA_CHAR_TO_COMPOUND.get('E'), numE);\n        chargedAA2Count.put(AA_CHAR_TO_COMPOUND.get('C'), numC);\n        chargedAA2Count.put(AA_CHAR_TO_COMPOUND.get('Y'), numY);\n        return chargedAA2Count;\n    }\n    @Override\n    public double getEnrichment(ProteinSequence sequence, AminoAcidCompound aminoAcidCode) {\n        double counter = 0.0;\n        char[] seq = this.getSequence(sequence.getSequenceAsString(), true);\n        String aaShort = aminoAcidCode.getShortName();\n        for(char aa:seq){\n            if(aaShort.equals(String.valueOf(aa))){\n                counter++;\n            }\n        }\n        return counter/sequence.getLength();\n    }\n    @Override\n    public Map<AminoAcidCompound, Double> getAAComposition(ProteinSequence sequence) {\n        int validLength = 0;\n        double[] counts = new double[26]; \n        char[] seq = this.getSequence(sequence.toString(), true);\n        for(char aa: seq){\n            if(PeptideProperties.standardAASet.contains(aa)){\n                int idx = Character.toUpperCase(aa) - 'A';\n                if(idx >= 0 && idx < counts.length) {\n                    counts[idx]++;\n                    validLength++;\n                }\n            }\n        }\n        Map<AminoAcidCompound, Double> aa2Composition = new HashMap<>();\n        for(char aa : PeptideProperties.standardAASet) {\n            AminoAcidCompound compound = AA_CHAR_TO_COMPOUND.get(aa);\n            int idx = Character.toUpperCase(aa) - 'A';\n            double v = (validLength > 0) ? counts[idx] / validLength : 0.0;\n            aa2Composition.put(compound, v);\n        }\n        return aa2Composition;\n    }\n    @Override\n    public double getAromaticity(ProteinSequence sequence) {\n        int validLength = sequence.getSequenceAsString().length();\n        if (validLength == 0) {\n            logger.warn(\"Valid length of sequence is 0, can't divide by 0 to calculate aromaticity: setting aromaticity to 0\");\n            return 0.0;\n        }\n        int totalF = 0, totalY = 0, totalW = 0;\n        char[] seq = this.getSequence(sequence.toString(), true);\n        for (char aa : seq) {\n            switch (Character.toUpperCase(aa)) {\n                case 'F': totalF++; break;\n                case 'Y': totalY++; break;\n                case 'W': totalW++; break;\n            }\n        }\n        return (totalF + totalY + totalW) / (double) (validLength);\n    }\n}\n"
    ]
}