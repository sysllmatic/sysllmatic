{
    "0": [
        "package jnt.scimark2;\n\npublic class LUOptimized {\n    private final double[][] LU_;\n    private final int[] pivot_;\n\n    public static void main(String[] args) {\n        Random R = new Random(101010);\n        int N = 1000;\n        \n        double[][] A = RandomMatrix(N, N, R);\n        double[][] lu = new double[N][N];\n        int[] pivot = new int[N];\n\n        CopyMatrix(lu, A);\n\n        int status = factor(lu, pivot);\n        if (status != 0) {\n            System.err.println(\"LU factorization failed due to singular matrix.\");\n            return;\n        }\n        \n        double[] b = RandomVector(N, R);\n        double[] x = NewVectorCopy(b);\n\n        solve(lu, pivot, x);\n        System.out.println(normabs(b, matvec(A, x)) / N);\n    }\n\n    public LUOptimized(double[][] A) {\n        int M = A.length;\n        int N = A[0].length;\n\n        LU_ = new double[M][N];\n\n        insert_copy(LU_, A);\n\n        pivot_ = new int[M];\n\n        factor(LU_, pivot_);\n    }\n\n    private static double[] NewVectorCopy(double[] x) {\n        int N = x.length;\n\n        double[] y = new double[N];\n        System.arraycopy(x, 0, y, 0, N);\n\n        return y;\n    }\n\n    private static double[][] RandomMatrix(int M, int N, Random R) {\n        double[][] A = new double[M][N];\n\n        for (int i = 0; i < N; i++)\n            for (int j = 0; j < N; j++)\n                A[i][j] = R.nextDouble();\n        return A;\n    }\n\n    private static double[] RandomVector(int N, Random R) {\n        double[] A = new double[N];\n\n        for (int i = 0; i < N; i++)\n            A[i] = R.nextDouble();\n        return A;\n    }\n\n    private static double[] matvec(double[][] A, double[] x) {\n        int N = x.length;\n        double[] y = new double[N];\n\n        matvec(A, x, y);\n\n        return y;\n    }\n\n    private static void matvec(double[][] A, double[] x, double[] y) {\n        int M = A.length;\n        int N = A[0].length;\n\n        for (int i = 0; i < M; i++) {\n            double sum = 0.0;\n            double[] Ai = A[i];\n            for (int j = 0; j < N; j++)\n                sum += Ai[j] * x[j];\n\n            y[i] = sum;\n        }\n    }\n\n    private static double normabs(double[] x, double[] y) {\n        int N = x.length;\n        double sum = 0.0;\n\n        for (int i = 0; i < N; i++)\n            sum += Math.abs(x[i] - y[i]);\n\n        return sum;\n    }\n\n    private static void CopyMatrix(double[][] B, double[][] A) {\n        int M = A.length;\n        int N = A[0].length;\n\n        int remainder = N & 3;         // N mod 4;\n\n        for (int i = 0; i < M; i++) {\n            double[] Bi = B[i];\n            double[] Ai = A[i];\n            System.arraycopy(Ai, 0, Bi, 0, remainder);\n            for (int j = remainder; j < N; j += 4) {\n                Bi[j] = Ai[j];\n                Bi[j + 1] = Ai[j + 1];\n                Bi[j + 2] = Ai[j + 2];\n                Bi[j + 3] = Ai[j + 3];\n            }\n        }\n    }\n\n    protected static double[] new_copy(double[] x) {\n        int N = x.length;\n        double[] T = new double[N];\n        System.arraycopy(x, 0, T, 0, N);\n        return T;\n    }\n\n    protected static double[][] new_copy(double[][] A) {\n        int M = A.length;\n        int N = A[0].length;\n\n        double[][] T = new double[M][N];\n\n        for (int i = 0; i < M; i++) {\n            double[] Ti = T[i];\n            double[] Ai = A[i];\n            System.arraycopy(Ai, 0, Ti, 0, N);\n        }\n\n        return T;\n    }\n\n    public static int[] new_copy(int[] x) {\n        int N = x.length;\n        int[] T = new int[N];\n        System.arraycopy(x, 0, T, 0, N);\n        return T;\n    }\n\n    protected static void insert_copy(double[][] B, double[][] A) {\n        int M = A.length;\n        int N = A[0].length;\n\n        int remainder = N & 3;         // N mod 4;\n\n        for (int i = 0; i < M; i++) {\n            double[] Bi = B[i];\n            double[] Ai = A[i];\n            System.arraycopy(Ai, 0, Bi, 0, remainder);\n            for (int j = remainder; j < N; j += 4) {\n                Bi[j] = Ai[j];\n                Bi[j + 1] = Ai[j + 1];\n                Bi[j + 2] = Ai[j + 2];\n                Bi[j + 3] = Ai[j + 3];\n            }\n        }\n    }\n\n    /**\n     * LU factorization (in place).\n     *\n     * @param A     (in/out) On input, the matrix to be factored.\n     *              On output, the compact LU factorization.\n     * @param pivot (out) The pivot vector records the\n     *              reordering of the rows of A during factorization.\n     * @return 0, if OK, nozero value, othewise.\n     */\n    public static int factor(double[][] A, int[] pivot) {\n\n\n        int N = A.length;\n        int M = A[0].length;\n\n        int minMN = Math.min(M, N);\n\n        for (int j = 0; j < minMN; j++) {\n            // find pivot in column j and  test for singularity.\n\n            int jp = j;\n\n            double t = Math.abs(A[j][j]);\n            for (int i = j + 1; i < M; i++) {\n                double ab = Math.abs(A[i][j]);\n                if (ab > t) {\n                    jp = i;\n                    t = ab;\n                }\n            }\n\n            pivot[j] = jp;\n\n            // jp now has the index of maximum element\n            // of column j, below the diagonal\n\n            if (A[jp][j] == 0)\n                return 1;       // factorization failed because of zero pivot\n\n\n            if (jp != j) {\n                // swap rows j and jp\n                double[] tA = A[j];\n                A[j] = A[jp];\n                A[jp] = tA;\n            }\n\n            if (j < M - 1)                // compute elements j+1:M of jth column\n            {\n                // note A(j,j), was A(jp,p) previously which was\n                // guarranteed not to be zero (Label #1)\n                //\n                double recp = 1.0 / A[j][j];\n\n                for (int k = j + 1; k < M; k++)\n                    A[k][j] *= recp;\n            }\n\n\n            if (j < minMN - 1) {\n                // rank-1 update to trailing submatrix:   E = E - x*y;\n                //\n                // E is the region A(j+1:M, j+1:N)\n                // x is the column vector A(j+1:M,j)\n                // y is row vector A(j,j+1:N)\n\n\n                for (int ii = j + 1; ii < M; ii++) {\n                    double[] Aii = A[ii];\n                    double[] Aj = A[j];\n                    double AiiJ = Aii[j];\n                    for (int jj = j + 1; jj < N; jj++)\n                        Aii[jj] -= AiiJ * Aj[jj];\n\n                }\n            }\n        }\n\n        return 0;\n    }\n\n    /**\n     * Solve a linear system, using a prefactored matrix\n     * in LU form.\n     *\n     * @param LU  (in) the factored matrix in LU form.\n     * @param pvt (in) the pivot vector which lists\n     *            the reordering used during the factorization\n     *            stage.\n     * @param b   (in/out) On input, the right-hand side.\n     *            On output, the solution vector.\n     */\n    public static void solve(double[][] LU, int[] pvt, double[] b) {\n        int M = LU.length;\n        int N = LU[0].length;\n        int ii = 0;\n\n        for (int i = 0; i < M; i++) {\n            int ip = pvt[i];\n            double sum = b[ip];\n\n            b[ip] = b[i];\n            if (ii == 0)\n                for (int j = ii; j < i; j++)\n                    sum -= LU[i][j] * b[j];\n            else if (sum == 0.0)\n                ii = i;\n            b[i] = sum;\n        }\n\n        for (int i = N - 1; i >= 0; i--) {\n            double sum = b[i];\n            for (int j = i + 1; j < N; j++)\n                sum -= LU[i][j] * b[j];\n            b[i] = sum / LU[i][i];\n        }\n    }\n\n    public double[][] getLU() {\n        return new_copy(LU_);\n    }\n\n    /**\n     * Solve a linear system, with pre-computed factorization.\n     *\n     * @param b (in) the right-hand side.\n     * @return solution vector.\n     */\n    public double[] solve(double[] b) {\n        double[] x = new_copy(b);\n\n        solve(LU_, pivot_, x);\n        return x;\n    }\n}\n",
        16.695,
        0.407,
        988440520.0,
        63211.2,
        2.458,
        5438.02,
        303
    ],
    "1": [
        "package jnt.scimark2;\n\nimport java.util.Random;\n\npublic class LUOptimized {\n    private final double[][] LU_;\n    private final int[] pivot_;\n\n    public static void main(String[] args) {\n        Random R = new Random(101010);\n        int N = 1000;\n        \n        double[][] A = RandomMatrix(N, N, R);\n        double[][] lu = new double[N][N];\n        int[] pivot = new int[N];\n\n        copyMatrix(lu, A);\n\n        int status = factor(lu, pivot);\n        if (status != 0) {\n            System.err.println(\"LU factorization failed due to singular matrix.\");\n            return;\n        }\n        \n        double[] b = RandomVector(N, R);\n        double[] x = b.clone();\n\n        solve(lu, pivot, x);\n        System.out.println(normabs(b, matvec(A, x)) / N);\n    }\n\n    public LUOptimized(double[][] A) {\n        int M = A.length;\n        int N = A[0].length;\n\n        LU_ = new double[M][N];\n\n        copyMatrix(LU_, A);\n\n        pivot_ = new int[M];\n\n        factor(LU_, pivot_);\n    }\n\n    private static double[][] RandomMatrix(int M, int N, Random R) {\n        double[][] A = new double[M][N];\n\n        for (int i = 0; i < M; i++) {\n            for (int j = 0; j < N; j++) {\n                A[i][j] = R.nextDouble();\n            }\n        }\n        return A;\n    }\n\n    private static double[] RandomVector(int N, Random R) {\n        double[] A = new double[N];\n\n        for (int i = 0; i < N; i++) {\n            A[i] = R.nextDouble();\n        }\n        return A;\n    }\n\n    private static double[] matvec(double[][] A, double[] x) {\n        int N = x.length;\n        double[] y = new double[N];\n\n        for (int i = 0; i < A.length; i++) {\n            double sum = 0.0;\n            for (int j = 0; j < N; j++) {\n                sum += A[i][j] * x[j];\n            }\n            y[i] = sum;\n        }\n        return y;\n    }\n\n    private static double normabs(double[] x, double[] y) {\n        int N = x.length;\n        double sum = 0.0;\n\n        for (int i = 0; i < N; i++) {\n            sum += Math.abs(x[i] - y[i]);\n        }\n\n        return sum;\n    }\n\n    private static void copyMatrix(double[][] B, double[][] A) {\n        for (int i = 0; i < A.length; i++) {\n            System.arraycopy(A[i], 0, B[i], 0, A[i].length);\n        }\n    }\n\n    public static int factor(double[][] A, int[] pivot) {\n        int N = A.length;\n        int M = A[0].length;\n\n        int minMN = Math.min(M, N);\n\n        for (int j = 0; j < minMN; j++) {\n            \n            int jp = j;\n            double t = Math.abs(A[j][j]);\n            for (int i = j + 1; i < M; i++) {\n                double ab = Math.abs(A[i][j]);\n                if (ab > t) {\n                    jp = i;\n                    t = ab;\n                }\n            }\n\n            pivot[j] = jp;\n\n            if (A[jp][j] == 0) {\n                return 1;  \n            }\n\n            if (jp != j) {\n                double[] temp = A[j];\n                A[j] = A[jp];\n                A[jp] = temp;\n            }\n\n            if (j < M - 1) {\n                double recp = 1.0 / A[j][j];\n                for (int i = j + 1; i < M; i++) {\n                    A[i][j] *= recp;\n                }\n            }\n\n            if (j < minMN - 1) {\n                for (int i = j + 1; i < M; i++) {\n                    double Aij = A[i][j];\n                    for (int k = j + 1; k < N; k++) {\n                        A[i][k] -= Aij * A[j][k];\n                    }\n                }\n            }\n        }\n\n        return 0;\n    }\n\n    public static void solve(double[][] LU, int[] pvt, double[] b) {\n        int M = LU.length;\n        int N = LU[0].length;\n\n        for (int i = 0; i < M; i++) {\n            int ip = pvt[i];\n            double sum = b[ip];\n            b[ip] = b[i];\n\n            for (int j = 0; j < i; j++) {\n                sum -= LU[i][j] * b[j];\n            }\n            b[i] = sum;\n        }\n\n        for (int i = N - 1; i >= 0; i--) {\n            double sum = b[i];\n            for (int j = i + 1; j < N; j++) {\n                sum -= LU[i][j] * b[j];\n            }\n            b[i] = sum / LU[i][i];\n        }\n    }\n\n    public double[][] getLU() {\n        return LU_.clone();\n    }\n\n    public double[] solve(double[] b) {\n        double[] x = b.clone();\n        solve(LU_, pivot_, x);\n        return x;\n    }\n}",
        0.462,
        0.675,
        0.5251676565514264,
        1.0058046284274038,
        0.674753864930838,
        0.2598004420726661,
        179
    ],
    "2": [
        "package jnt.scimark2;\n\nimport java.util.Random;\nimport java.util.stream.IntStream;\n\npublic class LUOptimized {\n    private final double[][] LU_;\n    private final int[] pivot_;\n\n    public static void main(String[] args) {\n        Random R = new Random(101010);\n        int N = 1000;\n        \n        double[][] A = RandomMatrix(N, N, R);\n        double[][] lu = new double[N][N];\n        int[] pivot = new int[N];\n\n        copyMatrix(lu, A);\n\n        int status = factor(lu, pivot);\n        if (status != 0) {\n            System.err.println(\"LU factorization failed due to singular matrix.\");\n            return;\n        }\n        \n        double[] b = RandomVector(N, R);\n        double[] x = b.clone();\n\n        solve(lu, pivot, x);\n        System.out.println(normabs(b, matvec(A, x)) / N);\n    }\n\n    public LUOptimized(double[][] A) {\n        int M = A.length;\n        int N = A[0].length;\n\n        LU_ = new double[M][N];\n\n        copyMatrix(LU_, A);\n\n        pivot_ = new int[M];\n\n        factor(LU_, pivot_);\n    }\n\n    private static double[][] RandomMatrix(int M, int N, Random R) {\n        double[][] A = new double[M][N];\n\n        for (int i = 0; i < M; i++) {\n            for (int j = 0; j < N; j++) {\n                A[i][j] = R.nextDouble();\n            }\n        }\n        return A;\n    }\n\n    private static double[] RandomVector(int N, Random R) {\n        double[] A = new double[N];\n\n        for (int i = 0; i < N; i++) {\n            A[i] = R.nextDouble();\n        }\n        return A;\n    }\n\n    private static double[] matvec(double[][] A, double[] x) {\n        int N = x.length;\n        double[] y = new double[N];\n\n        IntStream.range(0, A.length).parallel().forEach(i -> {\n            double sum = 0.0;\n            for (int j = 0; j < N; j++) {\n                sum += A[i][j] * x[j];\n            }\n            y[i] = sum;\n        });\n        return y;\n    }\n\n    private static double normabs(double[] x, double[] y) {\n        int N = x.length;\n        double sum = 0.0;\n\n        for (int i = 0; i < N; i++) {\n            sum += Math.abs(x[i] - y[i]);\n        }\n\n        return sum;\n    }\n\n    private static void copyMatrix(double[][] B, double[][] A) {\n        for (int i = 0; i < A.length; i++) {\n            System.arraycopy(A[i], 0, B[i], 0, A[i].length);\n        }\n    }\n\n    public static int factor(double[][] A, int[] pivot) {\n        int N = A.length;\n        int M = A[0].length;\n\n        int minMN = Math.min(M, N);\n\n        for (int j = 0; j < minMN; j++) {\n            \n            int jp = j;\n            double t = Math.abs(A[j][j]);\n            for (int i = j + 1; i < M; i++) {\n                double ab = Math.abs(A[i][j]);\n                if (ab > t) {\n                    jp = i;\n                    t = ab;\n                }\n            }\n\n            pivot[j] = jp;\n\n            if (A[jp][j] == 0) {\n                return 1;  \n            }\n\n            if (jp != j) {\n                double[] temp = A[j];\n                A[j] = A[jp];\n                A[jp] = temp;\n            }\n\n            if (j < M - 1) {\n                double recp = 1.0 / A[j][j];\n                for (int i = j + 1; i < M; i++) {\n                    A[i][j] *= recp;\n                }\n            }\n\n            for (int i = j + 1; i < M; i++) {\n                double Aij = A[i][j];\n                for (int k = j + 1; k < N; k += 4) { \n                    A[i][k] -= Aij * A[j][k];\n                    if (k + 1 < N) A[i][k + 1] -= Aij * A[j][k + 1];\n                    if (k + 2 < N) A[i][k + 2] -= Aij * A[j][k + 2];\n                    if (k + 3 < N) A[i][k + 3] -= Aij * A[j][k + 3];\n                }\n            }\n        }\n\n        return 0;\n    }\n\n    public static void solve(double[][] LU, int[] pvt, double[] b) {\n        int M = LU.length;\n        int N = LU[0].length;\n\n        for (int i = 0; i < M; i++) {\n            int ip = pvt[i];\n            double sum = b[ip];\n            b[ip] = b[i];\n\n            for (int j = 0; j < i; j++) {\n                sum -= LU[i][j] * b[j];\n            }\n            b[i] = sum;\n        }\n\n        for (int i = N - 1; i >= 0; i--) {\n            double sum = b[i];\n            for (int j = i + 1; j < N; j++) {\n                sum -= LU[i][j] * b[j];\n            }\n            b[i] = sum / LU[i][i];\n        }\n    }\n\n    public double[][] getLU() {\n        return LU_.clone();\n    }\n\n    public double[] solve(double[] b) {\n        double[] x = b.clone();\n        solve(LU_, pivot_, x);\n        return x;\n    }\n}",
        0.388,
        0.556,
        0.2085267950992983,
        0.9345239503252513,
        0.5558685923515052,
        0.2578879812873068,
        181
    ]
}