{
    "0": [
        "package jnt.scimark2;\n\npublic class FFTOptimized {\n\n    public static void transform(double[] data) {\n        transform_internal(data, -1);\n    }\n\n    public static void inverse(double[] data) {\n        transform_internal(data, +1);\n        // Normalize\n        int nd = data.length;\n        int n = nd / 2;\n        double norm = 1 / ((double) n);\n        for (int i = 0; i < nd; i++)\n            data[i] *= norm;\n    }\n\n    public static double test(double[] data) {\n        int nd = data.length;\n        // Make duplicate for comparison\n        double[] copy = new double[nd];\n        System.arraycopy(data, 0, copy, 0, nd);\n        // Transform & invert\n        transform(data);\n        inverse(data);\n        // Compute RMS difference.\n        double diff = 0.0;\n        for (int i = 0; i < nd; i++) {\n            double d = data[i] - copy[i];\n            diff += d * d;\n        }\n        return Math.sqrt(diff / nd);\n    }\n\n    public static double[] makeRandom(int n) {\n        int nd = 2 * n;\n        double[] data = new double[nd];\n        for (int i = 0; i < nd; i++)\n            data[i] = Math.random();\n        return data;\n    }\n\n    /**\n     * Main method, strictly do not change.\n     */\n    public static void main(String[] args) {\n        if (args.length == 0) {\n            int n = 1048576;\n            System.out.println(test(makeRandom(n)) / 1048576);\n        }\n        for (int i = 0; i < args.length; i++) {\n            int n = Integer.parseInt(args[i]);\n            System.out.println(test(makeRandom(n)) / 1048576);\n        }\n    }\n\n    protected static int log2(int n) {\n        int log = 0;\n        for (int k = 1; k < n; k *= 2, log++) ;\n        if (n != (1 << log))\n            throw new Error(\"FFT: Data length is not a power of 2!: \" + n);\n        return log;\n    }\n\n    protected static void transform_internal(double[] data, int direction) {\n        if (data.length == 0) return;\n        int n = data.length / 2;\n        if (n == 1) return;         // Identity operation!\n        int logn = log2(n);\n\n        /* bit reverse the input data for decimation in time algorithm */\n        bitreverse(data);\n\n        /* apply fft recursion */\n        /* this loop executed log2(N) times */\n        for (int bit = 0, dual = 1; bit < logn; bit++, dual *= 2) {\n            double w_real = 1.0;\n            double w_imag = 0.0;\n\n            double theta = 2.0 * direction * Math.PI / (2.0 * (double) dual);\n            double s = Math.sin(theta);\n            double t = Math.sin(theta / 2.0);\n            double s2 = 2.0 * t * t;\n\n            /* a = 0 */\n            for (int b = 0; b < n; b += 2 * dual) {\n                int i = 2 * b;\n                int j = 2 * (b + dual);\n\n                double wd_real = data[j];\n                double wd_imag = data[j + 1];\n\n                data[j] = data[i] - wd_real;\n                data[j + 1] = data[i + 1] - wd_imag;\n                data[i] += wd_real;\n                data[i + 1] += wd_imag;\n            }\n\n            /* a = 1 .. (dual-1) */\n            for (int a = 1; a < dual; a++) {\n                /* trignometric recurrence for w-> exp(i theta) w */\n                {\n                    double tmp_real = w_real - s * w_imag - s2 * w_real;\n                    double tmp_imag = w_imag + s * w_real - s2 * w_imag;\n                    w_real = tmp_real;\n                    w_imag = tmp_imag;\n                }\n                for (int b = 0; b < n; b += 2 * dual) {\n                    int i = 2 * (b + a);\n                    int j = 2 * (b + a + dual);\n\n                    double z1_real = data[j];\n                    double z1_imag = data[j + 1];\n\n                    double wd_real = w_real * z1_real - w_imag * z1_imag;\n                    double wd_imag = w_real * z1_imag + w_imag * z1_real;\n\n                    data[j] = data[i] - wd_real;\n                    data[j + 1] = data[i + 1] - wd_imag;\n                    data[i] += wd_real;\n                    data[i + 1] += wd_imag;\n                }\n            }\n        }\n    }\n\n\n    protected static void bitreverse(double[] data) {\n        /* This is the Goldrader bit-reversal algorithm */\n        int n = data.length / 2;\n        int nm1 = n - 1;\n        int i = 0;\n        int j = 0;\n        for (; i < nm1; i++) {\n\n            //int ii = 2*i;\n            int ii = i << 1;\n\n            //int jj = 2*j;\n            int jj = j << 1;\n\n            //int k = n / 2 ;\n            int k = n >> 1;\n\n            if (i < j) {\n                double tmp_real = data[ii];\n                double tmp_imag = data[ii + 1];\n                data[ii] = data[jj];\n                data[ii + 1] = data[jj + 1];\n                data[jj] = tmp_real;\n                data[jj + 1] = tmp_imag;\n            }\n\n            while (k <= j) {\n                //j = j - k ;\n                j -= k;\n\n                //k = k / 2 ;\n                k >>= 1;\n            }\n            j += k;\n        }\n    }\n}",
        42.216,
        0.479,
        1471010787.6,
        78457.6,
        2.086,
        534.11,
        165
    ],
    "1": [
        "package jnt.scimark2;\n\npublic class FFTOptimized {\n\n    public static void transform(double[] data) {\n        transform_internal(data, -1);\n    }\n\n    public static void inverse(double[] data) {\n        transform_internal(data, +1);\n        \n        int nd = data.length;\n        int n = nd / 2;\n        double norm = 1.0 / n;\n        for (int i = 0; i < nd; i++) {\n            data[i] *= norm;\n        }\n    }\n\n    public static double test(double[] data) {\n        int nd = data.length;\n        double[] copy = new double[nd];\n        System.arraycopy(data, 0, copy, 0, nd);\n        transform(data);\n        inverse(data);\n        double diff = 0.0;\n        for (int i = 0; i < nd; i++) {\n            double d = data[i] - copy[i];\n            diff += d * d;\n        }\n        return Math.sqrt(diff / nd);\n    }\n\n    public static double[] makeRandom(int n) {\n        int nd = 2 * n;\n        double[] data = new double[nd];\n        for (int i = 0; i < nd; i++) {\n            data[i] = Math.random(); \n        }\n        return data;\n    }\n\n    public static void main(String[] args) {\n        if (args.length == 0) {\n            int n = 1048576;\n            System.out.println(test(makeRandom(n)) / 1048576);\n        }\n        for (int i = 0; i < args.length; i++) {\n            int n = Integer.parseInt(args[i]);\n            System.out.println(test(makeRandom(n)) / 1048576);\n        }\n    }\n\n    protected static int log2(int n) {\n        if (n <= 0) throw new IllegalArgumentException(\"n must be positive\");\n        return 31 - Integer.numberOfLeadingZeros(n);\n    }\n\n    protected static void transform_internal(double[] data, int direction) {\n        if (data.length == 0) return;\n        int n = data.length / 2;\n        if (n == 1) return;\n        int logn = log2(n);\n\n        bitreverse(data);\n\n        for (int bit = 0, dual = 1; bit < logn; bit++, dual *= 2) {\n            double theta = 2.0 * direction * Math.PI / (2.0 * dual);\n            double wtemp, wpr, wpi, wr = 1.0, wi = 0.0;\n            wtemp = Math.sin(0.5 * theta);\n            wpr = -2.0 * wtemp * wtemp;\n            wpi = Math.sin(theta);\n\n            for (int a = 0; a < dual; a++) {\n                for (int b = a; b < n; b += 2 * dual) {\n                    int i = 2 * b;\n                    int j = 2 * (b + dual);\n\n                    double tempr = wr * data[j] - wi * data[j + 1];\n                    double tempi = wr * data[j + 1] + wi * data[j];\n\n                    data[j] = data[i] - tempr;\n                    data[j + 1] = data[i + 1] - tempi;\n                    data[i] += tempr;\n                    data[i + 1] += tempi;\n                }\n                wtemp = wr;\n                wr += wpr * wr - wpi * wi;\n                wi += wpi * wtemp + wpr * wi;\n            }\n        }\n    }\n\n    protected static void bitreverse(double[] data) {\n        int n = data.length / 2;\n        int nm1 = n - 1;\n        int i = 0, j = 0;\n        for (; i < nm1; i++) {\n            int ii = i << 1;\n            int jj = j << 1;\n            if (i < j) {\n                double tmp_real = data[ii];\n                double tmp_imag = data[ii + 1];\n                data[ii] = data[jj];\n                data[ii + 1] = data[jj + 1];\n                data[jj] = tmp_real;\n                data[jj + 1] = tmp_imag;\n            }\n\n            int k = n >> 1;\n            while (k <= j) {\n                j -= k;\n                k >>= 1;\n            }\n            j += k;\n        }\n    }\n}",
        1.076,
        0.935,
        0.9612545834365346,
        0.9958974775579837,
        0.9357996164908917,
        0.9792177641309842,
        118
    ]
}