{
    "0": [
        "package jnt.scimark2;\n\nimport java.util.Random;\n\npublic class SOROptimized {\n    // Executes the Successive Over-Relaxation (SOR) algorithm.\n    public static void execute(double omega, double[][] G, long num_iterations) {\n        int M = G.length;\n        int N = G[0].length;\n\n        double omega_over_four = omega * 0.25;\n        double one_minus_omega = 1.0 - omega;\n\n        // Update interior points for each iteration.\n        int Mm1 = M - 1;\n        int Nm1 = N - 1;\n        for (long p = 0; p < num_iterations; p++) {\n            for (int i = 1; i < Mm1; i++) {\n                double[] Gi = G[i];\n                double[] Gim1 = G[i - 1];\n                double[] Gip1 = G[i + 1];\n                for (int j = 1; j < Nm1; j++) {\n                    Gi[j] = omega_over_four * (Gim1[j] + Gip1[j] + Gi[j - 1] + Gi[j + 1])\n                            + one_minus_omega * Gi[j];\n                }\n            }\n        }\n    }\n\n    // Helper method to generate a random matrix with dimensions M x N.\n    private static double[][] randomMatrix(int M, int N) {\n        double[][] A = new double[M][N];\n        Random R = new Random(101010);\n        for (int i = 0; i < M; i++) {\n            for (int j = 0; j < N; j++) {\n                A[i][j] = R.nextDouble();\n            }\n        }\n        return A;\n    }\n\n\n    private static double normabs(double[] x, double[] y) {\n        int N = x.length;\n        double sum = 0.0;\n\n        for (int i = 0; i < N; i++)\n            sum += Math.abs(x[i] - y[i]);\n\n        return sum;\n    }\n\n    /**\n    * Main method, do not change.\n    */\n    public static void main(String[] args) {\n        final int SOR_SIZE = 100;      \n        final long cycles = 65536;      // Fixed number of iterations.\n        double omega = 1.25;            // Relaxation factor\n\n        // Create a random matrix of dimensions SOR_SIZE x SOR_SIZE.\n        double[][] G = randomMatrix(SOR_SIZE, SOR_SIZE);\n\n        // Execute the SOR algorithm.\n        execute(omega, G, cycles);\n\n        // Compute the error between the two matrices (should be 0.0 for a matrix of random values)\n        double[][] G_baseline = randomMatrix(SOR_SIZE, SOR_SIZE);\n        double error = 0.0;\n        for (int i = 0; i < SOR_SIZE; i++) {\n            error += normabs(G[i], G_baseline[i]);\n        }\n\n        // Print the error result\n        System.out.println(error * 1.0e-6);\n    }\n}\n\n\n",
        194.437,
        2.494,
        10052874577.2,
        45971.2,
        0.401,
        1691.05,
        79
    ],
    "1": [
        "package jnt.scimark2;\n\nimport java.util.Random;\n\npublic class SOROptimized {\n    \n    public static void execute(double omega, double[][] G, long num_iterations) {\n        int M = G.length;\n        int N = G[0].length;\n\n        double omega_over_four = omega * 0.25;\n        double one_minus_omega = 1.0 - omega;\n\n        int Mm1 = M - 1;\n        int Nm1 = N - 1;\n\n        for (long p = 0; p < num_iterations; p++) {\n            for (int i = 1; i < Mm1; i++) {\n                double[] Gi = G[i];\n                double[] Gim1 = G[i - 1];\n                double[] Gip1 = G[i + 1];\n                for (int j = 1; j < Nm1; j++) {\n                    Gi[j] = omega_over_four * (Gim1[j] + Gip1[j] + Gi[j - 1] + Gi[j + 1])\n                            + one_minus_omega * Gi[j];\n                }\n            }\n        }\n    }\n\n    \n    private static double[][] randomMatrix(int M, int N) {\n        double[][] A = new double[M][N];\n        Random R = new Random(101010);\n        for (int i = 0; i < M; i++) {\n            for (int j = 0; j < N; j++) {\n                A[i][j] = R.nextDouble();\n            }\n        }\n        return A;\n    }\n\n    private static double normabs(double[] x, double[] y) {\n        int N = x.length;\n        double sum = 0.0;\n\n        for (int i = 0; i < N; i++) {\n            sum += Math.abs(x[i] - y[i]);\n        }\n\n        return sum;\n    }\n\n    \n    public static void main(String[] args) {\n        final int SOR_SIZE = 100;\n        final long cycles = 65536;      \n        double omega = 1.25;            \n\n        \n        double[][] G = randomMatrix(SOR_SIZE, SOR_SIZE);\n\n        \n        execute(omega, G, cycles);\n\n        \n        double[][] G_baseline = randomMatrix(SOR_SIZE, SOR_SIZE);\n        double error = 0.0;\n        for (int i = 0; i < SOR_SIZE; i++) {\n            error += normabs(G[i], G_baseline[i]);\n        }\n\n        \n        System.out.println(error * 1.0e-6);\n    }\n}\n",
        1.003,
        0.997,
        1.000182290943943,
        1.0037204590312832,
        0.9972718204488777,
        1.0174152153987168,
        75
    ]
}