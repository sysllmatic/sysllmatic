{
    "0": [
        "package jnt.scimark2;\n\nimport java.util.Random;\n\npublic class SOROptimized {\n    // Executes the Successive Over-Relaxation (SOR) algorithm.\n    public static void execute(double omega, double[][] G, long num_iterations) {\n        int M = G.length;\n        int N = G[0].length;\n\n        double omega_over_four = omega * 0.25;\n        double one_minus_omega = 1.0 - omega;\n\n        // Update interior points for each iteration.\n        int Mm1 = M - 1;\n        int Nm1 = N - 1;\n        for (long p = 0; p < num_iterations; p++) {\n            for (int i = 1; i < Mm1; i++) {\n                double[] Gi = G[i];\n                double[] Gim1 = G[i - 1];\n                double[] Gip1 = G[i + 1];\n                for (int j = 1; j < Nm1; j++) {\n                    Gi[j] = omega_over_four * (Gim1[j] + Gip1[j] + Gi[j - 1] + Gi[j + 1])\n                            + one_minus_omega * Gi[j];\n                }\n            }\n        }\n    }\n\n    // Helper method to generate a random matrix with dimensions M x N.\n    private static double[][] randomMatrix(int M, int N) {\n        double[][] A = new double[M][N];\n        Random R = new Random(101010);\n        for (int i = 0; i < M; i++) {\n            for (int j = 0; j < N; j++) {\n                A[i][j] = R.nextDouble();\n            }\n        }\n        return A;\n    }\n\n\n    private static double normabs(double[] x, double[] y) {\n        int N = x.length;\n        double sum = 0.0;\n\n        for (int i = 0; i < N; i++)\n            sum += Math.abs(x[i] - y[i]);\n\n        return sum;\n    }\n\n    /**\n    * Main method, do not change.\n    */\n    public static void main(String[] args) {\n        final int SOR_SIZE = 100;      \n        final long cycles = 65536;      // Fixed number of iterations.\n        double omega = 1.25;            // Relaxation factor\n\n        // Create a random matrix of dimensions SOR_SIZE x SOR_SIZE.\n        double[][] G = randomMatrix(SOR_SIZE, SOR_SIZE);\n\n        // Execute the SOR algorithm.\n        execute(omega, G, cycles);\n\n        // Compute the error between the two matrices (should be 0.0 for a matrix of random values)\n        double[][] G_baseline = randomMatrix(SOR_SIZE, SOR_SIZE);\n        double error = 0.0;\n        for (int i = 0; i < SOR_SIZE; i++) {\n            error += normabs(G[i], G_baseline[i]);\n        }\n\n        // Print the error result\n        System.out.println(error * 1.0e-6);\n    }\n}\n\n\n",
        108.684,
        2.323,
        10055720454.8,
        45779.2,
        0.43,
        1674.16,
        79
    ],
    "1": [
        "package jnt.scimark2;\n\nimport java.util.Random;\n\npublic class SOROptimized {\n    \n    public static void execute(double omega, double[][] G, long num_iterations) {\n        int M = G.length;\n        int N = G[0].length;\n\n        double omega_over_four = omega * 0.25;\n        double one_minus_omega = 1.0 - omega;\n\n        \n        int Mm1 = M - 1;\n        int Nm1 = N - 1;\n        for (long p = 0; p < num_iterations; p++) {\n            for (int i = 1; i < Mm1; i++) {\n                double[] Gi = G[i];\n                double[] Gim1 = G[i - 1];\n                double[] Gip1 = G[i + 1];\n                for (int j = 1; j < Nm1; j += 2) {\n                    \n                    Gi[j] = omega_over_four * (Gim1[j] + Gip1[j] + Gi[j - 1] + Gi[j + 1])\n                            + one_minus_omega * Gi[j];\n                    if (j + 1 < Nm1) {\n                        Gi[j + 1] = omega_over_four * (Gim1[j + 1] + Gip1[j + 1] + Gi[j] + Gi[j + 2])\n                                + one_minus_omega * Gi[j + 1];\n                    }\n                }\n            }\n        }\n    }\n\n    \n    private static double[][] randomMatrix(int M, int N) {\n        double[][] A = new double[M][N];\n        Random R = new Random(101010);\n        for (int i = 0; i < M; i++) {\n            for (int j = 0; j < N; j++) {\n                A[i][j] = R.nextDouble();\n            }\n        }\n        return A;\n    }\n\n    private static double normabs(double[] x, double[] y) {\n        int N = x.length;\n        double sum = 0.0;\n\n        for (int i = 0; i < N; i++)\n            sum += Math.abs(x[i] - y[i]);\n\n        return sum;\n    }\n\n    \n    public static void main(String[] args) {\n        final int SOR_SIZE = 100;      \n        final long cycles = 65536;      \n        double omega = 1.25;            \n\n        \n        double[][] G = randomMatrix(SOR_SIZE, SOR_SIZE);\n\n        \n        execute(omega, G, cycles);\n\n        \n        double[][] G_baseline = randomMatrix(SOR_SIZE, SOR_SIZE);\n        double error = 0.0;\n        for (int i = 0; i < SOR_SIZE; i++) {\n            error += normabs(G[i], G_baseline[i]);\n        }\n\n        \n        System.out.println(error * 1.0e-6);\n    }\n}",
        0.894,
        0.91,
        0.9110075408095771,
        1.0044232254440777,
        0.9110093023255814,
        0.9297259521192717,
        79
    ],
    "2": [
        "package jnt.scimark2;\n\nimport java.util.Random;\nimport java.util.concurrent.*;\nimport java.util.stream.IntStream;\n\npublic class SOROptimized {\n\n    public static void execute(double omega, double[][] G, long num_iterations) {\n        int M = G.length;\n        int N = G[0].length;\n\n        double omega_over_four = omega * 0.25;\n        double one_minus_omega = 1.0 - omega;\n\n        int Mm1 = M - 1;\n        int Nm1 = N - 1;\n\n        ForkJoinPool pool = new ForkJoinPool();\n        try {\n            for (long p = 0; p < num_iterations; p++) {\n                pool.submit(() -> IntStream.range(1, Mm1).parallel().forEach(i -> {\n                    double[] Gi = G[i];\n                    double[] Gim1 = G[i - 1];\n                    double[] Gip1 = G[i + 1];\n                    for (int j = 1; j < Nm1; j++) {\n                        double sum = omega_over_four * (Gim1[j] + Gip1[j] + Gi[j - 1] + Gi[j + 1]);\n                        Gi[j] = sum + one_minus_omega * Gi[j];\n                    }\n                })).get();\n            }\n        } catch (InterruptedException | ExecutionException e) {\n            e.printStackTrace();\n        } finally {\n            pool.shutdown();\n        }\n    }\n\n    private static double[][] randomMatrix(int M, int N) {\n        double[][] A = new double[M][N];\n        Random R = new Random(101010);\n        for (int i = 0; i < M; i++) {\n            for (int j = 0; j < N; j++) {\n                A[i][j] = R.nextDouble();\n            }\n        }\n        return A;\n    }\n\n    private static double normabs(double[] x, double[] y) {\n        int N = x.length;\n        double sum = 0.0;\n\n        for (int i = 0; i < N; i++)\n            sum += Math.abs(x[i] - y[i]);\n\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        final int SOR_SIZE = 100;\n        final long cycles = 65536;\n        double omega = 1.25;\n\n        double[][] G = randomMatrix(SOR_SIZE, SOR_SIZE);\n\n        execute(omega, G, cycles);\n\n        double[][] G_baseline = randomMatrix(SOR_SIZE, SOR_SIZE);\n        double error = 0.0;\n        for (int i = 0; i < SOR_SIZE; i++) {\n            error += normabs(G[i], G_baseline[i]);\n        }\n\n        System.out.println(error * 1.0e-6);\n    }\n}\n",
        0.344,
        0.301,
        0.08759781121076918,
        0.13893738057489152,
        0.30143023255813955,
        0.4698893773593921,
        77
    ]
}