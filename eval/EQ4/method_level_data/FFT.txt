{
    "0": [
        "protected static void transform_internal(double[] data, int direction) {\n    if (data.length == 0)\n        return;\n    int n = data.length / 2;\n    // Identity operation!\n    if (n == 1)\n        return;\n    int logn = log2(n);\n    /* bit reverse the input data for decimation in time algorithm */\n    bitreverse(data);\n    /* apply fft recursion */\n    /* this loop executed log2(N) times */\n    for (int bit = 0, dual = 1; bit < logn; bit++, dual *= 2) {\n        double w_real = 1.0;\n        double w_imag = 0.0;\n        double theta = 2.0 * direction * Math.PI / (2.0 * (double) dual);\n        double s = Math.sin(theta);\n        double t = Math.sin(theta / 2.0);\n        double s2 = 2.0 * t * t;\n        /* a = 0 */\n        for (int b = 0; b < n; b += 2 * dual) {\n            int i = 2 * b;\n            int j = 2 * (b + dual);\n            double wd_real = data[j];\n            double wd_imag = data[j + 1];\n            data[j] = data[i] - wd_real;\n            data[j + 1] = data[i + 1] - wd_imag;\n            data[i] += wd_real;\n            data[i + 1] += wd_imag;\n        }\n        /* a = 1 .. (dual-1) */\n        for (int a = 1; a < dual; a++) {\n            /* trignometric recurrence for w-> exp(i theta) w */\n            {\n                double tmp_real = w_real - s * w_imag - s2 * w_real;\n                double tmp_imag = w_imag + s * w_real - s2 * w_imag;\n                w_real = tmp_real;\n                w_imag = tmp_imag;\n            }\n            for (int b = 0; b < n; b += 2 * dual) {\n                int i = 2 * (b + a);\n                int j = 2 * (b + a + dual);\n                double z1_real = data[j];\n                double z1_imag = data[j + 1];\n                double wd_real = w_real * z1_real - w_imag * z1_imag;\n                double wd_imag = w_real * z1_imag + w_imag * z1_real;\n                data[j] = data[i] - wd_real;\n                data[j + 1] = data[i + 1] - wd_imag;\n                data[i] += wd_real;\n                data[i + 1] += wd_imag;\n            }\n        }\n    }\n}",
        20.053,
        0.453,
        1302309795.8,
        78381.6,
        2.204,
        699.05,
        54
    ],
    "1": [
        "package jnt.scimark2;\nprotected static void transform_internal(double[] data, int direction) {\n    if (data.length == 0) return;\n    int n = data.length / 2;\n    if (n == 1) return;\n    int logn = log2(n);\n    bitreverse(data);\n    for (int bit = 0, dual = 1; bit < logn; bit++, dual *= 2) {\n        double w_real = 1.0;\n        double w_imag = 0.0;\n        double theta = 2.0 * direction * Math.PI / (2.0 * dual);\n        double s = Math.sin(theta);\n        double t = Math.sin(theta / 2.0);\n        double s2 = 2.0 * t * t;\n\n        int dual2 = 2 * dual;\n\n        for (int b = 0; b < n; b += dual2) {\n            int i = 2 * b;\n            int j = i + dual2;\n            double wd_real = data[j];\n            double wd_imag = data[j + 1];\n            data[j] = data[i] - wd_real;\n            data[j + 1] = data[i + 1] - wd_imag;\n            data[i] += wd_real;\n            data[i + 1] += wd_imag;\n        }\n\n        for (int a = 1; a < dual; a++) {\n            double tmp_real = w_real - s * w_imag - s2 * w_real;\n            double tmp_imag = w_imag + s * w_real - s2 * w_imag;\n            w_real = tmp_real;\n            w_imag = tmp_imag;\n\n            for (int b = 0; b < n; b += dual2) {\n                int i = 2 * (b + a);\n                int j = i + dual2;\n                double z1_real = data[j];\n                double z1_imag = data[j + 1];\n                double wd_real = w_real * z1_real - w_imag * z1_imag;\n                double wd_imag = w_real * z1_imag + w_imag * z1_real;\n                data[j] = data[i] - wd_real;\n                data[j + 1] = data[i + 1] - wd_imag;\n                data[i] += wd_real;\n                data[i + 1] += wd_imag;\n            }\n        }\n    }\n}",
        0.963,
        0.992,
        0.9841420944447432,
        1.0035439563253474,
        0.9934378402903811,
        0.997553823045562,
        49
    ],
    "2": [
        "package jnt.scimark2;\n\nimport java.util.stream.IntStream;\n\nprotected static void transform_internal(double[] data, int direction) {\n    if (data.length == 0) return;\n    int n = data.length / 2;\n    if (n == 1) return;\n    int logn = log2(n);\n    bitreverse(data);\n\n    \n    double[] sinCache = new double[logn];\n    double[] cosCache = new double[logn];\n    for (int i = 0; i < logn; i++) {\n        double theta = 2.0 * direction * Math.PI / (2 << i);\n        sinCache[i] = Math.sin(theta);\n        cosCache[i] = Math.cos(theta);\n    }\n\n    for (int bit = 0, dual = 1; bit < logn; bit++, dual *= 2) {\n        double w_real = 1.0;\n        double w_imag = 0.0;\n        double s = sinCache[bit];\n        double s2 = 2.0 * Math.sin(Math.PI / (2 << bit)) * Math.sin(Math.PI / (2 << bit));\n\n        int dual2 = 2 * dual;\n\n        \n        for (int b = 0; b < n; b += dual2) {\n            int i = 2 * b;\n            int j = i + dual2;\n            double wd_real = data[j];\n            double wd_imag = data[j + 1];\n            data[j] = data[i] - wd_real;\n            data[j + 1] = data[i + 1] - wd_imag;\n            data[i] += wd_real;\n            data[i + 1] += wd_imag;\n        }\n\n        for (int a = 1; a < dual; a++) {\n            double tmp_real = w_real - s * w_imag - s2 * w_real;\n            double tmp_imag = w_imag + s * w_real - s2 * w_imag;\n            w_real = tmp_real;\n            w_imag = tmp_imag;\n            \n            \n            for (int b = 0; b < n; b += dual2) {\n                int i = 2 * (b + a);\n                int j = i + dual2;\n                double z1_real = data[j];\n                double z1_imag = data[j + 1];\n                double wd_real = w_real * z1_real - w_imag * z1_imag;\n                double wd_imag = w_real * z1_imag + w_imag * z1_real;\n                data[j] = data[i] - wd_real;\n                data[j + 1] = data[i + 1] - wd_imag;\n                data[i] += wd_real;\n                data[i + 1] += wd_imag;\n            }\n        }\n    }\n}\n\nprivate static int log2(int n) {\n    return 31 - Integer.numberOfLeadingZeros(n);\n}\n\nprivate static void bitreverse(double[] data) {\n    int n = data.length / 2;\n    int j = 0;\n    for (int i = 0; i < n - 1; i++) {\n        int k = n >> 1;\n        if (i < j) {\n            \n            double temp = data[2 * i];\n            data[2 * i] = data[2 * j];\n            data[2 * j] = temp;\n\n            \n            temp = data[2 * i + 1];\n            data[2 * i + 1] = data[2 * j + 1];\n            data[2 * j + 1] = temp;\n        }\n        while (k <= j) {\n            j -= k;\n            k >>= 1;\n        }\n        j += k;\n    }\n}",
        0.948,
        0.965,
        0.9536998514981793,
        0.9971807763551612,
        0.9658620689655173,
        0.8565481725198484,
        90
    ]
}