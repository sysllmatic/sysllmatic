{
    "0": [
        "\npackage org.biojava.nbio.aaproperties;\n\nimport org.biojava.nbio.aaproperties.xml.AminoAcidCompositionTable;\nimport org.biojava.nbio.aaproperties.xml.ElementTable;\nimport org.biojava.nbio.aaproperties.xml.MyValidationEventHandler;\nimport org.biojava.nbio.core.sequence.ProteinSequence;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompound;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompoundSet;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport jakarta.xml.bind.JAXBContext;\nimport jakarta.xml.bind.JAXBException;\nimport jakarta.xml.bind.Unmarshaller;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.util.HashMap;\nimport java.util.Map;\n\n\npublic class PeptidePropertiesImpl implements IPeptideProperties{\n\n\tprivate final static Logger logger = LoggerFactory.getLogger(PeptidePropertiesImpl.class);\n\n\t\n\tprivate double getWaterMoleculeWeight(){\n\t\tfinal double hydrogenMW = 1.0079;\n\t\tfinal double hydroxideMW = 17.0073;\n\t\t\n\t\treturn hydrogenMW + hydroxideMW;\n\t}\n\n\tprivate char[] getSequence(String sequence, boolean ignoreCase){\n\t\tif(ignoreCase){\n\t\t\treturn sequence.toUpperCase().toCharArray();\n\t\t}else{\n\t\t\treturn sequence.toCharArray();\n\t\t}\n\t}\n\n\t@Override\n\tpublic double getMolecularWeight(ProteinSequence sequence) {\n\t\tdouble value = 0.0;\n\t\tAminoAcidCompoundSet aaSet = new AminoAcidCompoundSet();\n\t\tchar[] seq = getSequence(sequence.toString(), true);\n\t\tfor(char aa:seq){\n\t\t\tAminoAcidCompound c = aaSet.getCompoundForString(String.valueOf(aa));\n\t\t\tif(Constraints.aa2MolecularWeight.containsKey(c)){\n\t\t\t\tvalue += Constraints.aa2MolecularWeight.get(c);\n\t\t\t}\n\t\t}\n\t\tif(value == 0)\n\t\t\treturn value;\n\t\telse\n\t\t\treturn value + getWaterMoleculeWeight();\n\t}\n\n\t@Override\n\tpublic double getMolecularWeight(ProteinSequence sequence, File aminoAcidCompositionFile) throws JAXBException, FileNotFoundException {\n\t\tFile elementMassFile = new File(\"./src/main/resources/ElementMass.xml\");\n\t\tif(!elementMassFile.exists()){\n\t\t\tthrow new FileNotFoundException(\"Cannot locate ElementMass.xml. \" +\n\t\t\t\t\t\"Please use getMolecularWeight(ProteinSequence, File, File) to specify ElementMass.xml location.\");\n\t\t}\n\t\treturn getMolecularWeightBasedOnXML(sequence, obtainAminoAcidCompositionTable(elementMassFile, aminoAcidCompositionFile));\n\t}\n\n\t@Override\n\tpublic double getMolecularWeight(ProteinSequence sequence, File elementMassFile, File aminoAcidCompositionFile)\n\t\t\tthrows JAXBException, FileNotFoundException{\n\t\treturn getMolecularWeightBasedOnXML(sequence, obtainAminoAcidCompositionTable(elementMassFile, aminoAcidCompositionFile));\n\t}\n\n\t@Override\n\tpublic double getMolecularWeightBasedOnXML(ProteinSequence sequence, AminoAcidCompositionTable aminoAcidCompositionTable){\n\t\tdouble value = 0.0;\n\t\tchar[] seq = sequence.toString().toCharArray();\n\t\tfor(char aa:seq){\n\t\t\tDouble weight = aminoAcidCompositionTable.getMolecularWeight(aa);\n\t\t\tif(weight != null){\n\t\t\t\tvalue += weight;\n\t\t\t}\n\t\t}\n\t\tif(value == 0.0)\n\t\t\treturn value;\n\t\telse\n\t\t\treturn value + getWaterMoleculeWeight();\n\t}\n\n\t@Override\n\tpublic AminoAcidCompositionTable obtainAminoAcidCompositionTable(File aminoAcidCompositionFile)\n\t\tthrows JAXBException, FileNotFoundException{\n\t\tFile elementMassFile = new File(\"./src/main/resources/ElementMass.xml\");\n\t\tif(!elementMassFile.exists()){\n\t\t\tthrow new FileNotFoundException(\"Cannot locate ElementMass.xml. \" +\n\t\t\t\t\t\"Please use getMolecularWeight(ProteinSequence, File, File) to specify ElementMass.xml location.\");\n\t\t}\n\t\treturn obtainAminoAcidCompositionTable(elementMassFile, aminoAcidCompositionFile);\n\t}\n\n\t@Override\n\tpublic AminoAcidCompositionTable obtainAminoAcidCompositionTable(File elementMassFile, File aminoAcidCompositionFile)\n\t\tthrows JAXBException, FileNotFoundException{\n\t\t\n\t\tElementTable iTable = new ElementTable();\n\t\t\n\t\tJAXBContext jc = JAXBContext.newInstance(iTable.getClass());\n\t\tUnmarshaller u = jc.createUnmarshaller();\n\t\tu.setEventHandler(new MyValidationEventHandler());\n\t\tiTable = (ElementTable)u.unmarshal(new FileInputStream(elementMassFile));\n\t\tiTable.populateMaps();\n\n\t\t\n\t\tAminoAcidCompositionTable aTable = new AminoAcidCompositionTable();\n\t\t\n\t\tJAXBContext jc2 = JAXBContext.newInstance(aTable.getClass());\n\t\tUnmarshaller u2 = jc2.createUnmarshaller();\n\t\tu2.setEventHandler(new MyValidationEventHandler());\n\t\taTable = (AminoAcidCompositionTable)u2.unmarshal(new FileInputStream(aminoAcidCompositionFile));\n\t\taTable.computeMolecularWeight(iTable);\n\t\treturn aTable;\n\t}\n\n\t@Override\n\tpublic double getExtinctionCoefficient(ProteinSequence sequence, boolean assumeCysReduced) {\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tAminoAcidCompoundSet aaSet = new AminoAcidCompoundSet();\n\t\tMap<AminoAcidCompound, Integer> extinctAA2Count = this.getExtinctAACount(sequence);\n\n\t\tdouble eProt;\n\t\tif(!assumeCysReduced){\n\t\t\teProt = extinctAA2Count.get(aaSet.getCompoundForString(\"Y\")) *\n\t\t\t\tConstraints.aa2ExtinctionCoefficient.get(aaSet.getCompoundForString(\"Y\")) +\n\t\t\t\textinctAA2Count.get(aaSet.getCompoundForString(\"W\")) *\n\t\t\t\tConstraints.aa2ExtinctionCoefficient.get(aaSet.getCompoundForString(\"W\")) +\n\t\t\t\textinctAA2Count.get(aaSet.getCompoundForString(\"C\")) *\n\t\t\t\tConstraints.aa2ExtinctionCoefficient.get(aaSet.getCompoundForString(\"C\"));\n\t\t}else\n\t\t\teProt = extinctAA2Count.get(aaSet.getCompoundForString(\"Y\")) *\n\t\t\t\tConstraints.aa2ExtinctionCoefficient.get(aaSet.getCompoundForString(\"Y\")) +\n\t\t\t\textinctAA2Count.get(aaSet.getCompoundForString(\"W\")) *\n\t\t\t\tConstraints.aa2ExtinctionCoefficient.get(aaSet.getCompoundForString(\"W\"));\n\n\t\treturn eProt;\n\t}\n\n\t@Override\n\tpublic double getAbsorbance(ProteinSequence sequence, boolean assumeCysReduced){\n\t\t\n\t\tdouble mw = this.getMolecularWeight(sequence);\n\t\tdouble eProt = this.getExtinctionCoefficient(sequence, assumeCysReduced);\n\t\tif (mw == 0.0) {\n\t\t\tlogger.warn(\"Molecular weight is 0.0, can't divide by 0: setting absorbance to 0.0\");\n\t\t\treturn 0.0;\n\t\t}\n\t\treturn eProt / mw;\n\t}\n\n\tprivate Map<AminoAcidCompound, Integer> getExtinctAACount(ProteinSequence sequence){\n\t\t\n\t\tint numW = 0;\n\t\tint smallW = 0;\n\t\tdouble numC = 0;\n\t\tdouble smallC = 0;\n\t\tint numY = 0;\n\t\tint smallY = 0;\n\t\tfor(char aa:sequence.getSequenceAsString().toCharArray()){\n\t\t\tswitch(aa){\n\t\t\tcase 'W': numW++; break;\n\t\t\tcase 'w': smallW++; break;\n\t\t\tcase 'C': numC += 0.5; break;\n\t\t\tcase 'c': smallC += 0.5; break;\n\t\t\tcase 'Y': numY++; break;\n\t\t\tcase 'y': smallY++; break;\n\t\t\t}\n\t\t}\n\t\tAminoAcidCompoundSet aaSet = new AminoAcidCompoundSet();\n\t\tMap<AminoAcidCompound, Integer> extinctAA2Count = new HashMap<AminoAcidCompound, Integer>();\n\t\t\n\t\textinctAA2Count.put(aaSet.getCompoundForString(\"W\"), numW + smallW);\n\t\textinctAA2Count.put(aaSet.getCompoundForString(\"C\"), (int) (numC + smallC));\n\t\textinctAA2Count.put(aaSet.getCompoundForString(\"Y\"), numY + smallY);\n\t\treturn extinctAA2Count;\n\t}\n\n\t@Override\n\tpublic double getInstabilityIndex(ProteinSequence sequence) {\n\t\tdouble sum = 0.0;\n\t\tString s = sequence.getSequenceAsString().toUpperCase();\n\t\tfor(int i = 0; i < sequence.getLength() - 1; i++){\n\t\t\tString dipeptide = s.substring(i, i+2);\n\t\t\tif(Constraints.diAA2Instability.containsKey(dipeptide)){\n\t\t\t\tsum += Constraints.diAA2Instability.get(dipeptide);\n\t\t\t}\n\t\t}\n\t\tint denominator = s.length() - Utils.getNumberOfInvalidChar(s, null, true);\n\n\t\tif (denominator==0) {\n\t\t\tlogger.warn(\"Valid length of sequence is 0, can't divide by 0 to calculate instability index: setting instability index value to 0.0\");\n\t\t\treturn 0.0;\n\t\t}\n\t\treturn sum * 10.0 / denominator;\n\t}\n\n\t@Override\n\tpublic double getApliphaticIndex(ProteinSequence sequence) {\n\n\n\n\n\n\n\t\tAminoAcidCompoundSet aaSet = new AminoAcidCompoundSet();\n\t\tMap<AminoAcidCompound, Double> aa2Composition = getAAComposition(sequence);\n\t\tfinal double a = 2.9;\n\t\tfinal double b = 3.9;\n\t\tdouble xAla = aa2Composition.get(aaSet.getCompoundForString(\"A\"));\n\t\tdouble xVal = aa2Composition.get(aaSet.getCompoundForString(\"V\"));\n\t\tdouble xIle = aa2Composition.get(aaSet.getCompoundForString(\"I\"));\n\t\tdouble xLeu = aa2Composition.get(aaSet.getCompoundForString(\"L\"));\n\t\treturn (xAla + (a * xVal) + (b * (xIle + xLeu))) * 100;\n\t}\n\n\t@Override\n\tpublic double getAvgHydropathy(ProteinSequence sequence) {\n\t\tint validLength = 0;\n\t\tdouble total = 0.0;\n\t\tAminoAcidCompoundSet aaSet = new AminoAcidCompoundSet();\n\t\tchar[] seq = this.getSequence(sequence.toString(), true);\n\t\tfor(char aa:seq){\n\t\t\tAminoAcidCompound c = aaSet.getCompoundForString(String.valueOf(aa));\n\t\t\tif(Constraints.aa2Hydrophathicity.containsKey(c)){\n\t\t\t\ttotal += Constraints.aa2Hydrophathicity.get(c);\n\t\t\t\tvalidLength++;\n\t\t\t}\n\t\t}\n\t\tif (validLength==0) {\n\t\t\tlogger.warn(\"Valid length of sequence is 0, can't divide by 0 to calculate average hydropathy: setting average hydropathy to 0\");\n\t\t\treturn 0.0;\n\t\t}\n\n\t\treturn total / validLength;\n\t}\n\n\t@Override\n\tpublic double getIsoelectricPoint(ProteinSequence sequence, boolean useExpasyValues) {\n\t\tif(useExpasyValues){\n\t\t\treturn this.getIsoelectricPointExpasy(sequence.toString().toUpperCase());\n\t\t}else{\n\t\t\treturn this.getIsoelectricPointInnovagen(sequence);\n\t\t}\n\t}\n\n\tprivate double getIsoelectricPointInnovagen(ProteinSequence sequence){\n\t\tdouble currentPH = 7.0;\n\t\tdouble changeSize = 7.0;\n\t\tString sequenceString = sequence.toString();\n\t\tchar nTerminalChar = sequenceString.charAt(0);\n\t\tchar cTerminalChar = sequenceString.charAt(sequenceString.length() - 1);\n\n\t\tMap<AminoAcidCompound, Integer> chargedAA2Count = this.getChargedAACount(sequence);\n\t\tdouble margin;\n\t\tfinal double difference = 0.0001;\n\n\t\twhile(true){\n\t\t\tmargin = this.getNetChargeInnovagen(chargedAA2Count, currentPH, nTerminalChar, cTerminalChar);\n\t\t\t\n\t\t\tif(margin <= difference && margin >= -difference) break;\n\t\t\tchangeSize /= 2.0;\n\t\t\tif(margin > 0){\n\t\t\t\tcurrentPH += changeSize;\n\t\t\t}else{\n\t\t\t\tcurrentPH -= changeSize;\n\t\t\t}\n\t\t}\n\t\treturn currentPH;\n\t}\n\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tprivate final double[][] cPk = {\n\t\t\t{3.55, 7.59, 0.0},  \n\t\t\t{3.55, 7.50, 0.0},  \n\t\t\t{3.55, 7.50, 9.00}, \n\n\n\t\t\t{3.55, 7.50, 4.05}, \n\t\t\t{3.55, 7.70, 4.45}, \n\t\t\t{3.55, 7.50, 0}, \n\t\t\t{3.55, 7.50, 0}, \n\t\t\t{3.55, 7.50, 5.98}, \n\t\t\t{3.55, 7.50, 0.0}, \n\t\t\t{0.0, 0.0, 0.0}, \n\t\t\t{3.55, 7.50, 10.00}, \n\t\t\t{3.55, 7.50, 0.0}, \n\t\t\t{3.55, 7.00, 0.0},\n\t\t\t{3.55, 7.50, 0.0},\n\t\t\t{0.00, 0.00, 0.0},\n\t\t\t{3.55, 8.36, 0.0},\n\t\t\t{3.55, 7.50, 0.0}, \n\t\t\t{3.55, 7.50, 12.0},\n\t\t\t{3.55, 6.93, 0.0},\n\t\t\t{3.55, 6.82, 0.0}, \n\t\t\t{0.00, 0.00, 0.0}, \n\t\t\t{3.55, 7.44, 0.0},\n\t\t\t{3.55, 7.50, 0.0},\n\t\t\t{3.55, 7.50, 0.0},\n\t\t\t{3.55, 7.50, 10.00},\n\t\t\t{3.55, 7.50, 0.0}}; \n\n\tprivate final double PH_MIN = 0.0; \n\tprivate final double PH_MAX = 14.0; \n\tprivate final double MAXLOOP = 2000.0; \n\tprivate final double EPSI = 0.0001; \n\n\tprivate double exp10(double pka){\n\t\treturn Math.pow(10, pka);\n\t}\n\n\tprivate double getIsoelectricPointExpasy(String sequence){\n\t\t\n\t\t\n\t\t\n\t\tint[] comp = new int[26];\n\t\tfor(int i = 0; i < sequence.length(); i++){\n\t\t\tint index = sequence.charAt(i) - 'A';\n\t\t\tif(index < 0 || index >= 26) continue;\n\t\t\tcomp[index]++;\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tint nTermResidue = -1;\n\t\tint index = 0;\n\t\twhile((nTermResidue < 0 || nTermResidue >= 26) && index < 25){\n\t\t\tnTermResidue = sequence.charAt(index++) - 'A';\n\t\t}\n\n\t\tint cTermResidue = -1;\n\t\tindex = 1;\n\t\twhile((cTermResidue < 0 || cTermResidue >= 26) && index < 25){\n\t\t\tcTermResidue = sequence.charAt(sequence.length() - index++) - 'A';\n\t\t}\n\n\t\tdouble phMin = PH_MIN;\n\t\tdouble phMax = PH_MAX;\n\n\t\tdouble phMid = 0.0;\n\t\tdouble charge = 1.0;\n\t\tfor (int i = 0; i < MAXLOOP && (phMax - phMin) > EPSI; i++){\n\t\t\tphMid = phMin + (phMax - phMin) / 2.0;\n\n\t\t\tcharge = getNetChargeExpasy(comp, nTermResidue, cTermResidue, phMid);\n\n\t\t\tif (charge > 0.0) phMin = phMid;\n\t\t\telse phMax = phMid;\n\t\t}\n\t\treturn phMid;\n\t}\n\n\t@Override\n\tpublic double getIsoelectricPoint(ProteinSequence sequence){\n\t\treturn getIsoelectricPoint(sequence, true);\n\t}\n\n\t@Override\n\tpublic double getNetCharge(ProteinSequence sequence) {\n\t\treturn getNetCharge(sequence, true);\n\t}\n\n\t@Override\n\tpublic double getNetCharge(ProteinSequence sequence, boolean useExpasyValues){\n\t\treturn getNetCharge(sequence, true, 7.0);\n\t}\n\n\t@Override\n\tpublic double getNetCharge(ProteinSequence sequence, boolean useExpasyValues, double pHPoint){\n\t\tif(useExpasyValues){\n\t\t\treturn getNetChargeExpasy(sequence.toString().toUpperCase(), pHPoint);\n\t\t}else{\n\t\t\treturn getNetChargeInnovagen(sequence, pHPoint);\n\t\t}\n\t}\n\n\tprivate double getNetChargeExpasy(String sequence, double pHPoint){\n\t\t\n\t\t\n\t\t\n\t\tint[] comp = new int[26];\n\t\tfor(int i = 0; i < sequence.length(); i++){\n\t\t\tint index = sequence.charAt(i) - 'A';\n\t\t\tif(index < 0 || index >= 26) continue;\n\t\t\tcomp[index]++;\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tint nTermResidue = sequence.charAt(0) - 'A';\n\t\tint cTermResidue = sequence.charAt(sequence.length() - 1) - 'A';\n\t\treturn getNetChargeExpasy(comp, nTermResidue, cTermResidue, pHPoint);\n\t}\n\n\tprivate double getNetChargeExpasy(int[] comp, int nTermResidue, int cTermResidue, double ph){\n\t\tdouble cter = 0.0;\n\t\tif(cTermResidue >= 0 && cTermResidue < 26) cter = exp10(-cPk[cTermResidue][0]) / (exp10(-cPk[cTermResidue][0]) + exp10(-ph));\n\t\tdouble nter = 0.0;\n\t\tif(nTermResidue >= 0 && nTermResidue < 26) nter = exp10(-ph) / (exp10(-cPk[nTermResidue][1]) + exp10(-ph));\n\n\t\tdouble carg = comp['R' - 'A'] * exp10(-ph) / (exp10(-cPk['R' - 'A'][2]) + exp10(-ph));\n\t\tdouble chis = comp['H' - 'A'] * exp10(-ph) / (exp10(-cPk['H' - 'A'][2]) + exp10(-ph));\n\t\tdouble clys = comp['K' - 'A'] * exp10(-ph) / (exp10(-cPk['K' - 'A'][2]) + exp10(-ph));\n\n\t\tdouble casp = comp['D' - 'A'] * exp10(-cPk['D' - 'A'][2]) / (exp10(-cPk['D' - 'A'][2]) + exp10(-ph));\n\t\tdouble cglu = comp['E' - 'A'] * exp10(-cPk['E' - 'A'][2]) / (exp10(-cPk['E' - 'A'][2]) + exp10(-ph));\n\n\t\tdouble ccys = comp['C' - 'A'] * exp10(-cPk['C' - 'A'][2]) / (exp10(-cPk['C' - 'A'][2]) + exp10(-ph));\n\t\tdouble ctyr = comp['Y' - 'A'] * exp10(-cPk['Y' - 'A'][2]) / (exp10(-cPk['Y' - 'A'][2]) + exp10(-ph));\n\n\t\treturn (carg + clys + chis + nter) - (casp + cglu + ctyr + ccys + cter);\n\t}\n\n\tprivate double getNetChargeInnovagen(ProteinSequence sequence, double pHPoint) {\n\t\tMap<AminoAcidCompound, Integer> chargedAA2Count = this.getChargedAACount(sequence);\n\t\tString sequenceString = sequence.getSequenceAsString();\n\t\treturn getNetChargeInnovagen(chargedAA2Count, pHPoint, sequenceString.charAt(0), sequenceString.charAt(sequenceString.length() - 1));\n\t}\n\n\tprivate double getNetChargeInnovagen(Map<AminoAcidCompound, Integer> chargedAA2Count, double ph, char nTerminalChar, char cTerminalChar){\n\t\t\n\n\t\t\n\t\t\n\t\tAminoAcidCompoundSet aaSet = new AminoAcidCompoundSet();\n\n\t\tdouble nTerminalCharge = 0.0;\n\t\tAminoAcidCompound nTermCompound = aaSet.getCompoundForString(String.valueOf(nTerminalChar));\n\t\tif(Constraints.aa2NTerminalPka.containsKey(nTermCompound)){\n\t\t\tnTerminalCharge = this.getPosCharge(Constraints.aa2NTerminalPka.get(nTermCompound), ph);\n\t\t}\n\n\t\tdouble cTerminalCharge = 0.0;\n\t\tAminoAcidCompound cTermCompound = aaSet.getCompoundForString(String.valueOf(cTerminalChar));\n\t\tif(Constraints.aa2CTerminalPka.containsKey(cTermCompound)){\n\t\t\tcTerminalCharge = this.getNegCharge(Constraints.aa2CTerminalPka.get(cTermCompound), ph);\n\t\t}\n\n\t\tdouble kCharge = chargedAA2Count.get(aaSet.getCompoundForString(\"K\")) * this.getPosCharge(Constraints.aa2PKa.get(aaSet.getCompoundForString(\"K\")), ph);\n\t\tdouble rCharge = chargedAA2Count.get(aaSet.getCompoundForString(\"R\")) * this.getPosCharge(Constraints.aa2PKa.get(aaSet.getCompoundForString(\"R\")), ph);\n\t\tdouble hCharge = chargedAA2Count.get(aaSet.getCompoundForString(\"H\")) * this.getPosCharge(Constraints.aa2PKa.get(aaSet.getCompoundForString(\"H\")), ph);\n\t\tdouble dCharge = chargedAA2Count.get(aaSet.getCompoundForString(\"D\")) * this.getNegCharge(Constraints.aa2PKa.get(aaSet.getCompoundForString(\"D\")), ph);\n\t\tdouble eCharge = chargedAA2Count.get(aaSet.getCompoundForString(\"E\")) * this.getNegCharge(Constraints.aa2PKa.get(aaSet.getCompoundForString(\"E\")), ph);\n\t\tdouble cCharge = chargedAA2Count.get(aaSet.getCompoundForString(\"C\")) * this.getNegCharge(Constraints.aa2PKa.get(aaSet.getCompoundForString(\"C\")), ph);\n\t\tdouble yCharge = chargedAA2Count.get(aaSet.getCompoundForString(\"Y\")) * this.getNegCharge(Constraints.aa2PKa.get(aaSet.getCompoundForString(\"Y\")), ph);\n\n\n\n\t\treturn (nTerminalCharge + kCharge + rCharge + hCharge) - (dCharge + eCharge + cCharge + yCharge + cTerminalCharge);\n\t}\n\n\tprivate double getPosCharge(double pka, double ph){\n\t\treturn Math.pow(10, pka) / (Math.pow(10, pka) + Math.pow(10, ph));\n\t}\n\n\tprivate double getNegCharge(double pka, double ph){\n\t\treturn Math.pow(10, ph) / (Math.pow(10, pka) + Math.pow(10, ph));\n\t}\n\n\tprivate Map<AminoAcidCompound, Integer> getChargedAACount(ProteinSequence sequence){\n\t\t\n\t\t\n\t\tint numK = 0;\n\t\tint numR = 0;\n\t\tint numH = 0;\n\t\tint numD = 0;\n\t\tint numE = 0;\n\t\tint numC = 0;\n\t\tint numY = 0;\n\t\tchar[] seq = this.getSequence(sequence.getSequenceAsString(), true);\n\t\tfor(char aa:seq){\n\t\t\tswitch(aa){\n\t\t\tcase 'K': numK++; break;\n\t\t\tcase 'R': numR++; break;\n\t\t\tcase 'H': numH++; break;\n\t\t\tcase 'D': numD++; break;\n\t\t\tcase 'E': numE++; break;\n\t\t\tcase 'C': numC++; break;\n\t\t\tcase 'Y': numY++; break;\n\t\t\t}\n\t\t}\n\t\tAminoAcidCompoundSet aaSet = new AminoAcidCompoundSet();\n\t\tMap<AminoAcidCompound, Integer> chargedAA2Count = new HashMap<AminoAcidCompound, Integer>();\n\t\tchargedAA2Count.put(aaSet.getCompoundForString(\"K\"), numK);\n\t\tchargedAA2Count.put(aaSet.getCompoundForString(\"R\"), numR);\n\t\tchargedAA2Count.put(aaSet.getCompoundForString(\"H\"), numH);\n\t\tchargedAA2Count.put(aaSet.getCompoundForString(\"D\"), numD);\n\t\tchargedAA2Count.put(aaSet.getCompoundForString(\"E\"), numE);\n\t\tchargedAA2Count.put(aaSet.getCompoundForString(\"C\"), numC);\n\t\tchargedAA2Count.put(aaSet.getCompoundForString(\"Y\"), numY);\n\t\treturn chargedAA2Count;\n\t}\n\n\t@Override\n\tpublic double getEnrichment(ProteinSequence sequence, AminoAcidCompound aminoAcidCode) {\n\t\tdouble counter = 0.0;\n\t\tchar[] seq = this.getSequence(sequence.getSequenceAsString(), true);\n\t\tfor(char aa:seq){\n\t\t\tif(aminoAcidCode.getShortName().equals(String.valueOf(aa))){\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t}\n\t\treturn counter/sequence.getLength();\n\t}\n\n\t@Override\n\tpublic Map<AminoAcidCompound, Double> getAAComposition(ProteinSequence sequence) {\n\t\tint validLength = 0;\n\t\tMap<AminoAcidCompound, Double> aa2Composition = new HashMap<AminoAcidCompound, Double>();\n\t\tAminoAcidCompoundSet aaSet = new AminoAcidCompoundSet();\n\t\tfor(AminoAcidCompound aa:aaSet.getAllCompounds()){\n\t\t\taa2Composition.put(aa, 0.0);\n\t\t}\n\t\tchar[] seq = this.getSequence(sequence.toString(), true);\n\t\tfor(char aa:seq){\n\t\t\tif(PeptideProperties.standardAASet.contains(aa)){\n\t\t\t\tAminoAcidCompound compound = aaSet.getCompoundForString(String.valueOf(aa));\n\t\t\t\taa2Composition.put(compound, aa2Composition.get(compound) + 1.0);\n\t\t\t\tvalidLength++;\n\t\t\t}\n\t\t}\n\t\tif(validLength > 0){\n\t\t\tfor(AminoAcidCompound aa:aaSet.getAllCompounds()){\n\t\t\t\taa2Composition.put(aa, aa2Composition.get(aa) / validLength);\n\t\t\t}\n\t\t}else{\n\t\t\tfor(AminoAcidCompound aa:aaSet.getAllCompounds()){\n\t\t\t\taa2Composition.put(aa, 0.0);\n\t\t\t}\n\t\t}\n\t\treturn aa2Composition;\n\t}\n\n\n\t@Override\n\tpublic double getAromaticity(ProteinSequence sequence) {\n\t\tint validLength = sequence.getSequenceAsString().length();\n\n\t\tif (validLength == 0) {\n\t\t\tlogger.warn(\"Valid length of sequence is 0, can't divide by 0 to calculate aromaticity: setting aromaticity to 0\");\n\t\t\treturn 0.0;\n\t\t}\n\n\t\t\n\t\tint totalF = 0;\n\t\t\n\t\tint totalY = 0;\n\t\t\n\t\tint totalW = 0;\n\n\t\tchar[] seq = this.getSequence(sequence.toString(), true);\n\t\tfor (char aa : seq) {\n\t\t\tchar amino = Character.toUpperCase(aa);\n\t\t\tswitch (amino) {\n\t\t\t\tcase 'F':\n\t\t\t\t\ttotalF++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Y':\n\t\t\t\t\ttotalY++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'W':\n\t\t\t\t\ttotalW++;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn (totalF + totalY + totalW) / (double) (validLength);\n\t}\n}\n\n"
    ],
    "1": [
        "package org.biojava.nbio.aaproperties;\n\nimport org.biojava.nbio.aaproperties.xml.AminoAcidCompositionTable;\nimport org.biojava.nbio.aaproperties.xml.ElementTable;\nimport org.biojava.nbio.aaproperties.xml.MyValidationEventHandler;\nimport org.biojava.nbio.core.sequence.ProteinSequence;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompound;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompoundSet;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport jakarta.xml.bind.JAXBContext;\nimport jakarta.xml.bind.JAXBException;\nimport jakarta.xml.bind.Unmarshaller;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class PeptidePropertiesImpl implements IPeptideProperties{\n    private final static Logger logger = LoggerFactory.getLogger(PeptidePropertiesImpl.class);\n\n    \n    private static final AminoAcidCompoundSet AA_SET = new AminoAcidCompoundSet();\n\n    \n    private static final Map<Character, AminoAcidCompound> AA_CHAR_MAP = new HashMap<>();\n    static {\n        for (AminoAcidCompound aa : AA_SET.getAllCompounds()) {\n            String shortName = aa.getShortName();\n            if (shortName != null && shortName.length() == 1) {\n                char c = shortName.charAt(0);\n                AA_CHAR_MAP.put(Character.toUpperCase(c), aa);\n            }\n        }\n    }\n\n    private double getWaterMoleculeWeight(){\n        final double hydrogenMW = 1.0079;\n        final double hydroxideMW = 17.0073;\n        return hydrogenMW + hydroxideMW;\n    }\n\n    private char[] getSequence(String sequence, boolean ignoreCase){\n        if(ignoreCase){\n            return sequence.toUpperCase().toCharArray();\n        }else{\n            return sequence.toCharArray();\n        }\n    }\n\n    private AminoAcidCompound getCompoundForChar(char aa) {\n        return AA_CHAR_MAP.get(aa);\n    }\n\n    @Override\n    public double getMolecularWeight(ProteinSequence sequence) {\n        double value1 = 0.0, value2 = 0.0;\n        char[] seq = getSequence(sequence.toString(), true);\n        int i = 0;\n        for (; i + 1 < seq.length; i += 2) {\n            AminoAcidCompound c1 = getCompoundForChar(seq[i]);\n            AminoAcidCompound c2 = getCompoundForChar(seq[i+1]);\n            if (c1 != null && Constraints.aa2MolecularWeight.containsKey(c1)) {\n                value1 += Constraints.aa2MolecularWeight.get(c1);\n            }\n            if (c2 != null && Constraints.aa2MolecularWeight.containsKey(c2)) {\n                value2 += Constraints.aa2MolecularWeight.get(c2);\n            }\n        }\n        if (i < seq.length) {\n            AminoAcidCompound c = getCompoundForChar(seq[i]);\n            if (c != null && Constraints.aa2MolecularWeight.containsKey(c)) {\n                value1 += Constraints.aa2MolecularWeight.get(c);\n            }\n        }\n        double value = value1 + value2;\n        if(value == 0)\n            return value;\n        else\n            return value + getWaterMoleculeWeight();\n    }\n\n    @Override\n    public double getMolecularWeight(ProteinSequence sequence, File aminoAcidCompositionFile) throws JAXBException, FileNotFoundException {\n        File elementMassFile = new File(\"./src/main/resources/ElementMass.xml\");\n        if(!elementMassFile.exists()){\n            throw new FileNotFoundException(\"Cannot locate ElementMass.xml. \" +\n                    \"Please use getMolecularWeight(ProteinSequence, File, File) to specify ElementMass.xml location.\");\n        }\n        return getMolecularWeightBasedOnXML(sequence, obtainAminoAcidCompositionTable(elementMassFile, aminoAcidCompositionFile));\n    }\n\n    @Override\n    public double getMolecularWeight(ProteinSequence sequence, File elementMassFile, File aminoAcidCompositionFile)\n            throws JAXBException, FileNotFoundException{\n        return getMolecularWeightBasedOnXML(sequence, obtainAminoAcidCompositionTable(elementMassFile, aminoAcidCompositionFile));\n    }\n\n    @Override\n    public double getMolecularWeightBasedOnXML(ProteinSequence sequence, AminoAcidCompositionTable aminoAcidCompositionTable){\n        double value1 = 0.0, value2 = 0.0;\n        char[] seq = sequence.toString().toCharArray();\n        int i = 0;\n        for (; i + 1 < seq.length; i += 2) {\n            Double w1 = aminoAcidCompositionTable.getMolecularWeight(seq[i]);\n            Double w2 = aminoAcidCompositionTable.getMolecularWeight(seq[i+1]);\n            if (w1 != null) value1 += w1;\n            if (w2 != null) value2 += w2;\n        }\n        if (i < seq.length) {\n            Double w = aminoAcidCompositionTable.getMolecularWeight(seq[i]);\n            if (w != null) value1 += w;\n        }\n        double value = value1 + value2;\n        if(value == 0.0)\n            return value;\n        else\n            return value + getWaterMoleculeWeight();\n    }\n\n    @Override\n    public AminoAcidCompositionTable obtainAminoAcidCompositionTable(File aminoAcidCompositionFile)\n        throws JAXBException, FileNotFoundException{\n        File elementMassFile = new File(\"./src/main/resources/ElementMass.xml\");\n        if(!elementMassFile.exists()){\n            throw new FileNotFoundException(\"Cannot locate ElementMass.xml. \" +\n                    \"Please use getMolecularWeight(ProteinSequence, File, File) to specify ElementMass.xml location.\");\n        }\n        return obtainAminoAcidCompositionTable(elementMassFile, aminoAcidCompositionFile);\n    }\n\n    @Override\n    public AminoAcidCompositionTable obtainAminoAcidCompositionTable(File elementMassFile, File aminoAcidCompositionFile)\n        throws JAXBException, FileNotFoundException{\n        ElementTable iTable = new ElementTable();\n        JAXBContext jc = JAXBContext.newInstance(iTable.getClass());\n        Unmarshaller u = jc.createUnmarshaller();\n        u.setEventHandler(new MyValidationEventHandler());\n        iTable = (ElementTable)u.unmarshal(new FileInputStream(elementMassFile));\n        iTable.populateMaps();\n        AminoAcidCompositionTable aTable = new AminoAcidCompositionTable();\n        JAXBContext jc2 = JAXBContext.newInstance(aTable.getClass());\n        Unmarshaller u2 = jc2.createUnmarshaller();\n        u2.setEventHandler(new MyValidationEventHandler());\n        aTable = (AminoAcidCompositionTable)u2.unmarshal(new FileInputStream(aminoAcidCompositionFile));\n        aTable.computeMolecularWeight(iTable);\n        return aTable;\n    }\n\n    @Override\n    public double getExtinctionCoefficient(ProteinSequence sequence, boolean assumeCysReduced) {\n        Map<AminoAcidCompound, Integer> extinctAA2Count = this.getExtinctAACount(sequence);\n        double eProt;\n        if(!assumeCysReduced){\n            eProt = extinctAA2Count.get(getCompoundForChar('Y')) *\n                Constraints.aa2ExtinctionCoefficient.get(getCompoundForChar('Y')) +\n                extinctAA2Count.get(getCompoundForChar('W')) *\n                Constraints.aa2ExtinctionCoefficient.get(getCompoundForChar('W')) +\n                extinctAA2Count.get(getCompoundForChar('C')) *\n                Constraints.aa2ExtinctionCoefficient.get(getCompoundForChar('C'));\n        }else\n            eProt = extinctAA2Count.get(getCompoundForChar('Y')) *\n                Constraints.aa2ExtinctionCoefficient.get(getCompoundForChar('Y')) +\n                extinctAA2Count.get(getCompoundForChar('W')) *\n                Constraints.aa2ExtinctionCoefficient.get(getCompoundForChar('W'));\n        return eProt;\n    }\n\n    @Override\n    public double getAbsorbance(ProteinSequence sequence, boolean assumeCysReduced){\n        double mw = this.getMolecularWeight(sequence);\n        double eProt = this.getExtinctionCoefficient(sequence, assumeCysReduced);\n        if (mw == 0.0) {\n            logger.warn(\"Molecular weight is 0.0, can't divide by 0: setting absorbance to 0.0\");\n            return 0.0;\n        }\n        return eProt / mw;\n    }\n\n    private Map<AminoAcidCompound, Integer> getExtinctAACount(ProteinSequence sequence){\n        int numW = 0, smallW = 0, numY = 0, smallY = 0;\n        double numC = 0, smallC = 0;\n        char[] seq = sequence.getSequenceAsString().toCharArray();\n        for(char aa:seq){\n            switch(aa){\n            case 'W': numW++; break;\n            case 'w': smallW++; break;\n            case 'C': numC += 0.5; break;\n            case 'c': smallC += 0.5; break;\n            case 'Y': numY++; break;\n            case 'y': smallY++; break;\n            }\n        }\n        Map<AminoAcidCompound, Integer> extinctAA2Count = new HashMap<>();\n        extinctAA2Count.put(getCompoundForChar('W'), numW + smallW);\n        extinctAA2Count.put(getCompoundForChar('C'), (int) (numC + smallC));\n        extinctAA2Count.put(getCompoundForChar('Y'), numY + smallY);\n        return extinctAA2Count;\n    }\n\n    @Override\n    public double getInstabilityIndex(ProteinSequence sequence) {\n        double sum1 = 0.0, sum2 = 0.0;\n        String s = sequence.getSequenceAsString().toUpperCase();\n        int i = 0;\n        for (; i + 1 < sequence.getLength() - 1; i += 2) {\n            String dipeptide1 = s.substring(i, i+2);\n            String dipeptide2 = s.substring(i+1, i+3);\n            if(Constraints.diAA2Instability.containsKey(dipeptide1))\n                sum1 += Constraints.diAA2Instability.get(dipeptide1);\n            if(Constraints.diAA2Instability.containsKey(dipeptide2))\n                sum2 += Constraints.diAA2Instability.get(dipeptide2);\n        }\n        if (i < sequence.getLength() - 1) {\n            String dipeptide = s.substring(i, i+2);\n            if(Constraints.diAA2Instability.containsKey(dipeptide))\n                sum1 += Constraints.diAA2Instability.get(dipeptide);\n        }\n        int denominator = s.length() - Utils.getNumberOfInvalidChar(s, null, true);\n        if (denominator==0) {\n            logger.warn(\"Valid length of sequence is 0, can't divide by 0 to calculate instability index: setting instability index value to 0.0\");\n            return 0.0;\n        }\n        return (sum1 + sum2) * 10.0 / denominator;\n    }\n\n    @Override\n    public double getApliphaticIndex(ProteinSequence sequence) {\n        Map<AminoAcidCompound, Double> aa2Composition = getAAComposition(sequence);\n        final double a = 2.9;\n        final double b = 3.9;\n        double xAla = aa2Composition.get(getCompoundForChar('A'));\n        double xVal = aa2Composition.get(getCompoundForChar('V'));\n        double xIle = aa2Composition.get(getCompoundForChar('I'));\n        double xLeu = aa2Composition.get(getCompoundForChar('L'));\n        return (xAla + (a * xVal) + (b * (xIle + xLeu))) * 100;\n    }\n\n    @Override\n    public double getAvgHydropathy(ProteinSequence sequence) {\n        int validLength = 0;\n        double total1 = 0.0, total2 = 0.0;\n        char[] seq = this.getSequence(sequence.toString(), true);\n        int i = 0;\n        for (; i + 1 < seq.length; i += 2) {\n            AminoAcidCompound c1 = getCompoundForChar(seq[i]);\n            AminoAcidCompound c2 = getCompoundForChar(seq[i+1]);\n            if(c1 != null && Constraints.aa2Hydrophathicity.containsKey(c1)){\n                total1 += Constraints.aa2Hydrophathicity.get(c1);\n                validLength++;\n            }\n            if(c2 != null && Constraints.aa2Hydrophathicity.containsKey(c2)){\n                total2 += Constraints.aa2Hydrophathicity.get(c2);\n                validLength++;\n            }\n        }\n        if (i < seq.length) {\n            AminoAcidCompound c = getCompoundForChar(seq[i]);\n            if(c != null && Constraints.aa2Hydrophathicity.containsKey(c)){\n                total1 += Constraints.aa2Hydrophathicity.get(c);\n                validLength++;\n            }\n        }\n        if (validLength==0) {\n            logger.warn(\"Valid length of sequence is 0, can't divide by 0 to calculate average hydropathy: setting average hydropathy to 0\");\n            return 0.0;\n        }\n        return (total1 + total2) / validLength;\n    }\n\n    @Override\n    public double getIsoelectricPoint(ProteinSequence sequence, boolean useExpasyValues) {\n        if(useExpasyValues){\n            return this.getIsoelectricPointExpasy(sequence.toString().toUpperCase());\n        }else{\n            return this.getIsoelectricPointInnovagen(sequence);\n        }\n    }\n\n    @Override\n    public double getIsoelectricPoint(ProteinSequence sequence){\n        return getIsoelectricPoint(sequence, true);\n    }\n\n    \n    \n\n    private final double[][] cPk = {\n            {3.55, 7.59, 0.0},  \n            {3.55, 7.50, 0.0},  \n            {3.55, 7.50, 9.00},\n            {3.55, 7.50, 4.05}, \n            {3.55, 7.70, 4.45}, \n            {3.55, 7.50, 0}, \n            {3.55, 7.50, 0}, \n            {3.55, 7.50, 5.98}, \n            {3.55, 7.50, 0.0}, \n            {0.0, 0.0, 0.0}, \n            {3.55, 7.50, 10.00}, \n            {3.55, 7.50, 0.0}, \n            {3.55, 7.00, 0.0},\n            {3.55, 7.50, 0.0},\n            {0.00, 0.00, 0.0},\n            {3.55, 8.36, 0.0},\n            {3.55, 7.50, 0.0}, \n            {3.55, 7.50, 12.0},\n            {3.55, 6.93, 0.0},\n            {3.55, 6.82, 0.0}, \n            {0.00, 0.00, 0.0}, \n            {3.55, 7.44, 0.0},\n            {3.55, 7.50, 0.0},\n            {3.55, 7.50, 0.0},\n            {3.55, 7.50, 10.00},\n            {3.55, 7.50, 0.0}}; \n\n    private final double PH_MIN = 0.0; \n    private final double PH_MAX = 14.0; \n    private final double MAXLOOP = 2000.0; \n    private final double EPSI = 0.0001; \n\n    private double exp10(double pka){\n        return Math.pow(10, pka);\n    }\n\n    private double getIsoelectricPointExpasy(String sequence){\n        int[] comp = new int[26];\n        for(int i = 0; i < sequence.length(); i++){\n            int index = sequence.charAt(i) - 'A';\n            if(index < 0 || index >= 26) continue;\n            comp[index]++;\n        }\n        int nTermResidue = -1;\n        int index = 0;\n        while((nTermResidue < 0 || nTermResidue >= 26) && index < 25){\n            nTermResidue = sequence.charAt(index++) - 'A';\n        }\n        int cTermResidue = -1;\n        index = 1;\n        while((cTermResidue < 0 || cTermResidue >= 26) && index < 25){\n            cTermResidue = sequence.charAt(sequence.length() - index++) - 'A';\n        }\n        double phMin = PH_MIN;\n        double phMax = PH_MAX;\n        double phMid = 0.0;\n        double charge = 1.0;\n        for (int i = 0; i < MAXLOOP && (phMax - phMin) > EPSI; i++){\n            phMid = phMin + (phMax - phMin) / 2.0;\n            charge = getNetChargeExpasy(comp, nTermResidue, cTermResidue, phMid);\n            if (charge > 0.0) phMin = phMid;\n            else phMax = phMid;\n        }\n        return phMid;\n    }\n\n    private double getIsoelectricPointInnovagen(ProteinSequence sequence){\n        double currentPH = 7.0;\n        double changeSize = 7.0;\n        String sequenceString = sequence.toString();\n        char nTerminalChar = sequenceString.charAt(0);\n        char cTerminalChar = sequenceString.charAt(sequenceString.length() - 1);\n        Map<AminoAcidCompound, Integer> chargedAA2Count = this.getChargedAACount(sequence);\n        double margin;\n        final double difference = 0.0001;\n        while(true){\n            margin = this.getNetChargeInnovagen(chargedAA2Count, currentPH, nTerminalChar, cTerminalChar);\n            if(margin <= difference && margin >= -difference) break;\n            changeSize /= 2.0;\n            if(margin > 0){\n                currentPH += changeSize;\n            }else{\n                currentPH -= changeSize;\n            }\n        }\n        return currentPH;\n    }\n\n    @Override\n    public double getNetCharge(ProteinSequence sequence) {\n        return getNetCharge(sequence, true);\n    }\n\n    @Override\n    public double getNetCharge(ProteinSequence sequence, boolean useExpasyValues){\n        return getNetCharge(sequence, useExpasyValues, 7.0);\n    }\n\n    @Override\n    public double getNetCharge(ProteinSequence sequence, boolean useExpasyValues, double pHPoint){\n        if(useExpasyValues){\n            return getNetChargeExpasy(sequence.toString().toUpperCase(), pHPoint);\n        }else{\n            return getNetChargeInnovagen(sequence, pHPoint);\n        }\n    }\n\n    private double getNetChargeExpasy(String sequence, double pHPoint){\n        int[] comp = new int[26];\n        for(int i = 0; i < sequence.length(); i++){\n            int index = sequence.charAt(i) - 'A';\n            if(index < 0 || index >= 26) continue;\n            comp[index]++;\n        }\n        int nTermResidue = sequence.charAt(0) - 'A';\n        int cTermResidue = sequence.charAt(sequence.length() - 1) - 'A';\n        return getNetChargeExpasy(comp, nTermResidue, cTermResidue, pHPoint);\n    }\n\n    private double getNetChargeExpasy(int[] comp, int nTermResidue, int cTermResidue, double ph){\n        double cter = 0.0;\n        if(cTermResidue >= 0 && cTermResidue < 26) cter = exp10(-cPk[cTermResidue][0]) / (exp10(-cPk[cTermResidue][0]) + exp10(-ph));\n        double nter = 0.0;\n        if(nTermResidue >= 0 && nTermResidue < 26) nter = exp10(-ph) / (exp10(-cPk[nTermResidue][1]) + exp10(-ph));\n        double carg = comp['R' - 'A'] * exp10(-ph) / (exp10(-cPk['R' - 'A'][2]) + exp10(-ph));\n        double chis = comp['H' - 'A'] * exp10(-ph) / (exp10(-cPk['H' - 'A'][2]) + exp10(-ph));\n        double clys = comp['K' - 'A'] * exp10(-ph) / (exp10(-cPk['K' - 'A'][2]) + exp10(-ph));\n        double casp = comp['D' - 'A'] * exp10(-cPk['D' - 'A'][2]) / (exp10(-cPk['D' - 'A'][2]) + exp10(-ph));\n        double cglu = comp['E' - 'A'] * exp10(-cPk['E' - 'A'][2]) / (exp10(-cPk['E' - 'A'][2]) + exp10(-ph));\n        double ccys = comp['C' - 'A'] * exp10(-cPk['C' - 'A'][2]) / (exp10(-cPk['C' - 'A'][2]) + exp10(-ph));\n        double ctyr = comp['Y' - 'A'] * exp10(-cPk['Y' - 'A'][2]) / (exp10(-cPk['Y' - 'A'][2]) + exp10(-ph));\n        return (carg + clys + chis + nter) - (casp + cglu + ctyr + ccys + cter);\n    }\n\n    private double getNetChargeInnovagen(ProteinSequence sequence, double pHPoint) {\n        Map<AminoAcidCompound, Integer> chargedAA2Count = this.getChargedAACount(sequence);\n        String sequenceString = sequence.getSequenceAsString();\n        return getNetChargeInnovagen(chargedAA2Count, pHPoint, sequenceString.charAt(0), sequenceString.charAt(sequenceString.length() - 1));\n    }\n\n    private double getNetChargeInnovagen(Map<AminoAcidCompound, Integer> chargedAA2Count, double ph, char nTerminalChar, char cTerminalChar){\n        double nTerminalCharge = 0.0;\n        AminoAcidCompound nTermCompound = getCompoundForChar(nTerminalChar);\n        if(nTermCompound != null && Constraints.aa2NTerminalPka.containsKey(nTermCompound)){\n            nTerminalCharge = this.getPosCharge(Constraints.aa2NTerminalPka.get(nTermCompound), ph);\n        }\n        double cTerminalCharge = 0.0;\n        AminoAcidCompound cTermCompound = getCompoundForChar(cTerminalChar);\n        if(cTermCompound != null && Constraints.aa2CTerminalPka.containsKey(cTermCompound)){\n            cTerminalCharge = this.getNegCharge(Constraints.aa2CTerminalPka.get(cTermCompound), ph);\n        }\n        double kCharge = chargedAA2Count.get(getCompoundForChar('K')) * this.getPosCharge(Constraints.aa2PKa.get(getCompoundForChar('K')), ph);\n        double rCharge = chargedAA2Count.get(getCompoundForChar('R')) * this.getPosCharge(Constraints.aa2PKa.get(getCompoundForChar('R')), ph);\n        double hCharge = chargedAA2Count.get(getCompoundForChar('H')) * this.getPosCharge(Constraints.aa2PKa.get(getCompoundForChar('H')), ph);\n        double dCharge = chargedAA2Count.get(getCompoundForChar('D')) * this.getNegCharge(Constraints.aa2PKa.get(getCompoundForChar('D')), ph);\n        double eCharge = chargedAA2Count.get(getCompoundForChar('E')) * this.getNegCharge(Constraints.aa2PKa.get(getCompoundForChar('E')), ph);\n        double cCharge = chargedAA2Count.get(getCompoundForChar('C')) * this.getNegCharge(Constraints.aa2PKa.get(getCompoundForChar('C')), ph);\n        double yCharge = chargedAA2Count.get(getCompoundForChar('Y')) * this.getNegCharge(Constraints.aa2PKa.get(getCompoundForChar('Y')), ph);\n        return (nTerminalCharge + kCharge + rCharge + hCharge) - (dCharge + eCharge + cCharge + yCharge + cTerminalCharge);\n    }\n\n    private double getPosCharge(double pka, double ph){\n        return Math.pow(10, pka) / (Math.pow(10, pka) + Math.pow(10, ph));\n    }\n\n    private double getNegCharge(double pka, double ph){\n        return Math.pow(10, ph) / (Math.pow(10, pka) + Math.pow(10, ph));\n    }\n\n    private Map<AminoAcidCompound, Integer> getChargedAACount(ProteinSequence sequence){\n        int numK = 0, numR = 0, numH = 0, numD = 0, numE = 0, numC = 0, numY = 0;\n        char[] seq = this.getSequence(sequence.getSequenceAsString(), true);\n        for(char aa:seq){\n            switch(aa){\n            case 'K': numK++; break;\n            case 'R': numR++; break;\n            case 'H': numH++; break;\n            case 'D': numD++; break;\n            case 'E': numE++; break;\n            case 'C': numC++; break;\n            case 'Y': numY++; break;\n            }\n        }\n        Map<AminoAcidCompound, Integer> chargedAA2Count = new HashMap<>();\n        chargedAA2Count.put(getCompoundForChar('K'), numK);\n        chargedAA2Count.put(getCompoundForChar('R'), numR);\n        chargedAA2Count.put(getCompoundForChar('H'), numH);\n        chargedAA2Count.put(getCompoundForChar('D'), numD);\n        chargedAA2Count.put(getCompoundForChar('E'), numE);\n        chargedAA2Count.put(getCompoundForChar('C'), numC);\n        chargedAA2Count.put(getCompoundForChar('Y'), numY);\n        return chargedAA2Count;\n    }\n\n    @Override\n    public double getEnrichment(ProteinSequence sequence, AminoAcidCompound aminoAcidCode) {\n        double counter = 0.0;\n        char[] seq = this.getSequence(sequence.getSequenceAsString(), true);\n        String code = aminoAcidCode.getShortName();\n        if (code != null && code.length() == 1) {\n            char target = code.charAt(0);\n            for(char aa:seq){\n                if(aa == target){\n                    counter++;\n                }\n            }\n        }\n        return counter/sequence.getLength();\n    }\n\n    @Override\n    public Map<AminoAcidCompound, Double> getAAComposition(ProteinSequence sequence) {\n        int validLength = 0;\n        Map<AminoAcidCompound, Double> aa2Composition = new HashMap<>();\n        for(AminoAcidCompound aa:AA_SET.getAllCompounds()){\n            aa2Composition.put(aa, 0.0);\n        }\n        char[] seq = this.getSequence(sequence.toString(), true);\n        for(char aa:seq){\n            if(PeptideProperties.standardAASet.contains(aa)){\n                AminoAcidCompound compound = getCompoundForChar(aa);\n                if (compound != null) {\n                    aa2Composition.put(compound, aa2Composition.get(compound) + 1.0);\n                    validLength++;\n                }\n            }\n        }\n        if(validLength > 0){\n            for(AminoAcidCompound aa:AA_SET.getAllCompounds()){\n                aa2Composition.put(aa, aa2Composition.get(aa) / validLength);\n            }\n        }else{\n            for(AminoAcidCompound aa:AA_SET.getAllCompounds()){\n                aa2Composition.put(aa, 0.0);\n            }\n        }\n        return aa2Composition;\n    }\n\n    @Override\n    public double getAromaticity(ProteinSequence sequence) {\n        int validLength = sequence.getSequenceAsString().length();\n        if (validLength == 0) {\n            logger.warn(\"Valid length of sequence is 0, can't divide by 0 to calculate aromaticity: setting aromaticity to 0\");\n            return 0.0;\n        }\n        int totalF = 0, totalY = 0, totalW = 0;\n        char[] seq = this.getSequence(sequence.toString(), true);\n        for (char aa : seq) {\n            switch (aa) {\n                case 'F': totalF++; break;\n                case 'Y': totalY++; break;\n                case 'W': totalW++; break;\n            }\n        }\n        return (totalF + totalY + totalW) / (double) (validLength);\n    }\n}\n"
    ],
    "2": [
        "package org.biojava.nbio.aaproperties;\n\nimport org.biojava.nbio.aaproperties.xml.AminoAcidCompositionTable;\nimport org.biojava.nbio.aaproperties.xml.ElementTable;\nimport org.biojava.nbio.aaproperties.xml.MyValidationEventHandler;\nimport org.biojava.nbio.core.sequence.ProteinSequence;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompound;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompoundSet;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport jakarta.xml.bind.JAXBContext;\nimport jakarta.xml.bind.JAXBException;\nimport jakarta.xml.bind.Unmarshaller;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class PeptidePropertiesImpl implements IPeptideProperties {\n    private final static Logger logger = LoggerFactory.getLogger(PeptidePropertiesImpl.class);\n    private static final AminoAcidCompoundSet AA_SET = new AminoAcidCompoundSet();\n    private static final Map<Character, AminoAcidCompound> AA_CHAR_MAP = new HashMap<>();\n    static {\n        for (AminoAcidCompound aa : AA_SET.getAllCompounds()) {\n            String shortName = aa.getShortName();\n            if (shortName != null && shortName.length() == 1) {\n                char c = shortName.charAt(0);\n                AA_CHAR_MAP.put(Character.toUpperCase(c), aa);\n            }\n        }\n    }\n\n    \n    private static final double[] AA_MW = new double[26];\n    private static final double[] AA_HYDROPATHY = new double[26];\n    private static final double[][] AA_DIPEPTIDE_INSTABILITY = new double[26][26];\n    static {\n        \n        for (char c = 'A'; c <= 'Z'; c++) {\n            AminoAcidCompound aa = AA_CHAR_MAP.get(c);\n            int idx = c - 'A';\n            if (aa != null) {\n                Double mw = Constraints.aa2MolecularWeight.get(aa);\n                AA_MW[idx] = mw == null ? 0.0 : mw;\n                Double hyd = Constraints.aa2Hydrophathicity.get(aa);\n                AA_HYDROPATHY[idx] = hyd == null ? 0.0 : hyd;\n            } else {\n                AA_MW[idx] = 0.0;\n                AA_HYDROPATHY[idx] = 0.0;\n            }\n        }\n        \n        for (Map.Entry<String, Double> e : Constraints.diAA2Instability.entrySet()) {\n            String k = e.getKey();\n            if (k.length() == 2) {\n                int i = k.charAt(0) - 'A';\n                int j = k.charAt(1) - 'A';\n                if (i >= 0 && i < 26 && j >= 0 && j < 26) {\n                    AA_DIPEPTIDE_INSTABILITY[i][j] = e.getValue();\n                }\n            }\n        }\n    }\n\n    private double getWaterMoleculeWeight() {\n        final double hydrogenMW = 1.0079;\n        final double hydroxideMW = 17.0073;\n        return hydrogenMW + hydroxideMW;\n    }\n\n    private char[] getSequence(String sequence, boolean ignoreCase) {\n        if (ignoreCase) {\n            return sequence.toUpperCase().toCharArray();\n        } else {\n            return sequence.toCharArray();\n        }\n    }\n\n    private AminoAcidCompound getCompoundForChar(char aa) {\n        return AA_CHAR_MAP.get(aa);\n    }\n\n    @Override\n    public double getMolecularWeight(ProteinSequence sequence) {\n        double value = 0.0;\n        char[] seq = getSequence(sequence.toString(), true);\n        for (int i = 0; i < seq.length; i++) {\n            char c = seq[i];\n            if (c >= 'A' && c <= 'Z') {\n                value += AA_MW[c - 'A'];\n            }\n        }\n        if (value == 0)\n            return value;\n        else\n            return value + getWaterMoleculeWeight();\n    }\n\n    @Override\n    public double getMolecularWeight(ProteinSequence sequence, File aminoAcidCompositionFile) throws JAXBException, FileNotFoundException {\n        File elementMassFile = new File(\"./src/main/resources/ElementMass.xml\");\n        if (!elementMassFile.exists()) {\n            throw new FileNotFoundException(\"Cannot locate ElementMass.xml. \" +\n                    \"Please use getMolecularWeight(ProteinSequence, File, File) to specify ElementMass.xml location.\");\n        }\n        return getMolecularWeightBasedOnXML(sequence, obtainAminoAcidCompositionTable(elementMassFile, aminoAcidCompositionFile));\n    }\n\n    @Override\n    public double getMolecularWeight(ProteinSequence sequence, File elementMassFile, File aminoAcidCompositionFile) throws JAXBException, FileNotFoundException {\n        return getMolecularWeightBasedOnXML(sequence, obtainAminoAcidCompositionTable(elementMassFile, aminoAcidCompositionFile));\n    }\n\n    @Override\n    public double getMolecularWeightBasedOnXML(ProteinSequence sequence, AminoAcidCompositionTable aminoAcidCompositionTable) {\n        double value = 0.0;\n        char[] seq = sequence.toString().toCharArray();\n        for (int i = 0; i < seq.length; i++) {\n            Double w = aminoAcidCompositionTable.getMolecularWeight(seq[i]);\n            if (w != null) value += w;\n        }\n        if (value == 0.0)\n            return value;\n        else\n            return value + getWaterMoleculeWeight();\n    }\n\n    @Override\n    public AminoAcidCompositionTable obtainAminoAcidCompositionTable(File aminoAcidCompositionFile) throws JAXBException, FileNotFoundException {\n        File elementMassFile = new File(\"./src/main/resources/ElementMass.xml\");\n        if (!elementMassFile.exists()) {\n            throw new FileNotFoundException(\"Cannot locate ElementMass.xml. \" +\n                    \"Please use getMolecularWeight(ProteinSequence, File, File) to specify ElementMass.xml location.\");\n        }\n        return obtainAminoAcidCompositionTable(elementMassFile, aminoAcidCompositionFile);\n    }\n\n    @Override\n    public AminoAcidCompositionTable obtainAminoAcidCompositionTable(File elementMassFile, File aminoAcidCompositionFile) throws JAXBException, FileNotFoundException {\n        ElementTable iTable = new ElementTable();\n        JAXBContext jc = JAXBContext.newInstance(iTable.getClass());\n        Unmarshaller u = jc.createUnmarshaller();\n        u.setEventHandler(new MyValidationEventHandler());\n        iTable = (ElementTable) u.unmarshal(new FileInputStream(elementMassFile));\n        iTable.populateMaps();\n        AminoAcidCompositionTable aTable = new AminoAcidCompositionTable();\n        JAXBContext jc2 = JAXBContext.newInstance(aTable.getClass());\n        Unmarshaller u2 = jc2.createUnmarshaller();\n        u2.setEventHandler(new MyValidationEventHandler());\n        aTable = (AminoAcidCompositionTable) u2.unmarshal(new FileInputStream(aminoAcidCompositionFile));\n        aTable.computeMolecularWeight(iTable);\n        return aTable;\n    }\n\n    \n    @Override\n    public double getExtinctionCoefficient(ProteinSequence sequence, boolean assumeCysReduced) {\n        Map<AminoAcidCompound, Integer> extinctAA2Count = this.getExtinctAACount(sequence);\n        double eProt;\n        if(!assumeCysReduced){\n            eProt = extinctAA2Count.get(getCompoundForChar('Y')) *\n                Constraints.aa2ExtinctionCoefficient.get(getCompoundForChar('Y')) +\n                extinctAA2Count.get(getCompoundForChar('W')) *\n                Constraints.aa2ExtinctionCoefficient.get(getCompoundForChar('W')) +\n                extinctAA2Count.get(getCompoundForChar('C')) *\n                Constraints.aa2ExtinctionCoefficient.get(getCompoundForChar('C'));\n        }else\n            eProt = extinctAA2Count.get(getCompoundForChar('Y')) *\n                Constraints.aa2ExtinctionCoefficient.get(getCompoundForChar('Y')) +\n                extinctAA2Count.get(getCompoundForChar('W')) *\n                Constraints.aa2ExtinctionCoefficient.get(getCompoundForChar('W'));\n        return eProt;\n    }\n\n    \n    private Map<AminoAcidCompound, Integer> getExtinctAACount(ProteinSequence sequence){\n        int numW = 0, smallW = 0, numY = 0, smallY = 0;\n        double numC = 0, smallC = 0;\n        for (char aa : sequence.getSequenceAsString().toCharArray()) {\n            switch(aa){\n            case 'W': numW++; break;\n            case 'w': smallW++; break;\n            case 'C': numC += 0.5; break;\n            case 'c': smallC += 0.5; break;\n            case 'Y': numY++; break;\n            case 'y': smallY++; break;\n            }\n        }\n        Map<AminoAcidCompound, Integer> extinctAA2Count = new HashMap<>();\n        extinctAA2Count.put(getCompoundForChar('W'), numW + smallW);\n        extinctAA2Count.put(getCompoundForChar('C'), (int) (numC + smallC));\n        extinctAA2Count.put(getCompoundForChar('Y'), numY + smallY);\n        return extinctAA2Count;\n    }\n\n    @Override\n    public double getAbsorbance(ProteinSequence sequence, boolean assumeCysReduced) {\n        double mw = this.getMolecularWeight(sequence);\n        double eProt = this.getExtinctionCoefficient(sequence, assumeCysReduced);\n        if (mw == 0.0) {\n            logger.warn(\"Molecular weight is 0.0, can't divide by 0: setting absorbance to 0.0\");\n            return 0.0;\n        }\n        return eProt / mw;\n    }\n\n    @Override\n    public double getInstabilityIndex(ProteinSequence sequence) {\n        String s = sequence.getSequenceAsString().toUpperCase();\n        char[] seq = s.toCharArray();\n        double sum = 0.0;\n        int n = s.length();\n        for (int i = 0; i < n - 1; i++) {\n            char c1 = seq[i];\n            char c2 = seq[i + 1];\n            if (c1 >= 'A' && c1 <= 'Z' && c2 >= 'A' && c2 <= 'Z') {\n                sum += AA_DIPEPTIDE_INSTABILITY[c1 - 'A'][c2 - 'A'];\n            }\n        }\n        int denominator = n - Utils.getNumberOfInvalidChar(s, null, true);\n        if (denominator == 0) {\n            logger.warn(\"Valid length of sequence is 0, can't divide by 0 to calculate instability index: setting instability index value to 0.0\");\n            return 0.0;\n        }\n        return sum * 10.0 / denominator;\n    }\n\n    @Override\n    public double getApliphaticIndex(ProteinSequence sequence) {\n        Map<AminoAcidCompound, Double> aa2Composition = getAAComposition(sequence);\n        final double a = 2.9;\n        final double b = 3.9;\n        double xAla = aa2Composition.get(getCompoundForChar('A'));\n        double xVal = aa2Composition.get(getCompoundForChar('V'));\n        double xIle = aa2Composition.get(getCompoundForChar('I'));\n        double xLeu = aa2Composition.get(getCompoundForChar('L'));\n        return (xAla + (a * xVal) + (b * (xIle + xLeu))) * 100;\n    }\n\n    @Override\n    public double getAvgHydropathy(ProteinSequence sequence) {\n        int validLength = 0;\n        double total = 0.0;\n        char[] seq = this.getSequence(sequence.toString(), true);\n        for (char c : seq) {\n            if (c >= 'A' && c <= 'Z') {\n                total += AA_HYDROPATHY[c - 'A'];\n                validLength++;\n            }\n        }\n        if (validLength == 0) {\n            logger.warn(\"Valid length of sequence is 0, can't divide by 0 to calculate average hydropathy: setting average hydropathy to 0\");\n            return 0.0;\n        }\n        return total / validLength;\n    }\n\n    @Override\n    public double getIsoelectricPoint(ProteinSequence sequence, boolean useExpasyValues) {\n        if (useExpasyValues) {\n            return this.getIsoelectricPointExpasy(sequence.toString().toUpperCase());\n        } else {\n            return this.getIsoelectricPointInnovagen(sequence);\n        }\n    }\n\n    @Override\n    public double getIsoelectricPoint(ProteinSequence sequence) {\n        return getIsoelectricPoint(sequence, true);\n    }\n\n    private final double[][] cPk = {\n            {3.55, 7.59, 0.0},\n            {3.55, 7.50, 0.0},\n            {3.55, 7.50, 9.00},\n            {3.55, 7.50, 4.05},\n            {3.55, 7.70, 4.45},\n            {3.55, 7.50, 0},\n            {3.55, 7.50, 0},\n            {3.55, 7.50, 5.98},\n            {3.55, 7.50, 0.0},\n            {0.0, 0.0, 0.0},\n            {3.55, 7.50, 10.00},\n            {3.55, 7.50, 0.0},\n            {3.55, 7.00, 0.0},\n            {3.55, 7.50, 0.0},\n            {0.00, 0.00, 0.0},\n            {3.55, 8.36, 0.0},\n            {3.55, 7.50, 0.0},\n            {3.55, 7.50, 12.0},\n            {3.55, 6.93, 0.0},\n            {3.55, 6.82, 0.0},\n            {0.00, 0.00, 0.0},\n            {3.55, 7.44, 0.0},\n            {3.55, 7.50, 0.0},\n            {3.55, 7.50, 0.0},\n            {3.55, 7.50, 10.00},\n            {3.55, 7.50, 0.0}\n    };\n    private final double PH_MIN = 0.0;\n    private final double PH_MAX = 14.0;\n    private final double MAXLOOP = 2000.0;\n    private final double EPSI = 0.0001;\n\n    private double exp10(double pka) {\n        return Math.pow(10, pka);\n    }\n\n    private double getIsoelectricPointExpasy(String sequence) {\n        int[] comp = new int[26];\n        for (int i = 0; i < sequence.length(); i++) {\n            int index = sequence.charAt(i) - 'A';\n            if (index < 0 || index >= 26) continue;\n            comp[index]++;\n        }\n        int nTermResidue = -1;\n        int index = 0;\n        while ((nTermResidue < 0 || nTermResidue >= 26) && index < 25) {\n            nTermResidue = sequence.charAt(index++) - 'A';\n        }\n        int cTermResidue = -1;\n        index = 1;\n        while ((cTermResidue < 0 || cTermResidue >= 26) && index < 25) {\n            cTermResidue = sequence.charAt(sequence.length() - index++) - 'A';\n        }\n        double phMin = PH_MIN;\n        double phMax = PH_MAX;\n        double phMid = 0.0;\n        double charge = 1.0;\n        for (int i = 0; i < MAXLOOP && (phMax - phMin) > EPSI; i++) {\n            phMid = phMin + (phMax - phMin) / 2.0;\n            charge = getNetChargeExpasy(comp, nTermResidue, cTermResidue, phMid);\n            if (charge > 0.0) phMin = phMid;\n            else phMax = phMid;\n        }\n        return phMid;\n    }\n\n    private double getIsoelectricPointInnovagen(ProteinSequence sequence) {\n        double currentPH = 7.0;\n        double changeSize = 7.0;\n        String sequenceString = sequence.toString();\n        char nTerminalChar = sequenceString.charAt(0);\n        char cTerminalChar = sequenceString.charAt(sequenceString.length() - 1);\n        Map<AminoAcidCompound, Integer> chargedAA2Count = this.getChargedAACount(sequence);\n        double margin;\n        final double difference = 0.0001;\n        while (true) {\n            margin = this.getNetChargeInnovagen(chargedAA2Count, currentPH, nTerminalChar, cTerminalChar);\n            if (margin <= difference && margin >= -difference) break;\n            changeSize /= 2.0;\n            if (margin > 0) {\n                currentPH += changeSize;\n            } else {\n                currentPH -= changeSize;\n            }\n        }\n        return currentPH;\n    }\n\n    @Override\n    public double getNetCharge(ProteinSequence sequence) {\n        return getNetCharge(sequence, true);\n    }\n\n    @Override\n    public double getNetCharge(ProteinSequence sequence, boolean useExpasyValues) {\n        return getNetCharge(sequence, useExpasyValues, 7.0);\n    }\n\n    @Override\n    public double getNetCharge(ProteinSequence sequence, boolean useExpasyValues, double pHPoint) {\n        if (useExpasyValues) {\n            return getNetChargeExpasy(sequence.toString().toUpperCase(), pHPoint);\n        } else {\n            return getNetChargeInnovagen(sequence, pHPoint);\n        }\n    }\n\n    private double getNetChargeExpasy(String sequence, double pHPoint) {\n        int[] comp = new int[26];\n        for (int i = 0; i < sequence.length(); i++) {\n            int index = sequence.charAt(i) - 'A';\n            if (index < 0 || index >= 26) continue;\n            comp[index]++;\n        }\n        int nTermResidue = sequence.charAt(0) - 'A';\n        int cTermResidue = sequence.charAt(sequence.length() - 1) - 'A';\n        return getNetChargeExpasy(comp, nTermResidue, cTermResidue, pHPoint);\n    }\n\n    private double getNetChargeExpasy(int[] comp, int nTermResidue, int cTermResidue, double ph) {\n        double cter = 0.0;\n        if (cTermResidue >= 0 && cTermResidue < 26)\n            cter = exp10(-cPk[cTermResidue][0]) / (exp10(-cPk[cTermResidue][0]) + exp10(-ph));\n        double nter = 0.0;\n        if (nTermResidue >= 0 && nTermResidue < 26)\n            nter = exp10(-ph) / (exp10(-cPk[nTermResidue][1]) + exp10(-ph));\n        double carg = comp['R' - 'A'] * exp10(-ph) / (exp10(-cPk['R' - 'A'][2]) + exp10(-ph));\n        double chis = comp['H' - 'A'] * exp10(-ph) / (exp10(-cPk['H' - 'A'][2]) + exp10(-ph));\n        double clys = comp['K' - 'A'] * exp10(-ph) / (exp10(-cPk['K' - 'A'][2]) + exp10(-ph));\n        double casp = comp['D' - 'A'] * exp10(-cPk['D' - 'A'][2]) / (exp10(-cPk['D' - 'A'][2]) + exp10(-ph));\n        double cglu = comp['E' - 'A'] * exp10(-cPk['E' - 'A'][2]) / (exp10(-cPk['E' - 'A'][2]) + exp10(-ph));\n        double ccys = comp['C' - 'A'] * exp10(-cPk['C' - 'A'][2]) / (exp10(-cPk['C' - 'A'][2]) + exp10(-ph));\n        double ctyr = comp['Y' - 'A'] * exp10(-cPk['Y' - 'A'][2]) / (exp10(-cPk['Y' - 'A'][2]) + exp10(-ph));\n        return (carg + clys + chis + nter) - (casp + cglu + ctyr + ccys + cter);\n    }\n\n    private double getNetChargeInnovagen(ProteinSequence sequence, double pHPoint) {\n        Map<AminoAcidCompound, Integer> chargedAA2Count = this.getChargedAACount(sequence);\n        String sequenceString = sequence.getSequenceAsString();\n        return getNetChargeInnovagen(chargedAA2Count, pHPoint, sequenceString.charAt(0), sequenceString.charAt(sequenceString.length() - 1));\n    }\n\n    private double getNetChargeInnovagen(Map<AminoAcidCompound, Integer> chargedAA2Count, double ph, char nTerminalChar, char cTerminalChar) {\n        double nTerminalCharge = 0.0;\n        AminoAcidCompound nTermCompound = getCompoundForChar(nTerminalChar);\n        if (nTermCompound != null && Constraints.aa2NTerminalPka.containsKey(nTermCompound)) {\n            nTerminalCharge = this.getPosCharge(Constraints.aa2NTerminalPka.get(nTermCompound), ph);\n        }\n        double cTerminalCharge = 0.0;\n        AminoAcidCompound cTermCompound = getCompoundForChar(cTerminalChar);\n        if (cTermCompound != null && Constraints.aa2CTerminalPka.containsKey(cTermCompound)) {\n            cTerminalCharge = this.getNegCharge(Constraints.aa2CTerminalPka.get(cTermCompound), ph);\n        }\n        double kCharge = chargedAA2Count.get(getCompoundForChar('K')) * this.getPosCharge(Constraints.aa2PKa.get(getCompoundForChar('K')), ph);\n        double rCharge = chargedAA2Count.get(getCompoundForChar('R')) * this.getPosCharge(Constraints.aa2PKa.get(getCompoundForChar('R')), ph);\n        double hCharge = chargedAA2Count.get(getCompoundForChar('H')) * this.getPosCharge(Constraints.aa2PKa.get(getCompoundForChar('H')), ph);\n        double dCharge = chargedAA2Count.get(getCompoundForChar('D')) * this.getNegCharge(Constraints.aa2PKa.get(getCompoundForChar('D')), ph);\n        double eCharge = chargedAA2Count.get(getCompoundForChar('E')) * this.getNegCharge(Constraints.aa2PKa.get(getCompoundForChar('E')), ph);\n        double cCharge = chargedAA2Count.get(getCompoundForChar('C')) * this.getNegCharge(Constraints.aa2PKa.get(getCompoundForChar('C')), ph);\n        double yCharge = chargedAA2Count.get(getCompoundForChar('Y')) * this.getNegCharge(Constraints.aa2PKa.get(getCompoundForChar('Y')), ph);\n        return (nTerminalCharge + kCharge + rCharge + hCharge) - (dCharge + eCharge + cCharge + yCharge + cTerminalCharge);\n    }\n\n    private double getPosCharge(double pka, double ph) {\n        return Math.pow(10, pka) / (Math.pow(10, pka) + Math.pow(10, ph));\n    }\n\n    private double getNegCharge(double pka, double ph) {\n        return Math.pow(10, ph) / (Math.pow(10, pka) + Math.pow(10, ph));\n    }\n\n    private Map<AminoAcidCompound, Integer> getChargedAACount(ProteinSequence sequence) {\n        int numK = 0, numR = 0, numH = 0, numD = 0, numE = 0, numC = 0, numY = 0;\n        char[] seq = this.getSequence(sequence.getSequenceAsString(), true);\n        for (char aa : seq) {\n            switch (aa) {\n                case 'K': numK++; break;\n                case 'R': numR++; break;\n                case 'H': numH++; break;\n                case 'D': numD++; break;\n                case 'E': numE++; break;\n                case 'C': numC++; break;\n                case 'Y': numY++; break;\n            }\n        }\n        Map<AminoAcidCompound, Integer> chargedAA2Count = new HashMap<>();\n        chargedAA2Count.put(getCompoundForChar('K'), numK);\n        chargedAA2Count.put(getCompoundForChar('R'), numR);\n        chargedAA2Count.put(getCompoundForChar('H'), numH);\n        chargedAA2Count.put(getCompoundForChar('D'), numD);\n        chargedAA2Count.put(getCompoundForChar('E'), numE);\n        chargedAA2Count.put(getCompoundForChar('C'), numC);\n        chargedAA2Count.put(getCompoundForChar('Y'), numY);\n        return chargedAA2Count;\n    }\n\n    @Override\n    public double getEnrichment(ProteinSequence sequence, AminoAcidCompound aminoAcidCode) {\n        double counter = 0.0;\n        char[] seq = this.getSequence(sequence.getSequenceAsString(), true);\n        String code = aminoAcidCode.getShortName();\n        if (code != null && code.length() == 1) {\n            char target = code.charAt(0);\n            for (char aa : seq) {\n                if (aa == target) {\n                    counter++;\n                }\n            }\n        }\n        return counter / sequence.getLength();\n    }\n\n    @Override\n    public Map<AminoAcidCompound, Double> getAAComposition(ProteinSequence sequence) {\n        int validLength = 0;\n        Map<AminoAcidCompound, Double> aa2Composition = new HashMap<>();\n        \n        char[] seq = this.getSequence(sequence.toString(), true);\n        for (char aa : seq) {\n            if (PeptideProperties.standardAASet.contains(aa)) {\n                AminoAcidCompound compound = getCompoundForChar(aa);\n                if (compound != null) {\n                    aa2Composition.put(compound, aa2Composition.getOrDefault(compound, 0.0) + 1.0);\n                    validLength++;\n                }\n            }\n        }\n        \n        if (validLength > 0) {\n            for (Map.Entry<AminoAcidCompound, Double> entry : aa2Composition.entrySet()) {\n                aa2Composition.put(entry.getKey(), entry.getValue() / validLength);\n            }\n            \n            for (AminoAcidCompound aa : AA_SET.getAllCompounds()) {\n                aa2Composition.putIfAbsent(aa, 0.0);\n            }\n        } else {\n            for (AminoAcidCompound aa : AA_SET.getAllCompounds()) {\n                aa2Composition.put(aa, 0.0);\n            }\n        }\n        return aa2Composition;\n    }\n\n    @Override\n    public double getAromaticity(ProteinSequence sequence) {\n        int validLength = sequence.getSequenceAsString().length();\n        if (validLength == 0) {\n            logger.warn(\"Valid length of sequence is 0, can't divide by 0 to calculate aromaticity: setting aromaticity to 0\");\n            return 0.0;\n        }\n        int totalF = 0, totalY = 0, totalW = 0;\n        char[] seq = this.getSequence(sequence.toString(), true);\n        for (char aa : seq) {\n            switch (aa) {\n                case 'F': totalF++; break;\n                case 'Y': totalY++; break;\n                case 'W': totalW++; break;\n            }\n        }\n        return (totalF + totalY + totalW) / (double) (validLength);\n    }\n}\n"
    ]
}