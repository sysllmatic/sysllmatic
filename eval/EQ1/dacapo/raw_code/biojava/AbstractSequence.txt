{
    "0": [
        "\npackage org.biojava.nbio.core.sequence.template;\n\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.core.sequence.AccessionID;\nimport org.biojava.nbio.core.sequence.DataSource;\nimport org.biojava.nbio.core.sequence.Strand;\nimport org.biojava.nbio.core.sequence.TaxonomyID;\nimport org.biojava.nbio.core.sequence.features.*;\nimport org.biojava.nbio.core.sequence.loader.UniprotProxySequenceReader;\nimport org.biojava.nbio.core.sequence.location.SequenceLocation;\nimport org.biojava.nbio.core.sequence.location.SimpleLocation;\nimport org.biojava.nbio.core.sequence.location.template.Location;\nimport org.biojava.nbio.core.sequence.reference.AbstractReference;\nimport org.biojava.nbio.core.sequence.storage.ArrayListSequenceReader;\nimport org.biojava.nbio.core.util.Equals;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.*;\n\n\npublic abstract class AbstractSequence<C extends Compound> implements Sequence<C> {\n\n\tprivate final static Logger logger = LoggerFactory.getLogger(AbstractSequence.class);\n\n\tprivate TaxonomyID taxonomy;\n\tprivate AccessionID accession;\n\tprivate SequenceReader<C> sequenceStorage = null;\n\tprivate CompoundSet<C> compoundSet;\n\tprivate AnnotationType annotationType = AnnotationType.UNKNOWN;\n\tprivate String description;\n\tprivate String originalHeader;\n\tprivate Collection<Object> userCollection;\n\tprivate Integer bioBegin = null;\n\tprivate Integer bioEnd = null;\n\tprivate AbstractSequence<?> parentSequence = null;\n\tprivate String source = null;\n\tprivate ArrayList<String> notesList = new ArrayList<String>();\n\tprivate Double sequenceScore = null;\n\tprivate FeaturesKeyWordInterface featuresKeyWord = null;\n\tprivate DatabaseReferenceInterface databaseReferences = null;\n\tprivate FeatureRetriever featureRetriever = null;\n\tprivate ArrayList<FeatureInterface<AbstractSequence<C>, C>> features =\n\t\t\tnew ArrayList<FeatureInterface<AbstractSequence<C>, C>>();\n\tprivate LinkedHashMap<String, ArrayList<FeatureInterface<AbstractSequence<C>, C>>> groupedFeatures =\n\t\t\tnew LinkedHashMap<String, ArrayList<FeatureInterface<AbstractSequence<C>, C>>>();\n\tprivate List<String> comments = new ArrayList<>();\n\tprivate List<AbstractReference> references;\n\n\tpublic AbstractSequence() {\n\t}\n\n\t\n\tpublic AbstractSequence(String seqString, CompoundSet<C> compoundSet) throws CompoundNotFoundException {\n\t\tsetCompoundSet(compoundSet);\n\t\tinitSequenceStorage(seqString);\n\t}\n\n\t\n\tprotected void initSequenceStorage(String seqString) throws CompoundNotFoundException {\n\t\tsequenceStorage = new ArrayListSequenceReader<C>();\n\t\tsequenceStorage.setCompoundSet(this.getCompoundSet());\n\t\tsequenceStorage.setContents(seqString);\n\t}\n\n\t\n\tpublic AbstractSequence(SequenceReader<C> proxyLoader, CompoundSet<C> compoundSet) {\n\t\tsetCompoundSet(compoundSet);\n\t\tsetProxySequenceReader(proxyLoader);\n\t}\n\n\t\n\tpublic void setProxySequenceReader(SequenceReader<C> proxyLoader) {\n\t\tthis.sequenceStorage = proxyLoader;\n\t\tif (proxyLoader instanceof FeaturesKeyWordInterface) {\n\t\t\tthis.setFeaturesKeyWord((FeaturesKeyWordInterface) sequenceStorage);\n\t\t}\n\t\tif (proxyLoader instanceof DatabaseReferenceInterface) {\n\t\t\tthis.setDatabaseReferences((DatabaseReferenceInterface) sequenceStorage);\n\t\t}\n\n\t\tif (proxyLoader instanceof FeatureRetriever) {\n\t\t\tthis.setFeatureRetriever((FeatureRetriever) sequenceStorage);\n\t\t\tMap<String, List<AbstractFeature<AbstractSequence<C>, C>>> ff = getFeatureRetriever().getFeatures();\n\t\t\tfor (String k: ff.keySet()){\n\t\t\t\tfor (AbstractFeature f: ff.get(k)){\n\t\t\t\t\tthis.addFeature(f);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tArrayList<DBReferenceInfo> dbQualifiers = (ArrayList)ff.get(\"source\").get(0).getQualifiers().get(\"db_xref\");\n\t\t\tDBReferenceInfo dbQualifier = dbQualifiers.get(0);\n\n\t\t\tif (dbQualifier != null) this.setTaxonomy(new TaxonomyID(dbQualifier.getDatabase()+\":\"+dbQualifier.getId(), DataSource.UNKNOWN));\n\t\t}\n\n\t\tif(getAccession() == null && proxyLoader instanceof UniprotProxySequenceReader){ \n\t\t\tthis.setAccession(proxyLoader.getAccession());\n\t\t}\n\t}\n\n\tpublic SequenceReader<C> getProxySequenceReader() {\n\t\treturn sequenceStorage;\n\t}\n\n\t\n\tpublic Integer getBioBegin() {\n\t\tif (bioBegin == null) {\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn bioBegin;\n\t\t}\n\t}\n\n\t\n\tpublic void setBioBegin(Integer bioBegin) {\n\t\tthis.bioBegin = bioBegin;\n\t}\n\n\t\n\tpublic Integer getBioEnd() {\n\t\tif (bioEnd == null) {\n\t\t\treturn this.getLength();\n\t\t} else {\n\t\t\treturn bioEnd;\n\t\t}\n\t}\n\n\t\n\tpublic void setBioEnd(Integer bioEnd) {\n\t\tthis.bioEnd = bioEnd;\n\t}\n\n\t\n\tpublic Collection<Object> getUserCollection() {\n\n\t\treturn userCollection;\n\t}\n\n\t\n\tpublic void setUserCollection(Collection<Object> userCollection) {\n\t\tthis.userCollection = userCollection;\n\t}\n\n\t\n\tpublic AnnotationType getAnnotationType() {\n\t\treturn annotationType;\n\t}\n\n\t\n\tpublic void setAnnotationType(AnnotationType annotationType) {\n\t\tthis.annotationType = annotationType;\n\t}\n\n\t\n\tpublic String getDescription() {\n\t\treturn description;\n\t}\n\n\t\n\tpublic void setDescription(String description) {\n\t\tthis.description = description;\n\t}\n\n\t\n\tpublic String getOriginalHeader() {\n\t\treturn originalHeader;\n\t}\n\n\t\n\tpublic void setOriginalHeader(String originalHeader) {\n\t\tthis.originalHeader = originalHeader;\n\t}\n\n\t\n\tpublic AbstractSequence<?> getParentSequence() {\n\t\treturn parentSequence;\n\t}\n\n\t\n\tpublic void setParentSequence(AbstractSequence<?> parentSequence) {\n\t\tthis.parentSequence = parentSequence;\n\t}\n\n\t\n\tpublic String getSource() {\n\t\tif (source != null) {\n\t\t\treturn source;\n\t\t}\n\t\tif (parentSequence != null) {\n\t\t\treturn parentSequence.getSource();\n\t\t}\n\t\treturn null;\n\t}\n\n\t\n\tpublic void setSource(String source) {\n\n\t\tthis.source = source;\n\t}\n\n\t\n\tpublic void addNote(String note) {\n\t\tnotesList.add(note);\n\t}\n\n\tpublic void removeNote(String note) {\n\t\tnotesList.remove(note);\n\t}\n\n\t\n\tpublic ArrayList<String> getNotesList() {\n\t\treturn notesList;\n\t}\n\n\t\n\tpublic void setNotesList(ArrayList<String> notesList) {\n\t\tthis.notesList = notesList;\n\t}\n\n\t\n\tpublic Double getSequenceScore() {\n\t\treturn sequenceScore;\n\t}\n\n\t\n\tpublic void setSequenceScore(Double sequenceScore) {\n\t\tthis.sequenceScore = sequenceScore;\n\t}\n\n\t\n\tpublic List<AbstractReference> getReferences() {\n\t\treturn references;\n\t}\n\n\t\n\tpublic void setReferences(List<AbstractReference> references) {\n\t\tthis.references = references;\n\t}\n\n\t\n\tpublic List<FeatureInterface<AbstractSequence<C>, C>> getFeatures(String featureType, int bioSequencePosition) {\n\t\tArrayList<FeatureInterface<AbstractSequence<C>, C>> featureHits =\n\t\t\t\tnew ArrayList<FeatureInterface<AbstractSequence<C>, C>>();\n\t\tList<FeatureInterface<AbstractSequence<C>, C>> features = getFeaturesByType(featureType);\n\t\tif (features != null) {\n\t\t\tfor (FeatureInterface<AbstractSequence<C>, C> feature : features) {\n\t\t\t\tif (bioSequencePosition >= feature.getLocations().getStart().getPosition() && bioSequencePosition <= feature.getLocations().getEnd().getPosition()) {\n\t\t\t\t\tfeatureHits.add(feature);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn featureHits;\n\t}\n\n\t\n\tpublic List<FeatureInterface<AbstractSequence<C>, C>> getFeatures(int bioSequencePosition) {\n\t\tArrayList<FeatureInterface<AbstractSequence<C>, C>> featureHits =\n\t\t\t\tnew ArrayList<FeatureInterface<AbstractSequence<C>, C>>();\n\t\tif (features != null) {\n\t\t\tfor (FeatureInterface<AbstractSequence<C>, C> feature : features) {\n\t\t\t\tif (bioSequencePosition >= feature.getLocations().getStart().getPosition() && bioSequencePosition <= feature.getLocations().getEnd().getPosition()) {\n\t\t\t\t\tfeatureHits.add(feature);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn featureHits;\n\t}\n\n\t\n\tpublic List<FeatureInterface<AbstractSequence<C>, C>> getFeatures() {\n\t\treturn features;\n\t}\n\n\t\n\tpublic void addFeature(int bioStart, int bioEnd, FeatureInterface<AbstractSequence<C>, C> feature) {\n\t\tSequenceLocation<AbstractSequence<C>, C> sequenceLocation =\n\t\t\t\tnew SequenceLocation<AbstractSequence<C>, C>(bioStart, bioEnd, this);\n\t\tfeature.setLocation(sequenceLocation);\n\t\taddFeature(feature);\n\t}\n\n\t\n\tpublic void addFeature(FeatureInterface<AbstractSequence<C>, C> feature) {\n\t\tfeatures.add(feature);\n\t\tArrayList<FeatureInterface<AbstractSequence<C>, C>> featureList = groupedFeatures.get(feature.getType());\n\t\tif (featureList == null) {\n\t\t\tfeatureList = new ArrayList<FeatureInterface<AbstractSequence<C>, C>>();\n\t\t\tgroupedFeatures.put(feature.getType(), featureList);\n\t\t}\n\t\tfeatureList.add(feature);\n\t\tCollections.sort(features, AbstractFeature.LOCATION_LENGTH);\n\t\tCollections.sort(featureList, AbstractFeature.LOCATION_LENGTH);\n\t}\n\n\t\n\tpublic void removeFeature(FeatureInterface<AbstractSequence<C>, C> feature) {\n\t\tfeatures.remove(feature);\n\t\tArrayList<FeatureInterface<AbstractSequence<C>, C>> featureList = groupedFeatures.get(feature.getType());\n\t\tif (featureList != null) {\n\t\t\tfeatureList.remove(feature);\n\t\t\tif (featureList.isEmpty()) {\n\t\t\t\tgroupedFeatures.remove(feature.getType());\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tpublic List<FeatureInterface<AbstractSequence<C>, C>> getFeaturesByType(String type) {\n\t\tList<FeatureInterface<AbstractSequence<C>, C>> features = groupedFeatures.get(type);\n\t\tif (features == null) {\n\t\t\tfeatures = new ArrayList<FeatureInterface<AbstractSequence<C>, C>>();\n\t\t}\n\t\treturn features;\n\t}\n\n\t\n\tpublic List<String> getComments() {\n\t\treturn comments;\n\t}\n\n\t\n\tpublic void setComments(List<String> comments) {\n\t\tthis.comments = comments;\n\t}\n\n\t\n\tpublic FeaturesKeyWordInterface getFeaturesKeyWord() {\n\t\treturn featuresKeyWord;\n\t}\n\n\t\n\tpublic void setFeaturesKeyWord(FeaturesKeyWordInterface featuresKeyWord) {\n\t\tthis.featuresKeyWord = featuresKeyWord;\n\t}\n\n\t\n\tpublic DatabaseReferenceInterface getDatabaseReferences() {\n\t\treturn databaseReferences;\n\t}\n\n\t\n\tpublic void setDatabaseReferences(DatabaseReferenceInterface databaseReferences) {\n\t\tthis.databaseReferences = databaseReferences;\n\t}\n\n\tpublic FeatureRetriever getFeatureRetriever() {\n\t\treturn featureRetriever;\n\t}\n\n\tpublic void setFeatureRetriever(FeatureRetriever featureRetriever) {\n\t\tthis.featureRetriever = featureRetriever;\n\t}\n\n\n\n\tpublic enum AnnotationType {\n\n\t\tCURATED, PREDICTED, UNKNOWN;\n\t}\n\n\t\n\t@Override\n\tpublic AccessionID getAccession() {\n\t\treturn accession;\n\t}\n\n\t\n\tpublic void setAccession(AccessionID accession) {\n\t\tthis.accession = accession;\n\t}\n\n\t\n\tpublic TaxonomyID getTaxonomy() {\n\t\treturn taxonomy;\n\t}\n\n\t\n\tpublic void setTaxonomy(TaxonomyID taxonomy) {\n\t\tthis.taxonomy = taxonomy;\n\t}\n\n\t@Override\n\tpublic CompoundSet<C> getCompoundSet() {\n\t\tif (compoundSet != null) {\n\t\t\treturn compoundSet;\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\treturn null;\n\n\n\t}\n\n\tpublic void setCompoundSet(CompoundSet<C> compoundSet) {\n\t\tthis.compoundSet = compoundSet;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o){\n\n\t\tif(! Equals.classEqual(this, o)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tSequence<C> other = (Sequence<C>)o;\n\n\t\tif ( other.getCompoundSet() != getCompoundSet())\n\t\t\treturn false;\n\n\n\t\tList<C> rawCompounds = getAsList();\n\t\tList<C> otherCompounds = other.getAsList();\n\n\t\tif ( rawCompounds.size() != otherCompounds.size())\n\t\t\treturn false;\n\n\t\tfor (int i = 0 ; i < rawCompounds.size() ; i++){\n\t\t\tCompound myCompound = rawCompounds.get(i);\n\t\t\tCompound otherCompound = otherCompounds.get(i);\n\t\t\tif ( ! myCompound.equalsIgnoreCase(otherCompound))\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic int hashCode(){\n\t\tString s = getSequenceAsString();\n\t\treturn s.hashCode();\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getSequenceAsString();\n\t}\n\n\tprivate SequenceReader<C> getSequenceStorage() {\n\t\tif (sequenceStorage != null) {\n\t\t\treturn sequenceStorage;\n\t\t}\n\t\tif (parentSequence != null) {\n\n\t\t\t\n\n\t\t\tif ( this.compoundSet.equals(parentSequence.getCompoundSet())){\n\t\t\t\tsequenceStorage = new ArrayListSequenceReader<C>();\n\t\t\t\tsequenceStorage.setCompoundSet(this.getCompoundSet());\n\t\t\t\ttry {\n\t\t\t\t\tsequenceStorage.setContents(parentSequence.getSequenceAsString());\n\t\t\t\t} catch (CompoundNotFoundException e) {\n\t\t\t\t\t\n\t\t\t\t\tlogger.error(\"Problem setting contents from parent sequence, some unrecognised compound: {}\",e.getMessage());\n\t\t\t\t}\n\t\t\t\treturn sequenceStorage;\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t\n\tpublic String getSequenceAsString(Integer bioStart, Integer bioEnd, Strand strand) {\n\n\t\tLocation loc = new SimpleLocation(bioStart, bioEnd, strand);\n\t\treturn loc.getSubSequence(this).getSequenceAsString();\n\t}\n\n\t\n\t@Override\n\tpublic String getSequenceAsString() {\n\t\treturn SequenceMixin.toString(this);\n\n\t}\n\n\t\n\t@Override\n\tpublic List<C> getAsList() {\n\n\t\treturn sequenceStorage.getAsList();\n\t}\n\n\t\n\t@Override\n\tpublic C getCompoundAt(int position) {\n\n\t\treturn getSequenceStorage().getCompoundAt(position);\n\t}\n\n\t\n\t@Override\n\tpublic int getIndexOf(C compound) {\n\t\treturn getSequenceStorage().getIndexOf(compound);\n\t}\n\n\t\n\t@Override\n\tpublic int getLastIndexOf(C compound) {\n\t\treturn getSequenceStorage().getLastIndexOf(compound);\n\t}\n\n\t\n\t@Override\n\tpublic int getLength() {\n\t\treturn getSequenceStorage().getLength();\n\t}\n\n\t\n\t@Override\n\tpublic SequenceView<C> getSubSequence(final Integer bioStart, final Integer bioEnd) {\n\t\treturn new SequenceProxyView<C>(this, bioStart, bioEnd);\n\t}\n\n\t\n\t@Override\n\tpublic Iterator<C> iterator() {\n\t\treturn getSequenceStorage().iterator();\n\t}\n\n\t\n\t@Override\n\tpublic int countCompounds(C... compounds) {\n\t\treturn SequenceMixin.countCompounds(this, compounds);\n\t}\n\n\t\n\t@Override\n\tpublic SequenceView<C> getInverse() {\n\t\treturn SequenceMixin.inverse(this);\n\t}\n\n\n}\n"
    ],
    "1": [
        "package org.biojava.nbio.core.sequence.template;\n\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.core.sequence.AccessionID;\nimport org.biojava.nbio.core.sequence.DataSource;\nimport org.biojava.nbio.core.sequence.Strand;\nimport org.biojava.nbio.core.sequence.TaxonomyID;\nimport org.biojava.nbio.core.sequence.features.*;\nimport org.biojava.nbio.core.sequence.loader.UniprotProxySequenceReader;\nimport org.biojava.nbio.core.sequence.location.SequenceLocation;\nimport org.biojava.nbio.core.sequence.location.SimpleLocation;\nimport org.biojava.nbio.core.sequence.location.template.Location;\nimport org.biojava.nbio.core.sequence.reference.AbstractReference;\nimport org.biojava.nbio.core.sequence.storage.ArrayListSequenceReader;\nimport org.biojava.nbio.core.util.Equals;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.*;\n\npublic abstract class AbstractSequence<C extends Compound> implements Sequence<C> {\n\n    private final static Logger logger = LoggerFactory.getLogger(AbstractSequence.class);\n\n    private TaxonomyID taxonomy;\n    private AccessionID accession;\n    private SequenceReader<C> sequenceStorage = null;\n    private CompoundSet<C> compoundSet;\n    private AnnotationType annotationType = AnnotationType.UNKNOWN;\n    private String description;\n    private String originalHeader;\n    private Collection<Object> userCollection;\n    private Integer bioBegin = null;\n    private Integer bioEnd = null;\n    private AbstractSequence<?> parentSequence = null;\n    private String source = null;\n    private ArrayList<String> notesList = new ArrayList<String>();\n    private Double sequenceScore = null;\n    private FeaturesKeyWordInterface featuresKeyWord = null;\n    private DatabaseReferenceInterface databaseReferences = null;\n    private FeatureRetriever featureRetriever = null;\n    private ArrayList<FeatureInterface<AbstractSequence<C>, C>> features =\n            new ArrayList<FeatureInterface<AbstractSequence<C>, C>>();\n    private LinkedHashMap<String, ArrayList<FeatureInterface<AbstractSequence<C>, C>>> groupedFeatures =\n            new LinkedHashMap<String, ArrayList<FeatureInterface<AbstractSequence<C>, C>>>();\n    private List<String> comments = new ArrayList<>();\n    private List<AbstractReference> references;\n\n    \n    private boolean featuresDirty = false;\n    private Set<String> groupedFeaturesDirty = new HashSet<>();\n\n    public AbstractSequence() {\n    }\n\n    public AbstractSequence(String seqString, CompoundSet<C> compoundSet) throws CompoundNotFoundException {\n        setCompoundSet(compoundSet);\n        initSequenceStorage(seqString);\n    }\n\n    protected void initSequenceStorage(String seqString) throws CompoundNotFoundException {\n        sequenceStorage = new ArrayListSequenceReader<C>();\n        sequenceStorage.setCompoundSet(this.getCompoundSet());\n        sequenceStorage.setContents(seqString);\n    }\n\n    public AbstractSequence(SequenceReader<C> proxyLoader, CompoundSet<C> compoundSet) {\n        setCompoundSet(compoundSet);\n        setProxySequenceReader(proxyLoader);\n    }\n\n    public void setProxySequenceReader(SequenceReader<C> proxyLoader) {\n        this.sequenceStorage = proxyLoader;\n        if (proxyLoader instanceof FeaturesKeyWordInterface) {\n            this.setFeaturesKeyWord((FeaturesKeyWordInterface) sequenceStorage);\n        }\n        if (proxyLoader instanceof DatabaseReferenceInterface) {\n            this.setDatabaseReferences((DatabaseReferenceInterface) sequenceStorage);\n        }\n\n        if (proxyLoader instanceof FeatureRetriever) {\n            this.setFeatureRetriever((FeatureRetriever) sequenceStorage);\n            Map<String, List<AbstractFeature<AbstractSequence<C>, C>>> ff = getFeatureRetriever().getFeatures();\n            for (String k: ff.keySet()){\n                for (AbstractFeature f: ff.get(k)){\n                    this.addFeature(f);\n                }\n            }\n            ArrayList<DBReferenceInfo> dbQualifiers = (ArrayList)ff.get(\"source\").get(0).getQualifiers().get(\"db_xref\");\n            DBReferenceInfo dbQualifier = dbQualifiers.get(0);\n            if (dbQualifier != null) this.setTaxonomy(new TaxonomyID(dbQualifier.getDatabase()+\":\"+dbQualifier.getId(), DataSource.UNKNOWN));\n        }\n\n        if(getAccession() == null && proxyLoader instanceof UniprotProxySequenceReader){ \n            this.setAccession(proxyLoader.getAccession());\n        }\n    }\n\n    public SequenceReader<C> getProxySequenceReader() {\n        return sequenceStorage;\n    }\n\n    public Integer getBioBegin() {\n        if (bioBegin == null) {\n            return 1;\n        } else {\n            return bioBegin;\n        }\n    }\n\n    public void setBioBegin(Integer bioBegin) {\n        this.bioBegin = bioBegin;\n    }\n\n    public Integer getBioEnd() {\n        if (bioEnd == null) {\n            return this.getLength();\n        } else {\n            return bioEnd;\n        }\n    }\n\n    public void setBioEnd(Integer bioEnd) {\n        this.bioEnd = bioEnd;\n    }\n\n    public Collection<Object> getUserCollection() {\n        return userCollection;\n    }\n\n    public void setUserCollection(Collection<Object> userCollection) {\n        this.userCollection = userCollection;\n    }\n\n    public AnnotationType getAnnotationType() {\n        return annotationType;\n    }\n\n    public void setAnnotationType(AnnotationType annotationType) {\n        this.annotationType = annotationType;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    public String getOriginalHeader() {\n        return originalHeader;\n    }\n\n    public void setOriginalHeader(String originalHeader) {\n        this.originalHeader = originalHeader;\n    }\n\n    public AbstractSequence<?> getParentSequence() {\n        return parentSequence;\n    }\n\n    public void setParentSequence(AbstractSequence<?> parentSequence) {\n        this.parentSequence = parentSequence;\n    }\n\n    public String getSource() {\n        if (source != null) {\n            return source;\n        }\n        if (parentSequence != null) {\n            return parentSequence.getSource();\n        }\n        return null;\n    }\n\n    public void setSource(String source) {\n        this.source = source;\n    }\n\n    public void addNote(String note) {\n        notesList.add(note);\n    }\n\n    public void removeNote(String note) {\n        notesList.remove(note);\n    }\n\n    public ArrayList<String> getNotesList() {\n        return notesList;\n    }\n\n    public void setNotesList(ArrayList<String> notesList) {\n        this.notesList = notesList;\n    }\n\n    public Double getSequenceScore() {\n        return sequenceScore;\n    }\n\n    public void setSequenceScore(Double sequenceScore) {\n        this.sequenceScore = sequenceScore;\n    }\n\n    public List<AbstractReference> getReferences() {\n        return references;\n    }\n\n    public void setReferences(List<AbstractReference> references) {\n        this.references = references;\n    }\n\n    public List<FeatureInterface<AbstractSequence<C>, C>> getFeatures(String featureType, int bioSequencePosition) {\n        List<FeatureInterface<AbstractSequence<C>, C>> featureHits = new ArrayList<FeatureInterface<AbstractSequence<C>, C>>();\n        List<FeatureInterface<AbstractSequence<C>, C>> features = getFeaturesByType(featureType);\n        if (features != null) {\n            for (FeatureInterface<AbstractSequence<C>, C> feature : features) {\n                if (bioSequencePosition >= feature.getLocations().getStart().getPosition() && bioSequencePosition <= feature.getLocations().getEnd().getPosition()) {\n                    featureHits.add(feature);\n                }\n            }\n        }\n        return featureHits;\n    }\n\n    public List<FeatureInterface<AbstractSequence<C>, C>> getFeatures(int bioSequencePosition) {\n        ensureFeaturesSorted();\n        List<FeatureInterface<AbstractSequence<C>, C>> featureHits = new ArrayList<FeatureInterface<AbstractSequence<C>, C>>();\n        if (features != null) {\n            for (FeatureInterface<AbstractSequence<C>, C> feature : features) {\n                if (bioSequencePosition >= feature.getLocations().getStart().getPosition() && bioSequencePosition <= feature.getLocations().getEnd().getPosition()) {\n                    featureHits.add(feature);\n                }\n            }\n        }\n        return featureHits;\n    }\n\n    public List<FeatureInterface<AbstractSequence<C>, C>> getFeatures() {\n        ensureFeaturesSorted();\n        return features;\n    }\n\n    public void addFeature(int bioStart, int bioEnd, FeatureInterface<AbstractSequence<C>, C> feature) {\n        SequenceLocation<AbstractSequence<C>, C> sequenceLocation =\n                new SequenceLocation<AbstractSequence<C>, C>(bioStart, bioEnd, this);\n        feature.setLocation(sequenceLocation);\n        addFeature(feature);\n    }\n\n    public void addFeature(FeatureInterface<AbstractSequence<C>, C> feature) {\n        features.add(feature);\n        featuresDirty = true;\n        ArrayList<FeatureInterface<AbstractSequence<C>, C>> featureList = groupedFeatures.get(feature.getType());\n        if (featureList == null) {\n            featureList = new ArrayList<FeatureInterface<AbstractSequence<C>, C>>();\n            groupedFeatures.put(feature.getType(), featureList);\n        }\n        featureList.add(feature);\n        groupedFeaturesDirty.add(feature.getType());\n        \n    }\n\n    public void removeFeature(FeatureInterface<AbstractSequence<C>, C> feature) {\n        features.remove(feature);\n        featuresDirty = true;\n        ArrayList<FeatureInterface<AbstractSequence<C>, C>> featureList = groupedFeatures.get(feature.getType());\n        if (featureList != null) {\n            featureList.remove(feature);\n            groupedFeaturesDirty.add(feature.getType());\n            if (featureList.isEmpty()) {\n                groupedFeatures.remove(feature.getType());\n                groupedFeaturesDirty.remove(feature.getType());\n            }\n        }\n    }\n\n    public List<FeatureInterface<AbstractSequence<C>, C>> getFeaturesByType(String type) {\n        ArrayList<FeatureInterface<AbstractSequence<C>, C>> features = groupedFeatures.get(type);\n        if (features == null) {\n            features = new ArrayList<FeatureInterface<AbstractSequence<C>, C>>();\n        } else {\n            ensureGroupedFeaturesSorted(type);\n        }\n        return features;\n    }\n\n    public List<String> getComments() {\n        return comments;\n    }\n\n    public void setComments(List<String> comments) {\n        this.comments = comments;\n    }\n\n    public FeaturesKeyWordInterface getFeaturesKeyWord() {\n        return featuresKeyWord;\n    }\n\n    public void setFeaturesKeyWord(FeaturesKeyWordInterface featuresKeyWord) {\n        this.featuresKeyWord = featuresKeyWord;\n    }\n\n    public DatabaseReferenceInterface getDatabaseReferences() {\n        return databaseReferences;\n    }\n\n    public void setDatabaseReferences(DatabaseReferenceInterface databaseReferences) {\n        this.databaseReferences = databaseReferences;\n    }\n\n    public FeatureRetriever getFeatureRetriever() {\n        return featureRetriever;\n    }\n\n    public void setFeatureRetriever(FeatureRetriever featureRetriever) {\n        this.featureRetriever = featureRetriever;\n    }\n\n    public enum AnnotationType {\n        CURATED, PREDICTED, UNKNOWN;\n    }\n\n    @Override\n    public AccessionID getAccession() {\n        return accession;\n    }\n\n    public void setAccession(AccessionID accession) {\n        this.accession = accession;\n    }\n\n    public TaxonomyID getTaxonomy() {\n        return taxonomy;\n    }\n\n    public void setTaxonomy(TaxonomyID taxonomy) {\n        this.taxonomy = taxonomy;\n    }\n\n    @Override\n    public CompoundSet<C> getCompoundSet() {\n        if (compoundSet != null) {\n            return compoundSet;\n        }\n        return null;\n    }\n\n    public void setCompoundSet(CompoundSet<C> compoundSet) {\n        this.compoundSet = compoundSet;\n    }\n\n    @Override\n    public boolean equals(Object o){\n        if(! Equals.classEqual(this, o)) {\n            return false;\n        }\n        Sequence<C> other = (Sequence<C>)o;\n        if ( other.getCompoundSet() != getCompoundSet())\n            return false;\n        List<C> rawCompounds = getAsList();\n        List<C> otherCompounds = other.getAsList();\n        if ( rawCompounds.size() != otherCompounds.size())\n            return false;\n        for (int i = 0 ; i < rawCompounds.size() ; i++){\n            Compound myCompound = rawCompounds.get(i);\n            Compound otherCompound = otherCompounds.get(i);\n            if ( ! myCompound.equalsIgnoreCase(otherCompound))\n                return false;\n        }\n        return true;\n    }\n\n    @Override\n    public int hashCode(){\n        String s = getSequenceAsString();\n        return s.hashCode();\n    }\n\n    @Override\n    public String toString() {\n        return getSequenceAsString();\n    }\n\n    private SequenceReader<C> getSequenceStorage() {\n        if (sequenceStorage != null) {\n            return sequenceStorage;\n        }\n        if (parentSequence != null) {\n            if ( this.compoundSet.equals(parentSequence.getCompoundSet())){\n                sequenceStorage = new ArrayListSequenceReader<C>();\n                sequenceStorage.setCompoundSet(this.getCompoundSet());\n                try {\n                    sequenceStorage.setContents(parentSequence.getSequenceAsString());\n                } catch (CompoundNotFoundException e) {\n                    logger.error(\"Problem setting contents from parent sequence, some unrecognised compound: {}\",e.getMessage());\n                }\n                return sequenceStorage;\n            }\n        }\n        return null;\n    }\n\n    public String getSequenceAsString(Integer bioStart, Integer bioEnd, Strand strand) {\n        Location loc = new SimpleLocation(bioStart, bioEnd, strand);\n        return loc.getSubSequence(this).getSequenceAsString();\n    }\n\n    @Override\n    public String getSequenceAsString() {\n        return SequenceMixin.toString(this);\n    }\n\n    @Override\n    public List<C> getAsList() {\n        return sequenceStorage.getAsList();\n    }\n\n    @Override\n    public C getCompoundAt(int position) {\n        return getSequenceStorage().getCompoundAt(position);\n    }\n\n    @Override\n    public int getIndexOf(C compound) {\n        return getSequenceStorage().getIndexOf(compound);\n    }\n\n    @Override\n    public int getLastIndexOf(C compound) {\n        return getSequenceStorage().getLastIndexOf(compound);\n    }\n\n    @Override\n    public int getLength() {\n        return getSequenceStorage().getLength();\n    }\n\n    @Override\n    public SequenceView<C> getSubSequence(final Integer bioStart, final Integer bioEnd) {\n        return new SequenceProxyView<C>(this, bioStart, bioEnd);\n    }\n\n    @Override\n    public Iterator<C> iterator() {\n        return getSequenceStorage().iterator();\n    }\n\n    @Override\n    public int countCompounds(C... compounds) {\n        return SequenceMixin.countCompounds(this, compounds);\n    }\n\n    @Override\n    public SequenceView<C> getInverse() {\n        return SequenceMixin.inverse(this);\n    }\n\n    \n    private void ensureFeaturesSorted() {\n        if (featuresDirty) {\n            Collections.sort(features, AbstractFeature.LOCATION_LENGTH);\n            featuresDirty = false;\n        }\n    }\n\n    private void ensureGroupedFeaturesSorted(String type) {\n        ArrayList<FeatureInterface<AbstractSequence<C>, C>> featureList = groupedFeatures.get(type);\n        if (featureList != null && groupedFeaturesDirty.contains(type)) {\n            Collections.sort(featureList, AbstractFeature.LOCATION_LENGTH);\n            groupedFeaturesDirty.remove(type);\n        }\n    }\n}\n"
    ],
    "2": [
        "package org.biojava.nbio.core.sequence.template;\n\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.core.sequence.AccessionID;\nimport org.biojava.nbio.core.sequence.DataSource;\nimport org.biojava.nbio.core.sequence.Strand;\nimport org.biojava.nbio.core.sequence.TaxonomyID;\nimport org.biojava.nbio.core.sequence.features.*;\nimport org.biojava.nbio.core.sequence.loader.UniprotProxySequenceReader;\nimport org.biojava.nbio.core.sequence.location.SequenceLocation;\nimport org.biojava.nbio.core.sequence.location.SimpleLocation;\nimport org.biojava.nbio.core.sequence.location.template.Location;\nimport org.biojava.nbio.core.sequence.reference.AbstractReference;\nimport org.biojava.nbio.core.sequence.storage.ArrayListSequenceReader;\nimport org.biojava.nbio.core.util.Equals;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport java.util.*;\nimport java.util.stream.Collectors;\n\npublic abstract class AbstractSequence<C extends Compound> implements Sequence<C> {\n\n    private final static Logger logger = LoggerFactory.getLogger(AbstractSequence.class);\n\n    private TaxonomyID taxonomy;\n    private AccessionID accession;\n    private SequenceReader<C> sequenceStorage = null;\n    private CompoundSet<C> compoundSet;\n    private AnnotationType annotationType = AnnotationType.UNKNOWN;\n    private String description;\n    private String originalHeader;\n    private Collection<Object> userCollection;\n    private Integer bioBegin = null;\n    private Integer bioEnd = null;\n    private AbstractSequence<?> parentSequence = null;\n    private String source = null;\n    private ArrayList<String> notesList = new ArrayList<String>();\n    private Double sequenceScore = null;\n    private FeaturesKeyWordInterface featuresKeyWord = null;\n    private DatabaseReferenceInterface databaseReferences = null;\n    private FeatureRetriever featureRetriever = null;\n    private ArrayList<FeatureInterface<AbstractSequence<C>, C>> features =\n            new ArrayList<FeatureInterface<AbstractSequence<C>, C>>();\n    private LinkedHashMap<String, ArrayList<FeatureInterface<AbstractSequence<C>, C>>> groupedFeatures =\n            new LinkedHashMap<String, ArrayList<FeatureInterface<AbstractSequence<C>, C>>>();\n    private List<String> comments = new ArrayList<>();\n    private List<AbstractReference> references;\n\n    \n    private boolean featuresDirty = false;\n    private Set<String> groupedFeaturesDirty = new HashSet<>();\n    private static final int PARALLEL_THRESHOLD = 1000;\n\n    public AbstractSequence() {\n    }\n\n    public AbstractSequence(String seqString, CompoundSet<C> compoundSet) throws CompoundNotFoundException {\n        setCompoundSet(compoundSet);\n        initSequenceStorage(seqString);\n    }\n\n    protected void initSequenceStorage(String seqString) throws CompoundNotFoundException {\n        sequenceStorage = new ArrayListSequenceReader<C>();\n        sequenceStorage.setCompoundSet(this.getCompoundSet());\n        sequenceStorage.setContents(seqString);\n    }\n\n    public AbstractSequence(SequenceReader<C> proxyLoader, CompoundSet<C> compoundSet) {\n        setCompoundSet(compoundSet);\n        setProxySequenceReader(proxyLoader);\n    }\n\n    public void setProxySequenceReader(SequenceReader<C> proxyLoader) {\n        this.sequenceStorage = proxyLoader;\n        if (proxyLoader instanceof FeaturesKeyWordInterface) {\n            this.setFeaturesKeyWord((FeaturesKeyWordInterface) sequenceStorage);\n        }\n        if (proxyLoader instanceof DatabaseReferenceInterface) {\n            this.setDatabaseReferences((DatabaseReferenceInterface) sequenceStorage);\n        }\n\n        if (proxyLoader instanceof FeatureRetriever) {\n            this.setFeatureRetriever((FeatureRetriever) sequenceStorage);\n            Map<String, List<AbstractFeature<AbstractSequence<C>, C>>> ff = getFeatureRetriever().getFeatures();\n            for (String k: ff.keySet()){\n                for (AbstractFeature f: ff.get(k)){\n                    this.addFeature(f);\n                }\n            }\n            ArrayList<DBReferenceInfo> dbQualifiers = (ArrayList)ff.get(\"source\").get(0).getQualifiers().get(\"db_xref\");\n            DBReferenceInfo dbQualifier = dbQualifiers.get(0);\n            if (dbQualifier != null) this.setTaxonomy(new TaxonomyID(dbQualifier.getDatabase()+\":\"+dbQualifier.getId(), DataSource.UNKNOWN));\n        }\n\n        if(getAccession() == null && proxyLoader instanceof UniprotProxySequenceReader){ \n            this.setAccession(proxyLoader.getAccession());\n        }\n    }\n\n    public SequenceReader<C> getProxySequenceReader() {\n        return sequenceStorage;\n    }\n\n    public Integer getBioBegin() {\n        if (bioBegin == null) {\n            return 1;\n        } else {\n            return bioBegin;\n        }\n    }\n\n    public void setBioBegin(Integer bioBegin) {\n        this.bioBegin = bioBegin;\n    }\n\n    public Integer getBioEnd() {\n        if (bioEnd == null) {\n            return this.getLength();\n        } else {\n            return bioEnd;\n        }\n    }\n\n    public void setBioEnd(Integer bioEnd) {\n        this.bioEnd = bioEnd;\n    }\n\n    public Collection<Object> getUserCollection() {\n        return userCollection;\n    }\n\n    public void setUserCollection(Collection<Object> userCollection) {\n        this.userCollection = userCollection;\n    }\n\n    public AnnotationType getAnnotationType() {\n        return annotationType;\n    }\n\n    public void setAnnotationType(AnnotationType annotationType) {\n        this.annotationType = annotationType;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    public String getOriginalHeader() {\n        return originalHeader;\n    }\n\n    public void setOriginalHeader(String originalHeader) {\n        this.originalHeader = originalHeader;\n    }\n\n    public AbstractSequence<?> getParentSequence() {\n        return parentSequence;\n    }\n\n    public void setParentSequence(AbstractSequence<?> parentSequence) {\n        this.parentSequence = parentSequence;\n    }\n\n    public String getSource() {\n        if (source != null) {\n            return source;\n        }\n        if (parentSequence != null) {\n            return parentSequence.getSource();\n        }\n        return null;\n    }\n\n    public void setSource(String source) {\n        this.source = source;\n    }\n\n    public void addNote(String note) {\n        notesList.add(note);\n    }\n\n    public void removeNote(String note) {\n        notesList.remove(note);\n    }\n\n    public ArrayList<String> getNotesList() {\n        return notesList;\n    }\n\n    public void setNotesList(ArrayList<String> notesList) {\n        this.notesList = notesList;\n    }\n\n    public Double getSequenceScore() {\n        return sequenceScore;\n    }\n\n    public void setSequenceScore(Double sequenceScore) {\n        this.sequenceScore = sequenceScore;\n    }\n\n    public List<AbstractReference> getReferences() {\n        return references;\n    }\n\n    public void setReferences(List<AbstractReference> references) {\n        this.references = references;\n    }\n\n    public List<FeatureInterface<AbstractSequence<C>, C>> getFeatures(String featureType, int bioSequencePosition) {\n        List<FeatureInterface<AbstractSequence<C>, C>> featureHits;\n        List<FeatureInterface<AbstractSequence<C>, C>> features = getFeaturesByType(featureType);\n        if (features == null || features.isEmpty()) {\n            featureHits = new ArrayList<FeatureInterface<AbstractSequence<C>, C>>();\n            return featureHits;\n        }\n        \n        if (features.size() > PARALLEL_THRESHOLD) {\n            featureHits = features.parallelStream()\n                .filter(feature -> bioSequencePosition >= feature.getLocations().getStart().getPosition()\n                        && bioSequencePosition <= feature.getLocations().getEnd().getPosition())\n                .collect(Collectors.toList());\n        } else {\n            featureHits = new ArrayList<FeatureInterface<AbstractSequence<C>, C>>();\n            for (FeatureInterface<AbstractSequence<C>, C> feature : features) {\n                if (bioSequencePosition >= feature.getLocations().getStart().getPosition() && bioSequencePosition <= feature.getLocations().getEnd().getPosition()) {\n                    featureHits.add(feature);\n                }\n            }\n        }\n        return featureHits;\n    }\n\n    public List<FeatureInterface<AbstractSequence<C>, C>> getFeatures(int bioSequencePosition) {\n        ensureFeaturesSorted();\n        List<FeatureInterface<AbstractSequence<C>, C>> featureHits;\n        if (features == null || features.isEmpty()) {\n            featureHits = new ArrayList<FeatureInterface<AbstractSequence<C>, C>>();\n            return featureHits;\n        }\n        \n        if (features.size() > PARALLEL_THRESHOLD) {\n            featureHits = features.parallelStream()\n                .filter(feature -> bioSequencePosition >= feature.getLocations().getStart().getPosition()\n                        && bioSequencePosition <= feature.getLocations().getEnd().getPosition())\n                .collect(Collectors.toList());\n        } else {\n            featureHits = new ArrayList<FeatureInterface<AbstractSequence<C>, C>>();\n            for (FeatureInterface<AbstractSequence<C>, C> feature : features) {\n                if (bioSequencePosition >= feature.getLocations().getStart().getPosition() && bioSequencePosition <= feature.getLocations().getEnd().getPosition()) {\n                    featureHits.add(feature);\n                }\n            }\n        }\n        return featureHits;\n    }\n\n    public List<FeatureInterface<AbstractSequence<C>, C>> getFeatures() {\n        ensureFeaturesSorted();\n        return features;\n    }\n\n    public void addFeature(int bioStart, int bioEnd, FeatureInterface<AbstractSequence<C>, C> feature) {\n        SequenceLocation<AbstractSequence<C>, C> sequenceLocation =\n                new SequenceLocation<AbstractSequence<C>, C>(bioStart, bioEnd, this);\n        feature.setLocation(sequenceLocation);\n        addFeature(feature);\n    }\n\n    public void addFeature(FeatureInterface<AbstractSequence<C>, C> feature) {\n        features.add(feature);\n        featuresDirty = true;\n        ArrayList<FeatureInterface<AbstractSequence<C>, C>> featureList = groupedFeatures.get(feature.getType());\n        if (featureList == null) {\n            featureList = new ArrayList<FeatureInterface<AbstractSequence<C>, C>>();\n            groupedFeatures.put(feature.getType(), featureList);\n        }\n        featureList.add(feature);\n        groupedFeaturesDirty.add(feature.getType());\n        \n    }\n\n    public void removeFeature(FeatureInterface<AbstractSequence<C>, C> feature) {\n        features.remove(feature);\n        featuresDirty = true;\n        ArrayList<FeatureInterface<AbstractSequence<C>, C>> featureList = groupedFeatures.get(feature.getType());\n        if (featureList != null) {\n            featureList.remove(feature);\n            groupedFeaturesDirty.add(feature.getType());\n            if (featureList.isEmpty()) {\n                groupedFeatures.remove(feature.getType());\n                groupedFeaturesDirty.remove(feature.getType());\n            }\n        }\n    }\n\n    public List<FeatureInterface<AbstractSequence<C>, C>> getFeaturesByType(String type) {\n        ArrayList<FeatureInterface<AbstractSequence<C>, C>> features = groupedFeatures.get(type);\n        if (features == null) {\n            features = new ArrayList<FeatureInterface<AbstractSequence<C>, C>>();\n        } else {\n            ensureGroupedFeaturesSorted(type);\n        }\n        return features;\n    }\n\n    public List<String> getComments() {\n        return comments;\n    }\n\n    public void setComments(List<String> comments) {\n        this.comments = comments;\n    }\n\n    public FeaturesKeyWordInterface getFeaturesKeyWord() {\n        return featuresKeyWord;\n    }\n\n    public void setFeaturesKeyWord(FeaturesKeyWordInterface featuresKeyWord) {\n        this.featuresKeyWord = featuresKeyWord;\n    }\n\n    public DatabaseReferenceInterface getDatabaseReferences() {\n        return databaseReferences;\n    }\n\n    public void setDatabaseReferences(DatabaseReferenceInterface databaseReferences) {\n        this.databaseReferences = databaseReferences;\n    }\n\n    public FeatureRetriever getFeatureRetriever() {\n        return featureRetriever;\n    }\n\n    public void setFeatureRetriever(FeatureRetriever featureRetriever) {\n        this.featureRetriever = featureRetriever;\n    }\n\n    public enum AnnotationType {\n        CURATED, PREDICTED, UNKNOWN;\n    }\n\n    @Override\n    public AccessionID getAccession() {\n        return accession;\n    }\n\n    public void setAccession(AccessionID accession) {\n        this.accession = accession;\n    }\n\n    public TaxonomyID getTaxonomy() {\n        return taxonomy;\n    }\n\n    public void setTaxonomy(TaxonomyID taxonomy) {\n        this.taxonomy = taxonomy;\n    }\n\n    @Override\n    public CompoundSet<C> getCompoundSet() {\n        if (compoundSet != null) {\n            return compoundSet;\n        }\n        return null;\n    }\n\n    public void setCompoundSet(CompoundSet<C> compoundSet) {\n        this.compoundSet = compoundSet;\n    }\n\n    @Override\n    public boolean equals(Object o){\n        if(! Equals.classEqual(this, o)) {\n            return false;\n        }\n        Sequence<C> other = (Sequence<C>)o;\n        if ( other.getCompoundSet() != getCompoundSet())\n            return false;\n        List<C> rawCompounds = getAsList();\n        List<C> otherCompounds = other.getAsList();\n        if ( rawCompounds.size() != otherCompounds.size())\n            return false;\n        for (int i = 0 ; i < rawCompounds.size() ; i++){\n            Compound myCompound = rawCompounds.get(i);\n            Compound otherCompound = otherCompounds.get(i);\n            if ( ! myCompound.equalsIgnoreCase(otherCompound))\n                return false;\n        }\n        return true;\n    }\n\n    @Override\n    public int hashCode(){\n        String s = getSequenceAsString();\n        return s.hashCode();\n    }\n\n    @Override\n    public String toString() {\n        return getSequenceAsString();\n    }\n\n    private SequenceReader<C> getSequenceStorage() {\n        if (sequenceStorage != null) {\n            return sequenceStorage;\n        }\n        if (parentSequence != null) {\n            if ( this.compoundSet.equals(parentSequence.getCompoundSet())){\n                sequenceStorage = new ArrayListSequenceReader<C>();\n                sequenceStorage.setCompoundSet(this.getCompoundSet());\n                try {\n                    sequenceStorage.setContents(parentSequence.getSequenceAsString());\n                } catch (CompoundNotFoundException e) {\n                    logger.error(\"Problem setting contents from parent sequence, some unrecognised compound: {}\",e.getMessage());\n                }\n                return sequenceStorage;\n            }\n        }\n        return null;\n    }\n\n    public String getSequenceAsString(Integer bioStart, Integer bioEnd, Strand strand) {\n        Location loc = new SimpleLocation(bioStart, bioEnd, strand);\n        return loc.getSubSequence(this).getSequenceAsString();\n    }\n\n    @Override\n    public String getSequenceAsString() {\n        return SequenceMixin.toString(this);\n    }\n\n    @Override\n    public List<C> getAsList() {\n        return sequenceStorage.getAsList();\n    }\n\n    @Override\n    public C getCompoundAt(int position) {\n        return getSequenceStorage().getCompoundAt(position);\n    }\n\n    @Override\n    public int getIndexOf(C compound) {\n        return getSequenceStorage().getIndexOf(compound);\n    }\n\n    @Override\n    public int getLastIndexOf(C compound) {\n        return getSequenceStorage().getLastIndexOf(compound);\n    }\n\n    @Override\n    public int getLength() {\n        return getSequenceStorage().getLength();\n    }\n\n    @Override\n    public SequenceView<C> getSubSequence(final Integer bioStart, final Integer bioEnd) {\n        return new SequenceProxyView<C>(this, bioStart, bioEnd);\n    }\n\n    @Override\n    public Iterator<C> iterator() {\n        return getSequenceStorage().iterator();\n    }\n\n    @Override\n    public int countCompounds(C... compounds) {\n        return SequenceMixin.countCompounds(this, compounds);\n    }\n\n    @Override\n    public SequenceView<C> getInverse() {\n        return SequenceMixin.inverse(this);\n    }\n\n    private void ensureFeaturesSorted() {\n        if (featuresDirty) {\n            synchronized (features) {\n                if (featuresDirty) {\n                    Collections.sort(features, AbstractFeature.LOCATION_LENGTH);\n                    featuresDirty = false;\n                }\n            }\n        }\n    }\n\n    private void ensureGroupedFeaturesSorted(String type) {\n        ArrayList<FeatureInterface<AbstractSequence<C>, C>> featureList = groupedFeatures.get(type);\n        if (featureList != null && groupedFeaturesDirty.contains(type)) {\n            synchronized (featureList) {\n                if (groupedFeaturesDirty.contains(type)) {\n                    Collections.sort(featureList, AbstractFeature.LOCATION_LENGTH);\n                    groupedFeaturesDirty.remove(type);\n                }\n            }\n        }\n    }\n}\n"
    ]
}