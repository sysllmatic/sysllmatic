{
    "0": [
        "\npackage org.biojava.nbio.core.sequence.template;\n\nimport org.biojava.nbio.core.sequence.compound.NucleotideCompound;\nimport org.biojava.nbio.core.sequence.storage.ArrayListSequenceReader;\nimport org.biojava.nbio.core.sequence.views.ComplementSequenceView;\nimport org.biojava.nbio.core.sequence.views.ReversedSequenceView;\nimport org.biojava.nbio.core.sequence.views.WindowedSequence;\nimport org.biojava.nbio.core.util.CRC64Checksum;\n\nimport java.io.IOException;\nimport java.util.*;\n\n\npublic class SequenceMixin {\n\n\t\n\tpublic static <C extends Compound> int countCompounds(\n\t\t\tSequence<C> sequence, C... compounds) {\n\t\tint count = 0;\n\t\tMap<C, Integer> compositon = getComposition(sequence);\n\t\tfor (C compound : compounds) {\n\t\t\tif(compositon.containsKey(compound)) {\n\t\t\t\tcount = compositon.get(compound) + count;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\n\t\n\tpublic static int countGC(Sequence<NucleotideCompound> sequence) {\n\t\tCompoundSet<NucleotideCompound> cs = sequence.getCompoundSet();\n\t\tNucleotideCompound G = cs.getCompoundForString(\"G\");\n\t\tNucleotideCompound C = cs.getCompoundForString(\"C\");\n\t\tNucleotideCompound g = cs.getCompoundForString(\"g\");\n\t\tNucleotideCompound c = cs.getCompoundForString(\"c\");\n\t\treturn countCompounds(sequence, G, C, g, c);\n\t}\n\n\t\n\tpublic static int countAT(Sequence<NucleotideCompound> sequence) {\n\t\tCompoundSet<NucleotideCompound> cs = sequence.getCompoundSet();\n\t\tNucleotideCompound A = cs.getCompoundForString(\"A\");\n\t\tNucleotideCompound T = cs.getCompoundForString(\"T\");\n\t\tNucleotideCompound a = cs.getCompoundForString(\"a\");\n\t\tNucleotideCompound t = cs.getCompoundForString(\"t\");\n\t\treturn countCompounds(sequence, A, T, a, t);\n\t}\n\n\t\n\tpublic static <C extends Compound> Map<C, Double> getDistribution(Sequence<C> sequence) {\n\t\tMap<C, Double> results = new HashMap<C, Double>();\n\t\tMap<C, Integer> composition = getComposition(sequence);\n\t\tdouble length = sequence.getLength();\n\t\tfor (Map.Entry<C, Integer> entry : composition.entrySet()) {\n\t\t\tdouble dist = entry.getValue().doubleValue() / length;\n\t\t\tresults.put(entry.getKey(), dist);\n\t\t}\n\t\treturn results;\n\t}\n\n\t\n\tpublic static <C extends Compound> Map<C, Integer> getComposition(Sequence<C> sequence) {\n\t\tMap<C, Integer> results = new HashMap<C, Integer>();\n\n\t\tfor (C currentCompound : sequence) {\n\t\t\tInteger currentInteger = results.get(currentCompound);\n\t\t\tif ( currentInteger == null)\n\t\t\t\tcurrentInteger = 0;\n\t\t\tcurrentInteger++;\n\t\t\tresults.put(currentCompound, currentInteger);\n\t\t}\n\t\treturn results;\n\t}\n\n\t\n\tpublic static <C extends Compound> void write(Appendable appendable, Sequence<C> sequence) throws IOException {\n\t\tfor(C compound: sequence) {\n\t\t\tappendable.append(compound.toString());\n\t\t}\n\t}\n\n\t\n\tpublic static <C extends Compound> StringBuilder toStringBuilder(Sequence<C> sequence) {\n\t\tStringBuilder sb = new StringBuilder(sequence.getLength());\n\t\tfor (C compound : sequence) {\n\t\t\tsb.append(compound.toString());\n\t\t}\n\t\treturn sb;\n\t}\n\n\t\n\tpublic static <C extends Compound> String toString(Sequence<C> sequence) {\n\t\treturn toStringBuilder(sequence).toString();\n\t}\n\n\t\n\tpublic static <C extends Compound> List<C> toList(Sequence<C> sequence) {\n\t\tList<C> list = new ArrayList<C>(sequence.getLength());\n\t\tfor (C compound : sequence) {\n\t\t\tlist.add(compound);\n\t\t}\n\t\treturn list;\n\t}\n\n\t\n\tpublic static <C extends Compound> int indexOf(Sequence<C> sequence,\n\t\t\tC compound) {\n\t\tint index = 1;\n\t\tfor (C currentCompound : sequence) {\n\t\t\tif (currentCompound.equals(compound)) {\n\t\t\t\treturn index;\n\t\t\t}\n\t\t\tindex++;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t\n\tpublic static <C extends Compound> int lastIndexOf(Sequence<C> sequence,\n\t\t\tC compound) {\n\t\tint index = indexOf(new ReversedSequenceView<C>(sequence), compound);\n\t\treturn (sequence.getLength() - index)+1;\n\t}\n\n\t\n\tpublic static <C extends Compound> Iterator<C> createIterator(\n\t\t\tSequence<C> sequence) {\n\t\treturn new SequenceIterator<C>(sequence);\n\t}\n\n\t\n\tpublic static <C extends Compound> SequenceView<C> createSubSequence(\n\t\t\tSequence<C> sequence, int start, int end) {\n\t\treturn new SequenceProxyView<C>(sequence, start, end);\n\t}\n\n\t\n\tpublic static <C extends Compound> Sequence<C> shuffle(Sequence<C> sequence) {\n\t\tList<C> compounds = sequence.getAsList();\n\t\tCollections.shuffle(compounds);\n\t\treturn new ArrayListSequenceReader<C>(compounds,\n\t\t\t\tsequence.getCompoundSet());\n\t}\n\n\t\n\tpublic static <C extends Compound> String checksum(Sequence<C> sequence) {\n\t\tCRC64Checksum checksum = new CRC64Checksum();\n\t\tfor (C compound : sequence) {\n\t\t\tchecksum.update(compound.getShortName());\n\t\t}\n\t\treturn checksum.toString();\n\t}\n\n\t\n\tpublic static <C extends Compound> List<SequenceView<C>> nonOverlappingKmers(Sequence<C> sequence, int kmer) {\n\t\tList<SequenceView<C>> l = new ArrayList<SequenceView<C>>();\n\t\tWindowedSequence<C> w = new WindowedSequence<C>(sequence, kmer);\n\t\tfor(SequenceView<C> view: w) {\n\t\t\tl.add(view);\n\t\t}\n\t\treturn l;\n\t}\n\n\t\n\tpublic static <C extends Compound> List<SequenceView<C>> overlappingKmers(Sequence<C> sequence, int kmer) {\n\t\tList<SequenceView<C>> l = new ArrayList<SequenceView<C>>();\n\t\tList<Iterator<SequenceView<C>>> windows\n\t\t\t\t= new ArrayList<Iterator<SequenceView<C>>>();\n\n\t\tfor(int i=1; i<=kmer; i++) {\n\t\t\tif(i == 1) {\n\t\t\t\twindows.add(new WindowedSequence<C>(sequence, kmer).iterator());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSequenceView<C> sv = sequence.getSubSequence(i, sequence.getLength());\n\t\t\t\twindows.add(new WindowedSequence<C>(sv, kmer).iterator());\n\t\t\t}\n\t\t}\n\n\t\tOUTER: while(true) {\n\t\t\tfor(int i=0; i<kmer; i++) {\n\t\t\t\tIterator<SequenceView<C>> iterator = windows.get(i);\n\t\t\t\tboolean breakLoop=true;\n\t\t\t\tif(iterator.hasNext()) {\n\t\t\t\t\tl.add(iterator.next());\n\t\t\t\t\tbreakLoop = false;\n\t\t\t\t}\n\t\t\t\tif(breakLoop) {\n\t\t\t\t\tbreak OUTER;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn l;\n\t}\n\n\t\n\t@SuppressWarnings({ \"unchecked\" })\n\tpublic static <C extends Compound> SequenceView<C> inverse(Sequence<C> sequence) {\n\t\tSequenceView<C> reverse = new ReversedSequenceView<C>(sequence);\n\t\tif(sequence.getCompoundSet().isComplementable()) {\n\t\t\treturn new ComplementSequenceView(reverse);\n\t\t}\n\t\treturn reverse;\n\t}\n\n\t\n\tpublic static <C extends Compound> boolean sequenceEqualityIgnoreCase(Sequence<C> source, Sequence<C> target) {\n\t\treturn baseSequenceEquality(source, target, true);\n\t}\n\n\t\n\tpublic static <C extends Compound> boolean sequenceEquality(Sequence<C> source, Sequence<C> target) {\n\t\treturn baseSequenceEquality(source, target, false);\n\t}\n\n\tprivate static <C extends Compound> boolean baseSequenceEquality(Sequence<C> source, Sequence<C> target, boolean ignoreCase) {\n\t\tboolean equal = true;\n\t\tif(\n\t\t\t\tsource.getLength() == target.getLength() &&\n\t\t\t\tsource.getCompoundSet().equals(target.getCompoundSet())) {\n\t\t\tIterator<C> sIter = source.iterator();\n\t\t\tIterator<C> tIter = target.iterator();\n\t\t\twhile(sIter.hasNext()) {\n\t\t\t\tC s = sIter.next();\n\t\t\t\tC t = tIter.next();\n\t\t\t\tboolean cEqual = (ignoreCase) ? s.equalsIgnoreCase(t) : s.equals(t);\n\t\t\t\tif(!cEqual) {\n\t\t\t\t\tequal = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tequal = false;\n\t\t}\n\t\treturn equal;\n\t}\n\n\t\n\tpublic static class SequenceIterator<C extends Compound>\n\t\t\timplements Iterator<C> {\n\n\t\tprivate final Sequence<C> sequence;\n\t\tprivate final int length;\n\t\tprivate int currentPosition = 0;\n\n\t\tpublic SequenceIterator(Sequence<C> sequence) {\n\t\t\tthis.sequence = sequence;\n\t\t\tthis.length = sequence.getLength();\n\t\t}\n\n\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\treturn (currentPosition < length);\n\t\t}\n\n\n\t\t@Override\n\t\tpublic C next() {\n\t\t\tif(!hasNext()) {\n\t\t\t\tthrow new NoSuchElementException(\"Exhausted sequence of elements\");\n\t\t\t}\n\t\t\treturn sequence.getCompoundAt(++currentPosition);\n\t\t}\n\n\t\t@Override\n\t\tpublic void remove() {\n\t\t\tthrow new UnsupportedOperationException(\"Cannot remove() on a SequenceIterator\");\n\t\t}\n\t}\n}\n"
    ],
    "1": [
        "package org.biojava.nbio.core.sequence.template;\n\nimport org.biojava.nbio.core.sequence.compound.NucleotideCompound;\nimport org.biojava.nbio.core.sequence.storage.ArrayListSequenceReader;\nimport org.biojava.nbio.core.sequence.views.ComplementSequenceView;\nimport org.biojava.nbio.core.sequence.views.ReversedSequenceView;\nimport org.biojava.nbio.core.sequence.views.WindowedSequence;\nimport org.biojava.nbio.core.util.CRC64Checksum;\n\nimport java.io.IOException;\nimport java.util.*;\n\npublic class SequenceMixin {\n\n    \n    public static <C extends Compound> int countCompounds(\n            Sequence<C> sequence, C... compounds) {\n        if (compounds == null || compounds.length == 0) return 0;\n        Set<C> compoundSet = new HashSet<>(Arrays.asList(compounds));\n        int count = 0;\n        for (C c : sequence) {\n            if (compoundSet.contains(c)) count++;\n        }\n        return count;\n    }\n\n    \n    public static int countGC(Sequence<NucleotideCompound> sequence) {\n        CompoundSet<NucleotideCompound> cs = sequence.getCompoundSet();\n        Set<NucleotideCompound> gcSet = new HashSet<>(Arrays.asList(\n                cs.getCompoundForString(\"G\"), cs.getCompoundForString(\"C\"),\n                cs.getCompoundForString(\"g\"), cs.getCompoundForString(\"c\")\n        ));\n        int count = 0;\n        for (NucleotideCompound nc : sequence) {\n            if (gcSet.contains(nc)) count++;\n        }\n        return count;\n    }\n\n    \n    public static int countAT(Sequence<NucleotideCompound> sequence) {\n        CompoundSet<NucleotideCompound> cs = sequence.getCompoundSet();\n        Set<NucleotideCompound> atSet = new HashSet<>(Arrays.asList(\n                cs.getCompoundForString(\"A\"), cs.getCompoundForString(\"T\"),\n                cs.getCompoundForString(\"a\"), cs.getCompoundForString(\"t\")\n        ));\n        int count = 0;\n        for (NucleotideCompound nc : sequence) {\n            if (atSet.contains(nc)) count++;\n        }\n        return count;\n    }\n\n    \n    public static <C extends Compound> Map<C, Integer> getComposition(Sequence<C> sequence) {\n        Map<C, Integer> results = new HashMap<>();\n        for (C c : sequence) {\n            results.merge(c, 1, Integer::sum);\n        }\n        return results;\n    }\n\n    \n    public static <C extends Compound> Map<C, Double> getDistribution(Sequence<C> sequence) {\n        Map<C, Double> results = new HashMap<>();\n        Map<C, Integer> composition = getComposition(sequence);\n        double length = sequence.getLength();\n        for (Map.Entry<C, Integer> entry : composition.entrySet()) {\n            results.put(entry.getKey(), entry.getValue() / length);\n        }\n        return results;\n    }\n\n    public static <C extends Compound> void write(Appendable appendable, Sequence<C> sequence) throws IOException {\n        for(C compound: sequence) {\n            appendable.append(compound.toString());\n        }\n    }\n\n    public static <C extends Compound> StringBuilder toStringBuilder(Sequence<C> sequence) {\n        StringBuilder sb = new StringBuilder(sequence.getLength());\n        for (C compound : sequence) {\n            sb.append(compound.toString());\n        }\n        return sb;\n    }\n\n    public static <C extends Compound> String toString(Sequence<C> sequence) {\n        return toStringBuilder(sequence).toString();\n    }\n\n    public static <C extends Compound> List<C> toList(Sequence<C> sequence) {\n        List<C> list = new ArrayList<>(sequence.getLength());\n        for (C compound : sequence) {\n            list.add(compound);\n        }\n        return list;\n    }\n\n    public static <C extends Compound> int indexOf(Sequence<C> sequence, C compound) {\n        int index = 1;\n        for (C currentCompound : sequence) {\n            if (currentCompound.equals(compound)) {\n                return index;\n            }\n            index++;\n        }\n        return 0;\n    }\n\n    public static <C extends Compound> int lastIndexOf(Sequence<C> sequence, C compound) {\n        \n        int len = sequence.getLength();\n        for (int i = len; i >= 1; i--) {\n            if (sequence.getCompoundAt(i).equals(compound)) {\n                return i;\n            }\n        }\n        return 0;\n    }\n\n    public static <C extends Compound> Iterator<C> createIterator(Sequence<C> sequence) {\n        return new SequenceIterator<>(sequence);\n    }\n\n    public static <C extends Compound> SequenceView<C> createSubSequence(\n            Sequence<C> sequence, int start, int end) {\n        return new SequenceProxyView<>(sequence, start, end);\n    }\n\n    public static <C extends Compound> Sequence<C> shuffle(Sequence<C> sequence) {\n        List<C> compounds = sequence.getAsList();\n        Collections.shuffle(compounds);\n        return new ArrayListSequenceReader<>(compounds,\n                sequence.getCompoundSet());\n    }\n\n    public static <C extends Compound> String checksum(Sequence<C> sequence) {\n        CRC64Checksum checksum = new CRC64Checksum();\n        for (C compound : sequence) {\n            checksum.update(compound.getShortName());\n        }\n        return checksum.toString();\n    }\n\n    public static <C extends Compound> List<SequenceView<C>> nonOverlappingKmers(Sequence<C> sequence, int kmer) {\n        List<SequenceView<C>> l = new ArrayList<>();\n        WindowedSequence<C> w = new WindowedSequence<>(sequence, kmer);\n        for(SequenceView<C> view: w) {\n            l.add(view);\n        }\n        return l;\n    }\n\n    public static <C extends Compound> List<SequenceView<C>> overlappingKmers(Sequence<C> sequence, int kmer) {\n        List<SequenceView<C>> l = new ArrayList<>();\n        int len = sequence.getLength();\n        if (kmer <= 0 || kmer > len) return l;\n        for (int i = 1; i <= len - kmer + 1; i++) {\n            l.add(sequence.getSubSequence(i, i + kmer - 1));\n        }\n        return l;\n    }\n\n    @SuppressWarnings({ \"unchecked\" })\n    public static <C extends Compound> SequenceView<C> inverse(Sequence<C> sequence) {\n        SequenceView<C> reverse = new ReversedSequenceView<>(sequence);\n        if(sequence.getCompoundSet().isComplementable()) {\n            return new ComplementSequenceView(reverse);\n        }\n        return reverse;\n    }\n\n    public static <C extends Compound> boolean sequenceEqualityIgnoreCase(Sequence<C> source, Sequence<C> target) {\n        return baseSequenceEquality(source, target, true);\n    }\n\n    public static <C extends Compound> boolean sequenceEquality(Sequence<C> source, Sequence<C> target) {\n        return baseSequenceEquality(source, target, false);\n    }\n\n    private static <C extends Compound> boolean baseSequenceEquality(Sequence<C> source, Sequence<C> target, boolean ignoreCase) {\n        if(source.getLength() != target.getLength() ||\n           !source.getCompoundSet().equals(target.getCompoundSet())) {\n            return false;\n        }\n        Iterator<C> sIter = source.iterator();\n        Iterator<C> tIter = target.iterator();\n        while(sIter.hasNext()) {\n            C s = sIter.next();\n            C t = tIter.next();\n            boolean cEqual = (ignoreCase) ? s.equalsIgnoreCase(t) : s.equals(t);\n            if(!cEqual) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static class SequenceIterator<C extends Compound>\n            implements Iterator<C> {\n\n        private final Sequence<C> sequence;\n        private final int length;\n        private int currentPosition = 0;\n\n        public SequenceIterator(Sequence<C> sequence) {\n            this.sequence = sequence;\n            this.length = sequence.getLength();\n        }\n\n        @Override\n        public boolean hasNext() {\n            return (currentPosition < length);\n        }\n\n        @Override\n        public C next() {\n            if(!hasNext()) {\n                throw new NoSuchElementException(\"Exhausted sequence of elements\");\n            }\n            return sequence.getCompoundAt(++currentPosition);\n        }\n\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException(\"Cannot remove() on a SequenceIterator\");\n        }\n    }\n}\n"
    ],
    "2": [
        "package org.biojava.nbio.core.sequence.template;\n\nimport org.biojava.nbio.core.sequence.compound.NucleotideCompound;\nimport org.biojava.nbio.core.sequence.storage.ArrayListSequenceReader;\nimport org.biojava.nbio.core.sequence.views.ComplementSequenceView;\nimport org.biojava.nbio.core.sequence.views.ReversedSequenceView;\nimport org.biojava.nbio.core.sequence.views.WindowedSequence;\nimport org.biojava.nbio.core.util.CRC64Checksum;\n\nimport java.io.IOException;\nimport java.util.*;\n\npublic class SequenceMixin {\n    private static final String[] GC_STRINGS = {\"G\", \"C\", \"g\", \"c\"};\n    private static final String[] AT_STRINGS = {\"A\", \"T\", \"a\", \"t\"};\n\n    public static <C extends Compound> int countCompounds(Sequence<C> sequence, C... compounds) {\n        if (compounds == null || compounds.length == 0) return 0;\n        if (compounds.length == 1) {\n            \n            C cmp = compounds[0];\n            int count = 0;\n            for (C c : sequence) {\n                if (c.equals(cmp)) count++;\n            }\n            return count;\n        } else {\n            Set<C> compoundSet = new HashSet<>(Arrays.asList(compounds));\n            int count = 0;\n            for (C c : sequence) {\n                if (compoundSet.contains(c)) count++;\n            }\n            return count;\n        }\n    }\n\n    public static int countGC(Sequence<NucleotideCompound> sequence) {\n        Set<NucleotideCompound> gcSet = new HashSet<>(4);\n        Object cs = sequence.getCompoundSet();\n        for (String s : GC_STRINGS) {\n            try {\n                NucleotideCompound nc = (NucleotideCompound) (cs.getClass().getMethod(\"getCompoundForString\", String.class).invoke(cs, s));\n                if (nc != null) gcSet.add(nc);\n            } catch (Exception e) {\n                \n            }\n        }\n        int count = 0;\n        for (NucleotideCompound nc : sequence) {\n            if (gcSet.contains(nc)) count++;\n        }\n        return count;\n    }\n\n    public static int countAT(Sequence<NucleotideCompound> sequence) {\n        Set<NucleotideCompound> atSet = new HashSet<>(4);\n        Object cs = sequence.getCompoundSet();\n        for (String s : AT_STRINGS) {\n            try {\n                NucleotideCompound nc = (NucleotideCompound) (cs.getClass().getMethod(\"getCompoundForString\", String.class).invoke(cs, s));\n                if (nc != null) atSet.add(nc);\n            } catch (Exception e) {\n                \n            }\n        }\n        int count = 0;\n        for (NucleotideCompound nc : sequence) {\n            if (atSet.contains(nc)) count++;\n        }\n        return count;\n    }\n\n    public static <C extends Compound> Map<C, Integer> getComposition(Sequence<C> sequence) {\n        int estimatedKeys = Math.max(16, (int)Math.min(sequence.getLength(), 128));\n        Map<C, Integer> results = new HashMap<>(estimatedKeys);\n        for (C c : sequence) {\n            results.merge(c, 1, Integer::sum);\n        }\n        return results;\n    }\n\n    public static <C extends Compound> Map<C, Double> getDistribution(Sequence<C> sequence) {\n        Map<C, Double> results = new HashMap<>();\n        Map<C, Integer> composition = getComposition(sequence);\n        double length = sequence.getLength();\n        for (Map.Entry<C, Integer> entry : composition.entrySet()) {\n            results.put(entry.getKey(), entry.getValue() / length);\n        }\n        return results;\n    }\n\n    public static <C extends Compound> void write(Appendable appendable, Sequence<C> sequence) throws IOException {\n        if (appendable instanceof StringBuilder) {\n            StringBuilder sb = (StringBuilder) appendable;\n            for (C compound : sequence) {\n                sb.append(compound.toString());\n            }\n        } else {\n            for (C compound : sequence) {\n                appendable.append(compound.toString());\n            }\n        }\n    }\n\n    public static <C extends Compound> StringBuilder toStringBuilder(Sequence<C> sequence) {\n        StringBuilder sb = new StringBuilder(sequence.getLength());\n        for (C compound : sequence) {\n            sb.append(compound.toString());\n        }\n        return sb;\n    }\n\n    public static <C extends Compound> String toString(Sequence<C> sequence) {\n        return toStringBuilder(sequence).toString();\n    }\n\n    public static <C extends Compound> List<C> toList(Sequence<C> sequence) {\n        List<C> list = new ArrayList<>(sequence.getLength());\n        for (C compound : sequence) {\n            list.add(compound);\n        }\n        return list;\n    }\n\n    public static <C extends Compound> int indexOf(Sequence<C> sequence, C compound) {\n        int index = 1;\n        for (C currentCompound : sequence) {\n            if (currentCompound.equals(compound)) {\n                return index;\n            }\n            index++;\n        }\n        return 0;\n    }\n\n    public static <C extends Compound> int lastIndexOf(Sequence<C> sequence, C compound) {\n        int len = sequence.getLength();\n        for (int i = len; i >= 1; i--) {\n            if (sequence.getCompoundAt(i).equals(compound)) {\n                return i;\n            }\n        }\n        return 0;\n    }\n\n    public static <C extends Compound> Iterator<C> createIterator(Sequence<C> sequence) {\n        return new SequenceIterator<>(sequence);\n    }\n\n    public static <C extends Compound> SequenceView<C> createSubSequence(Sequence<C> sequence, int start, int end) {\n        return new SequenceProxyView<>(sequence, start, end);\n    }\n\n    public static <C extends Compound> Sequence<C> shuffle(Sequence<C> sequence) {\n        List<C> compounds = sequence.getAsList();\n        Collections.shuffle(compounds);\n        return new ArrayListSequenceReader<>(compounds, sequence.getCompoundSet());\n    }\n\n    public static <C extends Compound> String checksum(Sequence<C> sequence) {\n        CRC64Checksum checksum = new CRC64Checksum();\n        for (C compound : sequence) {\n            checksum.update(compound.getShortName());\n        }\n        return checksum.toString();\n    }\n\n    public static <C extends Compound> List<SequenceView<C>> nonOverlappingKmers(Sequence<C> sequence, int kmer) {\n        int maxKmers = Math.max(4, sequence.getLength()/Math.max(1, kmer));\n        List<SequenceView<C>> l = new ArrayList<>(maxKmers);\n        WindowedSequence<C> w = new WindowedSequence<>(sequence, kmer);\n        for(SequenceView<C> view: w) {\n            l.add(view);\n        }\n        return l;\n    }\n\n    public static <C extends Compound> List<SequenceView<C>> overlappingKmers(Sequence<C> sequence, int kmer) {\n        int len = sequence.getLength();\n        if (kmer <= 0 || kmer > len) return new ArrayList<>();\n        int nKmers = len - kmer + 1;\n        List<SequenceView<C>> l = new ArrayList<>(nKmers);\n        for (int i = 1; i <= nKmers; i++) {\n            l.add(sequence.getSubSequence(i, i + kmer - 1));\n        }\n        return l;\n    }\n\n    @SuppressWarnings({ \"unchecked\" })\n    public static <C extends Compound> SequenceView<C> inverse(Sequence<C> sequence) {\n        SequenceView<C> reverse = new ReversedSequenceView<>(sequence);\n        if(sequence.getCompoundSet().isComplementable()) {\n            return new ComplementSequenceView(reverse);\n        }\n        return reverse;\n    }\n\n    public static <C extends Compound> boolean sequenceEqualityIgnoreCase(Sequence<C> source, Sequence<C> target) {\n        return baseSequenceEquality(source, target, true);\n    }\n\n    public static <C extends Compound> boolean sequenceEquality(Sequence<C> source, Sequence<C> target) {\n        return baseSequenceEquality(source, target, false);\n    }\n\n    private static <C extends Compound> boolean baseSequenceEquality(Sequence<C> source, Sequence<C> target, boolean ignoreCase) {\n        if(source.getLength() != target.getLength() ||\n           !source.getCompoundSet().equals(target.getCompoundSet())) {\n            return false;\n        }\n        Iterator<C> sIter = source.iterator();\n        Iterator<C> tIter = target.iterator();\n        while(sIter.hasNext()) {\n            C s = sIter.next();\n            C t = tIter.next();\n            boolean cEqual = (ignoreCase) ? s.equalsIgnoreCase(t) : s.equals(t);\n            if(!cEqual) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static class SequenceIterator<C extends Compound>\n            implements Iterator<C> {\n        private final Sequence<C> sequence;\n        private final int length;\n        private int currentPosition = 0;\n        public SequenceIterator(Sequence<C> sequence) {\n            this.sequence = sequence;\n            this.length = sequence.getLength();\n        }\n        @Override\n        public boolean hasNext() {\n            return (currentPosition < length);\n        }\n        @Override\n        public C next() {\n            if(!hasNext()) {\n                throw new NoSuchElementException(\"Exhausted sequence of elements\");\n            }\n            return sequence.getCompoundAt(++currentPosition);\n        }\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException(\"Cannot remove() on a SequenceIterator\");\n        }\n    }\n}\n"
    ]
}