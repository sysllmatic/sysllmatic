{
    "0": [
        "\n\n\n\npackage org.apache.fop.util;\n\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\n\n\npublic class CharUtilities {\n\n    \n    public static final char CODE_EOT = 0;\n\n    \n    public static final int UCWHITESPACE = 0;\n    \n    public static final int LINEFEED = 1;\n    \n    public static final int EOT = 2;\n    \n    public static final int NONWHITESPACE = 3;\n    \n    public static final int XMLWHITESPACE = 4;\n\n\n    \n    public static final char NULL_CHAR = '\\u0000';\n    \n    public static final char LINEFEED_CHAR = '\\n';\n    \n    public static final char CARRIAGE_RETURN = '\\r';\n    \n    public static final char TAB = '\\t';\n    \n    public static final char SPACE = '\\u0020';\n    \n    public static final char NBSPACE = '\\u00A0';\n    \n    public static final char NEXT_LINE = '\\u0085';\n    \n    public static final char ZERO_WIDTH_SPACE = '\\u200B';\n    \n    public static final char WORD_JOINER = '\\u2060';\n    \n    public static final char ZERO_WIDTH_JOINER = '\\u200D';\n    \n    public static final char LRM = '\\u200E';\n    \n    public static final char RLM = '\\u202F';\n    \n    public static final char LRE = '\\u202A';\n    \n    public static final char RLE = '\\u202B';\n    \n    public static final char PDF = '\\u202C';\n    \n    public static final char LRO = '\\u202D';\n    \n    public static final char RLO = '\\u202E';\n    \n    public static final char ZERO_WIDTH_NOBREAK_SPACE = '\\uFEFF';\n    \n    public static final char SOFT_HYPHEN = '\\u00AD';\n    \n    public static final char LINE_SEPARATOR = '\\u2028';\n    \n    public static final char PARAGRAPH_SEPARATOR = '\\u2029';\n    \n    public static final char MISSING_IDEOGRAPH = '\\u25A1';\n    \n    public static final char IDEOGRAPHIC_SPACE = '\\u3000';\n    \n    public static final char OBJECT_REPLACEMENT_CHARACTER = '\\uFFFC';\n    \n    public static final char NOT_A_CHARACTER = '\\uFFFF';\n\n    \n    protected CharUtilities() {\n        throw new UnsupportedOperationException();\n    }\n\n    \n    public static int classOf(int c) {\n        switch (c) {\n            case CODE_EOT:\n                return EOT;\n            case LINEFEED_CHAR:\n                return LINEFEED;\n            case SPACE:\n            case CARRIAGE_RETURN:\n            case TAB:\n                return XMLWHITESPACE;\n            default:\n                return isAnySpace(c) ? UCWHITESPACE : NONWHITESPACE;\n        }\n    }\n\n\n    \n    public static boolean isBreakableSpace(int c) {\n        return (c == SPACE || isFixedWidthSpace(c));\n    }\n\n    \n    public static boolean isZeroWidthSpace(int c) {\n        return c == ZERO_WIDTH_SPACE           \n            || c == WORD_JOINER                \n            || c == ZERO_WIDTH_NOBREAK_SPACE;  \n    }\n\n    \n    public static boolean isFixedWidthSpace(int c) {\n        return (c >= '\\u2000' && c <= '\\u200B')\n                || c == '\\u3000';\n\n\n\n\n\n\n\n\n\n\n\n\n\n    }\n\n    \n    public static boolean isNonBreakableSpace(int c) {\n        return\n            (c == NBSPACE       \n            || c == '\\u202F'    \n            || c == '\\u3000'    \n            || c == WORD_JOINER \n            || c == ZERO_WIDTH_NOBREAK_SPACE);  \n    }\n\n    \n    public static boolean isAdjustableSpace(int c) {\n        \n        return\n            (c == '\\u0020'    \n            || c == NBSPACE); \n    }\n\n    \n    public static boolean isAnySpace(int c) {\n        return (isBreakableSpace(c) || isNonBreakableSpace(c));\n    }\n\n    \n    public static boolean isAlphabetic(int c) {\n        \n        \n        int generalCategory = Character.getType((char)c);\n        switch (generalCategory) {\n            case Character.UPPERCASE_LETTER: \n            case Character.LOWERCASE_LETTER: \n            case Character.TITLECASE_LETTER: \n            case Character.MODIFIER_LETTER: \n            case Character.OTHER_LETTER: \n            case Character.LETTER_NUMBER: \n                return true;\n            default:\n                \n                \n                return false;\n        }\n    }\n\n    \n    public static boolean isExplicitBreak(int c) {\n        return (c == LINEFEED_CHAR\n            || c == CARRIAGE_RETURN\n            || c == NEXT_LINE\n            || c == LINE_SEPARATOR\n            || c == PARAGRAPH_SEPARATOR);\n    }\n\n    \n    public static String charToNCRef(int c) {\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0, nDigits = (c > 0xFFFF) ? 6 : 4; i < nDigits; i++, c >>= 4) {\n            int d = c & 0xF;\n            char hd;\n            if (d < 10) {\n                hd = (char) ((int) '0' + d);\n            } else {\n                hd = (char) ((int) 'A' + (d - 10));\n            }\n            sb.append(hd);\n        }\n        return \"&#x\" + sb.reverse() + \";\";\n    }\n\n    \n    public static String toNCRefs(String s) {\n        StringBuffer sb = new StringBuffer();\n        if (s != null) {\n            for (int i = 0; i < s.length(); i++) {\n                char c = s.charAt(i);\n                if ((c >= 32) && (c < 127)) {\n                    if (c == '<') {\n                        sb.append(\"&lt;\");\n                    } else if (c == '>') {\n                        sb.append(\"&gt;\");\n                    } else if (c == '&') {\n                        sb.append(\"&amp;\");\n                    } else {\n                        sb.append(c);\n                    }\n                } else {\n                    sb.append(charToNCRef(c));\n                }\n            }\n        }\n        return sb.toString();\n    }\n\n    \n    public static String padLeft(String s, int width, char pad) {\n        StringBuffer sb = new StringBuffer();\n        for (int i = s.length(); i < width; i++) {\n            sb.append(pad);\n        }\n        sb.append(s);\n        return sb.toString();\n    }\n\n    \n    public static String format(int c) {\n        if (c < 1114112) {\n            return \"0x\" + padLeft(Integer.toString(c, 16), (c < 65536) ? 4 : 6, '0');\n        } else {\n            return \"!NOT A CHARACTER!\";\n        }\n    }\n\n    \n    public static boolean isSameSequence(CharSequence cs1, CharSequence cs2) {\n        assert cs1 != null;\n        assert cs2 != null;\n        if (cs1.length() != cs2.length()) {\n            return false;\n        } else {\n            for (int i = 0, n = cs1.length(); i < n; i++) {\n                if (cs1.charAt(i) != cs2.charAt(i)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    \n    public static boolean isBmpCodePoint(int codePoint) {\n        return codePoint >>> 16 == 0;\n    }\n\n    \n    public static int incrementIfNonBMP(int codePoint) {\n        return isBmpCodePoint(codePoint) ? 0 : 1;\n    }\n\n    \n    public static boolean isSurrogatePair(char ch) {\n        return Character.isHighSurrogate(ch) || Character.isLowSurrogate(ch);\n    }\n\n    \n    public static boolean containsSurrogatePairAt(CharSequence chars, int index) {\n        char ch = chars.charAt(index);\n\n        if (Character.isHighSurrogate(ch)) {\n            if ((index + 1) > chars.length()) {\n                throw new IllegalArgumentException(\n                        \"ill-formed UTF-16 sequence, contains isolated high surrogate at end of sequence\");\n            }\n\n            if (Character.isLowSurrogate(chars.charAt(index + 1))) {\n                return true;\n            }\n\n            throw new IllegalArgumentException(\n                    \"ill-formed UTF-16 sequence, contains isolated high surrogate at index \" + index);\n\n        } else if (Character.isLowSurrogate(ch)) {\n            throw new IllegalArgumentException(\n                    \"ill-formed UTF-16 sequence, contains isolated low surrogate at index \" + index);\n        }\n\n        return false;\n    }\n\n    \n    public static Iterable<Integer> codepointsIter(final CharSequence s) {\n        return codepointsIter(s, 0, s.length());\n    }\n\n    \n    public static Iterable<Integer> codepointsIter(final CharSequence s, final int beginIndex, final int endIndex) {\n        if (beginIndex < 0) {\n            throw new StringIndexOutOfBoundsException(beginIndex);\n        }\n        if (endIndex > s.length()) {\n            throw new StringIndexOutOfBoundsException(endIndex);\n        }\n        int subLen = endIndex - beginIndex;\n        if (subLen < 0) {\n            throw new StringIndexOutOfBoundsException(subLen);\n        }\n\n        return new Iterable<Integer>() {\n            public Iterator<Integer> iterator() {\n                return new Iterator<Integer>() {\n                    int nextIndex = beginIndex;\n\n                    public boolean hasNext() {\n                        return nextIndex < endIndex;\n                    }\n\n                    public Integer next() {\n                        if (!hasNext()) {\n                            \n                            throw new NoSuchElementException();\n                        }\n                        int result = Character.codePointAt(s, nextIndex);\n                        nextIndex += Character.charCount(result);\n                        return result;\n                    }\n\n                    public void remove() {\n                        throw new UnsupportedOperationException();\n                    }\n                };\n            }\n        };\n    }\n}\n"
    ],
    "1": [
        "package org.apache.fop.util;\n\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\n\npublic class CharUtilities {\n\n    public static final char CODE_EOT = 0;\n    public static final int UCWHITESPACE = 0;\n    public static final int LINEFEED = 1;\n    public static final int EOT = 2;\n    public static final int NONWHITESPACE = 3;\n    public static final int XMLWHITESPACE = 4;\n\n    public static final char NULL_CHAR = '\\u0000';\n    public static final char LINEFEED_CHAR = '\\n';\n    public static final char CARRIAGE_RETURN = '\\r';\n    public static final char TAB = '\\t';\n    public static final char SPACE = '\\u0020';\n    public static final char NBSPACE = '\\u00A0';\n    public static final char NEXT_LINE = '\\u0085';\n    public static final char ZERO_WIDTH_SPACE = '\\u200B';\n    public static final char WORD_JOINER = '\\u2060';\n    public static final char ZERO_WIDTH_JOINER = '\\u200D';\n    public static final char LRM = '\\u200E';\n    public static final char RLM = '\\u202F';\n    public static final char LRE = '\\u202A';\n    public static final char RLE = '\\u202B';\n    public static final char PDF = '\\u202C';\n    public static final char LRO = '\\u202D';\n    public static final char RLO = '\\u202E';\n    public static final char ZERO_WIDTH_NOBREAK_SPACE = '\\uFEFF';\n    public static final char SOFT_HYPHEN = '\\u00AD';\n    public static final char LINE_SEPARATOR = '\\u2028';\n    public static final char PARAGRAPH_SEPARATOR = '\\u2029';\n    public static final char MISSING_IDEOGRAPH = '\\u25A1';\n    public static final char IDEOGRAPHIC_SPACE = '\\u3000';\n    public static final char OBJECT_REPLACEMENT_CHARACTER = '\\uFFFC';\n    public static final char NOT_A_CHARACTER = '\\uFFFF';\n\n    protected CharUtilities() {\n        throw new UnsupportedOperationException();\n    }\n\n    public static int classOf(int c) {\n        switch (c) {\n            case CODE_EOT:\n                return EOT;\n            case LINEFEED_CHAR:\n                return LINEFEED;\n            case SPACE:\n            case CARRIAGE_RETURN:\n            case TAB:\n                return XMLWHITESPACE;\n            default:\n                return isAnySpace(c) ? UCWHITESPACE : NONWHITESPACE;\n        }\n    }\n\n    public static boolean isBreakableSpace(int c) {\n        return (c == SPACE || isFixedWidthSpace(c));\n    }\n\n    public static boolean isZeroWidthSpace(int c) {\n        return c == ZERO_WIDTH_SPACE\n            || c == WORD_JOINER\n            || c == ZERO_WIDTH_NOBREAK_SPACE;\n    }\n\n    public static boolean isFixedWidthSpace(int c) {\n        return (c >= '\\u2000' && c <= '\\u200B') || c == '\\u3000';\n    }\n\n    public static boolean isNonBreakableSpace(int c) {\n        return (c == NBSPACE\n            || c == '\\u202F'\n            || c == '\\u3000'\n            || c == WORD_JOINER\n            || c == ZERO_WIDTH_NOBREAK_SPACE);\n    }\n\n    public static boolean isAdjustableSpace(int c) {\n        return (c == '\\u0020' || c == NBSPACE);\n    }\n\n    public static boolean isAnySpace(int c) {\n        return (isBreakableSpace(c) || isNonBreakableSpace(c));\n    }\n\n    public static boolean isAlphabetic(int c) {\n        int generalCategory = Character.getType((char)c);\n        switch (generalCategory) {\n            case Character.UPPERCASE_LETTER:\n            case Character.LOWERCASE_LETTER:\n            case Character.TITLECASE_LETTER:\n            case Character.MODIFIER_LETTER:\n            case Character.OTHER_LETTER:\n            case Character.LETTER_NUMBER:\n                return true;\n            default:\n                return false;\n        }\n    }\n\n    public static boolean isExplicitBreak(int c) {\n        return (c == LINEFEED_CHAR\n            || c == CARRIAGE_RETURN\n            || c == NEXT_LINE\n            || c == LINE_SEPARATOR\n            || c == PARAGRAPH_SEPARATOR);\n    }\n\n    public static String charToNCRef(int c) {\n        \n        int nDigits = (c > 0xFFFF) ? 6 : 4;\n        char[] hex = new char[nDigits];\n        int value = c;\n        for (int i = nDigits - 1; i >= 0; i--) {\n            int d = value & 0xF;\n            hex[i] = (char) (d < 10 ? ('0' + d) : ('A' + (d - 10)));\n            value >>= 4;\n        }\n        return \"&#x\" + new String(hex) + \";\";\n    }\n\n    public static String toNCRefs(String s) {\n        if (s == null) {\n            return \"\";\n        }\n        \n        StringBuilder sb = new StringBuilder(s.length() + 16);\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if ((c >= 32) && (c < 127)) {\n                switch (c) {\n                    case '<':\n                        sb.append(\"&lt;\");\n                        break;\n                    case '>':\n                        sb.append(\"&gt;\");\n                        break;\n                    case '&':\n                        sb.append(\"&amp;\");\n                        break;\n                    default:\n                        sb.append(c);\n                        break;\n                }\n            } else {\n                sb.append(charToNCRef(c));\n            }\n        }\n        return sb.toString();\n    }\n\n    public static String padLeft(String s, int width, char pad) {\n        int nPad = width - s.length();\n        if (nPad <= 0) {\n            return s;\n        }\n        StringBuilder sb = new StringBuilder(width);\n        for (int i = 0; i < nPad; i++) {\n            sb.append(pad);\n        }\n        sb.append(s);\n        return sb.toString();\n    }\n\n    public static String format(int c) {\n        if (c < 1114112) {\n            return \"0x\" + padLeft(Integer.toString(c, 16), (c < 65536) ? 4 : 6, '0');\n        } else {\n            return \"!NOT A CHARACTER!\";\n        }\n    }\n\n    public static boolean isSameSequence(CharSequence cs1, CharSequence cs2) {\n        assert cs1 != null;\n        assert cs2 != null;\n        int n = cs1.length();\n        if (n != cs2.length()) {\n            return false;\n        }\n        for (int i = 0; i < n; i++) {\n            if (cs1.charAt(i) != cs2.charAt(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static boolean isBmpCodePoint(int codePoint) {\n        return codePoint >>> 16 == 0;\n    }\n\n    public static int incrementIfNonBMP(int codePoint) {\n        return isBmpCodePoint(codePoint) ? 0 : 1;\n    }\n\n    public static boolean isSurrogatePair(char ch) {\n        return Character.isHighSurrogate(ch) || Character.isLowSurrogate(ch);\n    }\n\n    public static boolean containsSurrogatePairAt(CharSequence chars, int index) {\n        char ch = chars.charAt(index);\n        if (Character.isHighSurrogate(ch)) {\n            if ((index + 1) > chars.length()) {\n                throw new IllegalArgumentException(\n                        \"ill-formed UTF-16 sequence, contains isolated high surrogate at end of sequence\");\n            }\n            if (Character.isLowSurrogate(chars.charAt(index + 1))) {\n                return true;\n            }\n            throw new IllegalArgumentException(\n                    \"ill-formed UTF-16 sequence, contains isolated high surrogate at index \" + index);\n        } else if (Character.isLowSurrogate(ch)) {\n            throw new IllegalArgumentException(\n                    \"ill-formed UTF-16 sequence, contains isolated low surrogate at index \" + index);\n        }\n        return false;\n    }\n\n    public static Iterable<Integer> codepointsIter(final CharSequence s) {\n        return codepointsIter(s, 0, s.length());\n    }\n\n    public static Iterable<Integer> codepointsIter(final CharSequence s, final int beginIndex, final int endIndex) {\n        if (beginIndex < 0) {\n            throw new StringIndexOutOfBoundsException(beginIndex);\n        }\n        if (endIndex > s.length()) {\n            throw new StringIndexOutOfBoundsException(endIndex);\n        }\n        int subLen = endIndex - beginIndex;\n        if (subLen < 0) {\n            throw new StringIndexOutOfBoundsException(subLen);\n        }\n        return new Iterable<Integer>() {\n            public Iterator<Integer> iterator() {\n                return new Iterator<Integer>() {\n                    int nextIndex = beginIndex;\n                    public boolean hasNext() {\n                        return nextIndex < endIndex;\n                    }\n                    public Integer next() {\n                        if (!hasNext()) {\n                            throw new NoSuchElementException();\n                        }\n                        int result = Character.codePointAt(s, nextIndex);\n                        nextIndex += Character.charCount(result);\n                        return result;\n                    }\n                    public void remove() {\n                        throw new UnsupportedOperationException();\n                    }\n                };\n            }\n        };\n    }\n}\n"
    ],
    "2": [
        "package org.apache.fop.util;\n\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\n\npublic class CharUtilities {\n\n    public static final char CODE_EOT = 0;\n    public static final int UCWHITESPACE = 0;\n    public static final int LINEFEED = 1;\n    public static final int EOT = 2;\n    public static final int NONWHITESPACE = 3;\n    public static final int XMLWHITESPACE = 4;\n\n    public static final char NULL_CHAR = '\\u0000';\n    public static final char LINEFEED_CHAR = '\\n';\n    public static final char CARRIAGE_RETURN = '\\r';\n    public static final char TAB = '\\t';\n    public static final char SPACE = '\\u0020';\n    public static final char NBSPACE = '\\u00A0';\n    public static final char NEXT_LINE = '\\u0085';\n    public static final char ZERO_WIDTH_SPACE = '\\u200B';\n    public static final char WORD_JOINER = '\\u2060';\n    public static final char ZERO_WIDTH_JOINER = '\\u200D';\n    public static final char LRM = '\\u200E';\n    public static final char RLM = '\\u202F';\n    public static final char LRE = '\\u202A';\n    public static final char RLE = '\\u202B';\n    public static final char PDF = '\\u202C';\n    public static final char LRO = '\\u202D';\n    public static final char RLO = '\\u202E';\n    public static final char ZERO_WIDTH_NOBREAK_SPACE = '\\uFEFF';\n    public static final char SOFT_HYPHEN = '\\u00AD';\n    public static final char LINE_SEPARATOR = '\\u2028';\n    public static final char PARAGRAPH_SEPARATOR = '\\u2029';\n    public static final char MISSING_IDEOGRAPH = '\\u25A1';\n    public static final char IDEOGRAPHIC_SPACE = '\\u3000';\n    public static final char OBJECT_REPLACEMENT_CHARACTER = '\\uFFFC';\n    public static final char NOT_A_CHARACTER = '\\uFFFF';\n\n    \n    private static final boolean[] ASCII_SPACE = new boolean[128];\n    static {\n        ASCII_SPACE[' '] = true;\n        ASCII_SPACE['\\t'] = true;\n        ASCII_SPACE['\\n'] = true;\n        ASCII_SPACE['\\r'] = true;\n    }\n\n    protected CharUtilities() {\n        throw new UnsupportedOperationException();\n    }\n\n    public static int classOf(int c) {\n        switch (c) {\n            case CODE_EOT:\n                return EOT;\n            case LINEFEED_CHAR:\n                return LINEFEED;\n            case SPACE:\n            case CARRIAGE_RETURN:\n            case TAB:\n                return XMLWHITESPACE;\n            default:\n                return isAnySpace(c) ? UCWHITESPACE : NONWHITESPACE;\n        }\n    }\n\n    public static boolean isBreakableSpace(int c) {\n        \n        if (c < 128) {\n            return c == SPACE || c == TAB;\n        }\n        return isFixedWidthSpace(c);\n    }\n\n    public static boolean isZeroWidthSpace(int c) {\n        return c == ZERO_WIDTH_SPACE\n            || c == WORD_JOINER\n            || c == ZERO_WIDTH_NOBREAK_SPACE;\n    }\n\n    public static boolean isFixedWidthSpace(int c) {\n        return (c >= '\\u2000' && c <= '\\u200B') || c == '\\u3000';\n    }\n\n    public static boolean isNonBreakableSpace(int c) {\n        \n        return (c == NBSPACE\n            || c == '\\u202F'\n            || c == '\\u3000'\n            || c == WORD_JOINER\n            || c == ZERO_WIDTH_NOBREAK_SPACE);\n    }\n\n    public static boolean isAdjustableSpace(int c) {\n        \n        return (c == ' ' || c == NBSPACE);\n    }\n\n    public static boolean isAnySpace(int c) {\n        \n        if (c < 128) {\n            return ASCII_SPACE[c];\n        }\n        \n        return isFixedWidthSpace(c)\n            || c == NBSPACE\n            || c == '\\u202F'\n            || c == '\\u3000'\n            || c == WORD_JOINER\n            || c == ZERO_WIDTH_NOBREAK_SPACE;\n    }\n\n    public static boolean isAlphabetic(int c) {\n        \n        if (c <= 0x7F) {\n            return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n        }\n        int generalCategory = Character.getType((char)c);\n        switch (generalCategory) {\n            case Character.UPPERCASE_LETTER:\n            case Character.LOWERCASE_LETTER:\n            case Character.TITLECASE_LETTER:\n            case Character.MODIFIER_LETTER:\n            case Character.OTHER_LETTER:\n            case Character.LETTER_NUMBER:\n                return true;\n            default:\n                return false;\n        }\n    }\n\n    public static boolean isExplicitBreak(int c) {\n        \n        if (c < 128 && (c == LINEFEED_CHAR || c == CARRIAGE_RETURN)) {\n            return true;\n        }\n        return (c == NEXT_LINE\n            || c == LINE_SEPARATOR\n            || c == PARAGRAPH_SEPARATOR);\n    }\n\n    public static String charToNCRef(int c) {\n        int nDigits = (c > 0xFFFF) ? 6 : 4;\n        char[] hex = new char[nDigits];\n        int value = c;\n        for (int i = nDigits - 1; i >= 0; i--) {\n            int d = value & 0xF;\n            hex[i] = (char) (d < 10 ? ('0' + d) : ('A' + (d - 10)));\n            value >>= 4;\n        }\n        return \"&#x\" + new String(hex) + \";\";\n    }\n\n    public static String toNCRefs(String s) {\n        if (s == null) {\n            return \"\";\n        }\n        \n        StringBuilder sb = new StringBuilder(s.length() * 5 / 4 + 16);\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if ((c >= 32) && (c < 127)) {\n                switch (c) {\n                    case '<':\n                        sb.append(\"&lt;\");\n                        break;\n                    case '>':\n                        sb.append(\"&gt;\");\n                        break;\n                    case '&':\n                        sb.append(\"&amp;\");\n                        break;\n                    default:\n                        sb.append(c);\n                        break;\n                }\n            } else {\n                sb.append(charToNCRef(c));\n            }\n        }\n        return sb.toString();\n    }\n\n    public static String padLeft(String s, int width, char pad) {\n        if (s == null) {\n            throw new IllegalArgumentException(\"Input string cannot be null\");\n        }\n        int nPad = width - s.length();\n        if (nPad <= 0) {\n            return s;\n        }\n        StringBuilder sb = new StringBuilder(width);\n        for (int i = 0; i < nPad; i++) {\n            sb.append(pad);\n        }\n        sb.append(s);\n        return sb.toString();\n    }\n\n    public static String format(int c) {\n        if (c < 1114112) {\n            return \"0x\" + padLeft(Integer.toString(c, 16), (c < 65536) ? 4 : 6, '0');\n        } else {\n            return \"!NOT A CHARACTER!\";\n        }\n    }\n\n    public static boolean isSameSequence(CharSequence cs1, CharSequence cs2) {\n        assert cs1 != null;\n        assert cs2 != null;\n        int n = cs1.length();\n        if (n != cs2.length()) {\n            return false;\n        }\n        for (int i = 0; i < n; i++) {\n            if (cs1.charAt(i) != cs2.charAt(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static boolean isBmpCodePoint(int codePoint) {\n        return codePoint >>> 16 == 0;\n    }\n\n    public static int incrementIfNonBMP(int codePoint) {\n        return isBmpCodePoint(codePoint) ? 0 : 1;\n    }\n\n    public static boolean isSurrogatePair(char ch) {\n        return Character.isHighSurrogate(ch) || Character.isLowSurrogate(ch);\n    }\n\n    public static boolean containsSurrogatePairAt(CharSequence chars, int index) {\n        char ch = chars.charAt(index);\n        if (Character.isHighSurrogate(ch)) {\n            if ((index + 1) > chars.length()) {\n                throw new IllegalArgumentException(\n                        \"ill-formed UTF-16 sequence, contains isolated high surrogate at end of sequence\");\n            }\n            if (Character.isLowSurrogate(chars.charAt(index + 1))) {\n                return true;\n            }\n            throw new IllegalArgumentException(\n                    \"ill-formed UTF-16 sequence, contains isolated high surrogate at index \" + index);\n        } else if (Character.isLowSurrogate(ch)) {\n            throw new IllegalArgumentException(\n                    \"ill-formed UTF-16 sequence, contains isolated low surrogate at index \" + index);\n        }\n        return false;\n    }\n\n    public static Iterable<Integer> codepointsIter(final CharSequence s) {\n        return codepointsIter(s, 0, s.length());\n    }\n\n    public static Iterable<Integer> codepointsIter(final CharSequence s, final int beginIndex, final int endIndex) {\n        if (beginIndex < 0) {\n            throw new StringIndexOutOfBoundsException(beginIndex);\n        }\n        if (endIndex > s.length()) {\n            throw new StringIndexOutOfBoundsException(endIndex);\n        }\n        int subLen = endIndex - beginIndex;\n        if (subLen < 0) {\n            throw new StringIndexOutOfBoundsException(subLen);\n        }\n        return new Iterable<Integer>() {\n            public Iterator<Integer> iterator() {\n                return new Iterator<Integer>() {\n                    int nextIndex = beginIndex;\n                    public boolean hasNext() {\n                        return nextIndex < endIndex;\n                    }\n                    public Integer next() {\n                        if (!hasNext()) {\n                            throw new NoSuchElementException();\n                        }\n                        int result = Character.codePointAt(s, nextIndex);\n                        nextIndex += Character.charCount(result);\n                        return result;\n                    }\n                    public void remove() {\n                        throw new UnsupportedOperationException();\n                    }\n                };\n            }\n        };\n    }\n}\n"
    ]
}