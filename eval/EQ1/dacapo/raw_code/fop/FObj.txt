{
    "0": [
        "\n\n\n\npackage org.apache.fop.fo;\n\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.NoSuchElementException;\nimport java.util.Set;\n\nimport org.xml.sax.Attributes;\nimport org.xml.sax.Locator;\n\nimport org.apache.xmlgraphics.util.QName;\n\nimport org.apache.fop.apps.FOPException;\nimport org.apache.fop.fo.extensions.ExtensionAttachment;\nimport org.apache.fop.fo.flow.ChangeBar;\nimport org.apache.fop.fo.flow.Marker;\nimport org.apache.fop.fo.pagination.PageSequence;\nimport org.apache.fop.fo.properties.Property;\nimport org.apache.fop.fo.properties.PropertyMaker;\n\n\npublic abstract class FObj extends FONode implements Constants {\n\n    \n    private static final PropertyMaker[] PROPERTY_LIST_TABLE\n                            = FOPropertyMapping.getGenericMappings();\n\n    \n    protected FONode firstChild;\n\n    \n    protected FONode lastChild;\n\n    \n    private List<ExtensionAttachment> extensionAttachments;\n\n    \n    private Map<QName, String> foreignAttributes;\n\n    \n    private boolean isOutOfLineFODescendant;\n\n    \n    private Map<String, Marker> markers;\n\n    private int bidiLevel = -1;\n\n    \n    private String id;\n    private String layer;\n    \n\n    private boolean forceKeepTogether;\n\n    \n    public FObj(FONode parent) {\n        super(parent);\n\n        \n        if (parent != null && parent instanceof FObj) {\n            if (((FObj) parent).getIsOutOfLineFODescendant()) {\n                isOutOfLineFODescendant = true;\n            } else {\n                int foID = getNameId();\n                if (foID == FO_FLOAT || foID == FO_FOOTNOTE\n                    || foID == FO_FOOTNOTE_BODY) {\n                        isOutOfLineFODescendant = true;\n                }\n            }\n        }\n    }\n\n    \n    public FONode clone(FONode parent, boolean removeChildren)\n        throws FOPException {\n        FObj fobj = (FObj) super.clone(parent, removeChildren);\n        if (removeChildren) {\n            fobj.firstChild = null;\n        }\n        return fobj;\n    }\n\n    \n    public static PropertyMaker getPropertyMakerFor(int propId) {\n        return PROPERTY_LIST_TABLE[propId];\n    }\n\n    \n    public void processNode(String elementName, Locator locator,\n                            Attributes attlist, PropertyList pList)\n                    throws FOPException {\n        setLocator(locator);\n        pList.addAttributesToList(attlist);\n        if (!inMarker() || \"marker\".equals(elementName)) {\n            bind(pList);\n        }\n        warnOnUnknownProperties(attlist, elementName, pList);\n    }\n\n    private void warnOnUnknownProperties(Attributes attlist, String objName, PropertyList propertyList)\n            throws FOPException {\n        Map<String, Property> unknowns = propertyList.getUnknownPropertyValues();\n        for (Entry<String, Property> entry : unknowns.entrySet()) {\n            FOValidationEventProducer producer = FOValidationEventProducer.Provider.get(getUserAgent()\n                    .getEventBroadcaster());\n            producer.warnOnInvalidPropertyValue(this, objName,\n                    getAttributeNameForValue(attlist, entry.getValue(), propertyList), entry.getKey(), null,\n                    getLocator());\n        }\n    }\n\n    private String getAttributeNameForValue(Attributes attList, Property value, PropertyList propertyList)\n            throws FOPException {\n        for (int i = 0; i < attList.getLength(); i++) {\n            String attributeName = attList.getQName(i);\n            String attributeValue = attList.getValue(i);\n            Property prop = propertyList.getPropertyForAttribute(attList, attributeName, attributeValue);\n            if (prop != null && prop.equals(value)) {\n                return attributeName;\n            }\n        }\n        return \"unknown\";\n    }\n\n    \n    protected PropertyList createPropertyList(PropertyList parent,\n                    FOEventHandler foEventHandler) throws FOPException {\n        return getBuilderContext().getPropertyListMaker().make(this, parent);\n    }\n\n    \n    public void bind(PropertyList pList) throws FOPException {\n        id = pList.get(PR_ID).getString();\n        layer = pList.get(PR_X_LAYER).getString();\n    }\n\n    \n    public void startOfNode() throws FOPException {\n        if (id != null) {\n            checkId(id);\n        }\n\n        PageSequence pageSequence = getRoot().getLastPageSequence();\n        if (pageSequence != null && pageSequence.hasChangeBars()) {\n            startOfNodeChangeBarList = pageSequence.getClonedChangeBarList();\n        }\n    }\n\n    \n    public void endOfNode() throws FOPException {\n\n        List<ChangeBar> endOfNodeChangeBarList = null;\n\n        PageSequence pageSequence = getRoot().getLastPageSequence();\n        if (pageSequence != null) {\n            endOfNodeChangeBarList = pageSequence.getClonedChangeBarList();\n        }\n\n        if (startOfNodeChangeBarList != null && endOfNodeChangeBarList != null) {\n\n            nodeChangeBarList = new LinkedList<ChangeBar>(endOfNodeChangeBarList);\n            nodeChangeBarList.retainAll(startOfNodeChangeBarList);\n\n            if (nodeChangeBarList.isEmpty()) {\n                nodeChangeBarList = null;\n            }\n\n            startOfNodeChangeBarList = null;\n        }\n\n        super.endOfNode();\n    }\n\n    \n    private void checkId(String id) throws ValidationException {\n        if (!inMarker() && !id.equals(\"\")) {\n            Set<String> idrefs = getBuilderContext().getIDReferences();\n            if (!idrefs.contains(id)) {\n                idrefs.add(id);\n            } else {\n                getFOValidationEventProducer().idNotUnique(this, getName(), id, true, locator);\n            }\n        }\n    }\n\n    \n    boolean getIsOutOfLineFODescendant() {\n        return isOutOfLineFODescendant;\n    }\n\n    \n    protected void addChildNode(FONode child) throws FOPException {\n        if (child.getNameId() == FO_MARKER) {\n            addMarker((Marker) child);\n        } else {\n            ExtensionAttachment attachment = child.getExtensionAttachment();\n            if (attachment != null) {\n                \n                addExtensionAttachment(attachment);\n            } else {\n                if (firstChild == null) {\n                    firstChild = child;\n                    lastChild = child;\n                } else {\n                    if (lastChild == null) {\n                        FONode prevChild = firstChild;\n                        while (prevChild.siblings != null\n                                && prevChild.siblings[1] != null) {\n                            prevChild = prevChild.siblings[1];\n                        }\n                        FONode.attachSiblings(prevChild, child);\n                    } else {\n                        FONode.attachSiblings(lastChild, child);\n                        lastChild = child;\n                    }\n                }\n            }\n        }\n    }\n\n    \n    protected static void addChildTo(FONode child, FONode parent)\n                            throws FOPException {\n        parent.addChildNode(child);\n    }\n\n    \n    public void removeChild(FONode child) {\n        FONode nextChild = null;\n        if (child.siblings != null) {\n            nextChild = child.siblings[1];\n        }\n        if (child == firstChild) {\n            firstChild = nextChild;\n            if (firstChild != null) {\n                firstChild.siblings[0] = null;\n            }\n        } else if (child.siblings != null) {\n            FONode prevChild = child.siblings[0];\n            prevChild.siblings[1] = nextChild;\n            if (nextChild != null) {\n                nextChild.siblings[0] = prevChild;\n            }\n        }\n        if (child == lastChild) {\n            if (child.siblings != null) {\n                lastChild = child.siblings[0];\n            } else {\n                lastChild = null;\n            }\n        }\n    }\n\n    \n    public FObj findNearestAncestorFObj() {\n        FONode par = parent;\n        while (par != null && !(par instanceof FObj)) {\n            par = par.parent;\n        }\n        return (FObj) par;\n    }\n\n    \n    public boolean generatesReferenceAreas() {\n        return false;\n    }\n\n    \n    public FONodeIterator getChildNodes() {\n        if (hasChildren()) {\n            return new FObjIterator(this);\n        }\n        return null;\n    }\n\n    \n    public boolean hasChildren() {\n        return this.firstChild != null;\n    }\n\n    \n    public FONodeIterator getChildNodes(FONode childNode) {\n        FONodeIterator it = getChildNodes();\n        if (it != null) {\n            if (firstChild == childNode) {\n                return it;\n            } else {\n                while (it.hasNext()\n                        && it.next().siblings[1] != childNode) {\n                    \n                }\n                if (it.hasNext()) {\n                    return it;\n                } else {\n                    return null;\n                }\n            }\n        }\n        return null;\n    }\n\n    \n    void notifyChildRemoval(FONode node) {\n        \n    }\n\n    \n    protected void addMarker(Marker marker) {\n        String mcname = marker.getMarkerClassName();\n        if (firstChild != null) {\n            \n            for (FONodeIterator iter = getChildNodes(); iter.hasNext();) {\n                FONode node = iter.next();\n                if (node instanceof FObj\n                        || (node instanceof FOText\n                                && ((FOText) node).willCreateArea())) {\n                    getFOValidationEventProducer().markerNotInitialChild(this, getName(),\n                            mcname, locator);\n                    return;\n                } else if (node instanceof FOText) {\n                    iter.remove();\n                    notifyChildRemoval(node);\n                }\n            }\n        }\n        if (markers == null) {\n            markers = new HashMap<String, Marker>();\n        }\n        if (!markers.containsKey(mcname)) {\n            markers.put(mcname, marker);\n        } else {\n            getFOValidationEventProducer().markerNotUniqueForSameParent(this, getName(),\n                    mcname, locator);\n        }\n    }\n\n    \n    public boolean hasMarkers() {\n        return markers != null && !markers.isEmpty();\n    }\n\n    \n    public Map<String, Marker> getMarkers() {\n        return markers;\n    }\n\n    \n    protected String getContextInfoAlt() {\n        StringBuilder sb = new StringBuilder();\n        if (getLocalName() != null) {\n            sb.append(getName());\n            sb.append(\", \");\n        }\n        if (hasId()) {\n            sb.append(\"id=\").append(getId());\n            return sb.toString();\n        }\n        String s = gatherContextInfo();\n        if (s != null) {\n            sb.append(\"\\\"\");\n            if (s.length() < 32) {\n                sb.append(s);\n            } else {\n                sb.append(s.substring(0, 32));\n                sb.append(\"...\");\n            }\n            sb.append(\"\\\"\");\n            return sb.toString();\n        } else {\n            return null;\n        }\n    }\n\n    \n    protected String gatherContextInfo() {\n        if (getLocator() != null) {\n            return super.gatherContextInfo();\n        } else {\n            FONodeIterator iter = getChildNodes();\n            if (iter == null) {\n                return null;\n            }\n            StringBuilder sb = new StringBuilder();\n            while (iter.hasNext()) {\n                FONode node = iter.next();\n                String s = node.gatherContextInfo();\n                if (s != null) {\n                    if (sb.length() > 0) {\n                        sb.append(\", \");\n                    }\n                    sb.append(s);\n                }\n            }\n            return (sb.length() > 0 ? sb.toString() : null);\n        }\n    }\n\n    \n    protected boolean isBlockItem(String nsURI, String lName) {\n        return (FO_URI.equals(nsURI)\n                && (\"block\".equals(lName)\n                        || \"table\".equals(lName)\n                        || \"table-and-caption\".equals(lName)\n                        || \"block-container\".equals(lName)\n                        || \"list-block\".equals(lName)\n                        || \"float\".equals(lName)\n                        || isNeutralItem(nsURI, lName)));\n    }\n\n    \n    protected boolean isInlineItem(String nsURI, String lName) {\n        return (FO_URI.equals(nsURI)\n                && (\"bidi-override\".equals(lName)\n                        || \"change-bar-begin\".equals(lName)\n                        || \"change-bar-end\".equals(lName)\n                        || \"character\".equals(lName)\n                        || \"external-graphic\".equals(lName)\n                        || \"instream-foreign-object\".equals(lName)\n                        || \"inline\".equals(lName)\n                        || \"inline-container\".equals(lName)\n                        || \"leader\".equals(lName)\n                        || \"page-number\".equals(lName)\n                        || \"page-number-citation\".equals(lName)\n                        || \"page-number-citation-last\".equals(lName)\n                        || \"basic-link\".equals(lName)\n                        || (\"multi-toggle\".equals(lName)\n                                && (getNameId() == FO_MULTI_CASE\n                                        || findAncestor(FO_MULTI_CASE) > 0))\n                        || (\"footnote\".equals(lName)\n                                && !isOutOfLineFODescendant)\n                        || isNeutralItem(nsURI, lName)));\n    }\n\n    \n    protected boolean isBlockOrInlineItem(String nsURI, String lName) {\n        return (isBlockItem(nsURI, lName) || isInlineItem(nsURI, lName));\n    }\n\n    \n    protected boolean isNeutralItem(String nsURI, String lName) {\n        return (FO_URI.equals(nsURI)\n                && (\"multi-switch\".equals(lName)\n                        || \"multi-properties\".equals(lName)\n                        || \"wrapper\".equals(lName)\n                        || (!isOutOfLineFODescendant && \"float\".equals(lName))\n                        || \"retrieve-marker\".equals(lName)\n                        || \"retrieve-table-marker\".equals(lName)));\n    }\n\n    \n    protected int findAncestor(int ancestorID) {\n        int found = 1;\n        FONode temp = getParent();\n        while (temp != null) {\n            if (temp.getNameId() == ancestorID) {\n                return found;\n            }\n            found += 1;\n            temp = temp.getParent();\n        }\n        return -1;\n    }\n\n    \n    public void clearChildNodes() {\n        this.firstChild = null;\n    }\n\n    \n    public String getId() {\n        return id;\n    }\n\n    \n    public boolean hasId() {\n        return (id != null && id.length() > 0);\n    }\n\n    \n    public String getLayer() {\n        return layer;\n    }\n\n    \n    public boolean hasLayer() {\n        return (layer != null && layer.length() > 0);\n    }\n\n    \n    public String getNamespaceURI() {\n        return FOElementMapping.URI;\n    }\n\n    \n    public String getNormalNamespacePrefix() {\n        return \"fo\";\n    }\n\n    \n    public boolean isBidiRangeBlockItem() {\n        String ns = getNamespaceURI();\n        String ln = getLocalName();\n        return !isNeutralItem(ns, ln) && isBlockItem(ns, ln);\n    }\n\n    \n    public void setBidiLevel(int bidiLevel) {\n\n        assert bidiLevel >= 0;\n\n        if ((this.bidiLevel < 0) || (bidiLevel < this.bidiLevel)) {\n            this.bidiLevel = bidiLevel;\n            if ((parent != null) && !isBidiPropagationBoundary()) {\n                FObj foParent = (FObj) parent;\n                int parentBidiLevel = foParent.getBidiLevel();\n                if ((parentBidiLevel < 0) || (bidiLevel < parentBidiLevel)) {\n                    foParent.setBidiLevel(bidiLevel);\n                }\n            }\n        }\n    }\n\n    \n    public int getBidiLevel() {\n        return bidiLevel;\n    }\n\n    \n    public int getBidiLevelRecursive() {\n        for (FONode fn = this; fn != null; fn = fn.getParent()) {\n            if (fn instanceof FObj) {\n                int level = ((FObj) fn).getBidiLevel();\n                if (level >= 0) {\n                    return level;\n                }\n            }\n            if (isBidiInheritanceBoundary()) {\n                break;\n            }\n        }\n        return -1;\n    }\n\n    protected boolean isBidiBoundary(boolean propagate) {\n        return false;\n    }\n\n    private boolean isBidiInheritanceBoundary() {\n        return isBidiBoundary(false);\n    }\n\n    private boolean isBidiPropagationBoundary() {\n        return isBidiBoundary(true);\n    }\n\n    \n    void addExtensionAttachment(ExtensionAttachment attachment) {\n        if (attachment == null) {\n            throw new NullPointerException(\n                    \"Parameter attachment must not be null\");\n        }\n        if (extensionAttachments == null) {\n            extensionAttachments = new java.util.ArrayList<ExtensionAttachment>();\n        }\n        if (log.isDebugEnabled()) {\n            log.debug(\"ExtensionAttachment of category \"\n                    + attachment.getCategory() + \" added to \"\n                    + getName() + \": \" + attachment);\n        }\n        extensionAttachments.add(attachment);\n    }\n\n    \n    public List<ExtensionAttachment> getExtensionAttachments() {\n        if (extensionAttachments == null) {\n            return Collections.EMPTY_LIST;\n        } else {\n            return extensionAttachments;\n        }\n    }\n\n    \n    public boolean hasExtensionAttachments() {\n        return extensionAttachments != null;\n    }\n\n    \n    public void addForeignAttribute(QName attributeName, String value) {\n        \n        if (attributeName == null) {\n            throw new NullPointerException(\"Parameter attributeName must not be null\");\n        }\n        if (foreignAttributes == null) {\n            foreignAttributes = new java.util.HashMap<QName, String>();\n        }\n        foreignAttributes.put(attributeName, value);\n    }\n\n    \n    public Map getForeignAttributes() {\n        if (foreignAttributes == null) {\n            return Collections.EMPTY_MAP;\n        } else {\n            return foreignAttributes;\n        }\n    }\n\n    \n    public String toString() {\n        return (super.toString() + \"[@id=\" + this.id + \"]\");\n    }\n\n    public boolean isForceKeepTogether() {\n        return forceKeepTogether;\n    }\n\n    public void setForceKeepTogether(boolean b) {\n        forceKeepTogether = b;\n    }\n\n    \n    public static class FObjIterator implements FONodeIterator {\n\n        private static final int F_NONE_ALLOWED = 0;\n        private static final int F_SET_ALLOWED = 1;\n        private static final int F_REMOVE_ALLOWED = 2;\n\n        private FONode currentNode;\n        private final FObj parentNode;\n        private int currentIndex;\n        private int flags = F_NONE_ALLOWED;\n\n        FObjIterator(FObj parent) {\n            this.parentNode = parent;\n            this.currentNode = parent.firstChild;\n            this.currentIndex = 0;\n            this.flags = F_NONE_ALLOWED;\n        }\n\n        \n        public FObj parent() {\n            return parentNode;\n        }\n\n        \n        public FONode next() {\n            if (currentNode != null) {\n                if (currentIndex != 0) {\n                    if (currentNode.siblings != null\n                        && currentNode.siblings[1] != null) {\n                        currentNode = currentNode.siblings[1];\n                    } else {\n                        throw new NoSuchElementException();\n                    }\n                }\n                currentIndex++;\n                flags |= (F_SET_ALLOWED | F_REMOVE_ALLOWED);\n                return currentNode;\n            } else {\n                throw new NoSuchElementException();\n            }\n        }\n\n        \n        public FONode previous() {\n            if (currentNode.siblings != null\n                    && currentNode.siblings[0] != null) {\n                currentIndex--;\n                currentNode = currentNode.siblings[0];\n                flags |= (F_SET_ALLOWED | F_REMOVE_ALLOWED);\n                return currentNode;\n            } else {\n                throw new NoSuchElementException();\n            }\n        }\n\n        \n        public void set(FONode newNode) {\n            if ((flags & F_SET_ALLOWED) == F_SET_ALLOWED) {\n                if (currentNode == parentNode.firstChild) {\n                    parentNode.firstChild = newNode;\n                } else {\n                    FONode.attachSiblings(currentNode.siblings[0], newNode);\n                }\n                if (currentNode.siblings != null\n                        && currentNode.siblings[1] != null) {\n                    FONode.attachSiblings(newNode, currentNode.siblings[1]);\n                }\n                if (currentNode == parentNode.lastChild) {\n                    parentNode.lastChild = newNode;\n                }\n            } else {\n                throw new IllegalStateException();\n            }\n        }\n\n        \n        public void add(FONode newNode) {\n            if (currentIndex == -1) {\n                if (currentNode != null) {\n                    FONode.attachSiblings(newNode, currentNode);\n                }\n                parentNode.firstChild = newNode;\n                currentIndex = 0;\n                currentNode = newNode;\n                if (parentNode.lastChild == null) {\n                    parentNode.lastChild = newNode;\n                }\n            } else {\n                if (currentNode.siblings != null\n                        && currentNode.siblings[1] != null) {\n                    FONode.attachSiblings(newNode, currentNode.siblings[1]);\n                }\n                FONode.attachSiblings(currentNode, newNode);\n                if (currentNode == parentNode.lastChild) {\n                    parentNode.lastChild = newNode;\n                }\n            }\n            flags &= F_NONE_ALLOWED;\n        }\n\n        \n        public boolean hasNext() {\n            return (currentNode != null)\n                && ((currentIndex == 0)\n                        || (currentNode.siblings != null\n                            && currentNode.siblings[1] != null));\n        }\n\n        \n        public boolean hasPrevious() {\n            return (currentIndex != 0)\n                || (currentNode.siblings != null\n                    && currentNode.siblings[0] != null);\n        }\n\n        \n        public int nextIndex() {\n            return currentIndex + 1;\n        }\n\n        \n        public int previousIndex() {\n            return currentIndex - 1;\n        }\n\n        \n        public void remove() {\n            if ((flags & F_REMOVE_ALLOWED) == F_REMOVE_ALLOWED) {\n                parentNode.removeChild(currentNode);\n                if (currentIndex == 0) {\n                    \n                    currentNode = parentNode.firstChild;\n                } else if (currentNode.siblings != null\n                        && currentNode.siblings[0] != null) {\n                    currentNode = currentNode.siblings[0];\n                    currentIndex--;\n                } else {\n                    currentNode = null;\n                }\n                flags &= F_NONE_ALLOWED;\n            } else {\n                throw new IllegalStateException();\n            }\n        }\n\n        \n        public FONode last() {\n            while (currentNode != null\n                    && currentNode.siblings != null\n                    && currentNode.siblings[1] != null) {\n                currentNode = currentNode.siblings[1];\n                currentIndex++;\n            }\n            return currentNode;\n        }\n\n        \n        public FONode first() {\n            currentNode = parentNode.firstChild;\n            currentIndex = 0;\n            return currentNode;\n        }\n    }\n}\n"
    ],
    "1": [
        "package org.apache.fop.fo;\n\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.NoSuchElementException;\nimport java.util.Set;\nimport java.util.ArrayList;\n\nimport org.xml.sax.Attributes;\nimport org.xml.sax.Locator;\n\nimport org.apache.xmlgraphics.util.QName;\n\nimport org.apache.fop.apps.FOPException;\nimport org.apache.fop.fo.extensions.ExtensionAttachment;\nimport org.apache.fop.fo.flow.ChangeBar;\nimport org.apache.fop.fo.flow.Marker;\nimport org.apache.fop.fo.pagination.PageSequence;\nimport org.apache.fop.fo.properties.Property;\nimport org.apache.fop.fo.properties.PropertyMaker;\n\npublic abstract class FObj extends FONode implements Constants {\n\n    private static final PropertyMaker[] PROPERTY_LIST_TABLE = FOPropertyMapping.getGenericMappings();\n\n    protected FONode firstChild;\n    protected FONode lastChild;\n    private List<ExtensionAttachment> extensionAttachments;\n    private Map<QName, String> foreignAttributes;\n    private boolean isOutOfLineFODescendant;\n    private Map<String, Marker> markers;\n    private int bidiLevel = -1;\n    private String id;\n    private String layer;\n    private boolean forceKeepTogether;\n\n    \n    private Map<Property, String> attributeValueToNameCache;\n\n    public FObj(FONode parent) {\n        super(parent);\n        if (parent != null && parent instanceof FObj) {\n            if (((FObj) parent).getIsOutOfLineFODescendant()) {\n                isOutOfLineFODescendant = true;\n            } else {\n                int foID = getNameId();\n                if (foID == FO_FLOAT || foID == FO_FOOTNOTE || foID == FO_FOOTNOTE_BODY) {\n                    isOutOfLineFODescendant = true;\n                }\n            }\n        }\n    }\n\n    public FONode clone(FONode parent, boolean removeChildren) throws FOPException {\n        FObj fobj = (FObj) super.clone(parent, removeChildren);\n        if (removeChildren) {\n            fobj.firstChild = null;\n            fobj.lastChild = null;\n        }\n        return fobj;\n    }\n\n    public static PropertyMaker getPropertyMakerFor(int propId) {\n        return PROPERTY_LIST_TABLE[propId];\n    }\n\n    public void processNode(String elementName, Locator locator, Attributes attlist, PropertyList pList)\n            throws FOPException {\n        setLocator(locator);\n        pList.addAttributesToList(attlist);\n        if (!inMarker() || \"marker\".equals(elementName)) {\n            bind(pList);\n        }\n        warnOnUnknownProperties(attlist, elementName, pList);\n    }\n\n    private void warnOnUnknownProperties(Attributes attlist, String objName, PropertyList propertyList)\n            throws FOPException {\n        Map<String, Property> unknowns = propertyList.getUnknownPropertyValues();\n        \n        Map<Property, String> propToAttrName = buildPropertyToAttributeNameMap(attlist, propertyList);\n        for (Entry<String, Property> entry : unknowns.entrySet()) {\n            FOValidationEventProducer producer = FOValidationEventProducer.Provider.get(getUserAgent().getEventBroadcaster());\n            String attrName = propToAttrName.get(entry.getValue());\n            if (attrName == null) attrName = \"unknown\";\n            producer.warnOnInvalidPropertyValue(this, objName,\n                    attrName, entry.getKey(), null, getLocator());\n        }\n    }\n\n    \n    private Map<Property, String> buildPropertyToAttributeNameMap(Attributes attList, PropertyList propertyList)\n            throws FOPException {\n        Map<Property, String> propToAttrName = new HashMap<>();\n        int len = attList.getLength();\n        for (int i = 0; i < len; i++) {\n            String attributeName = attList.getQName(i);\n            String attributeValue = attList.getValue(i);\n            Property prop = propertyList.getPropertyForAttribute(attList, attributeName, attributeValue);\n            if (prop != null && !propToAttrName.containsKey(prop)) {\n                propToAttrName.put(prop, attributeName);\n            }\n        }\n        return propToAttrName;\n    }\n\n    \n    private String getAttributeNameForValue(Attributes attList, Property value, PropertyList propertyList)\n            throws FOPException {\n        int len = attList.getLength();\n        for (int i = 0; i < len; i++) {\n            String attributeName = attList.getQName(i);\n            String attributeValue = attList.getValue(i);\n            Property prop = propertyList.getPropertyForAttribute(attList, attributeName, attributeValue);\n            if (prop != null && prop.equals(value)) {\n                return attributeName;\n            }\n        }\n        return \"unknown\";\n    }\n\n    protected PropertyList createPropertyList(PropertyList parent, FOEventHandler foEventHandler) throws FOPException {\n        return getBuilderContext().getPropertyListMaker().make(this, parent);\n    }\n\n    public void bind(PropertyList pList) throws FOPException {\n        id = pList.get(PR_ID).getString();\n        layer = pList.get(PR_X_LAYER).getString();\n    }\n\n    public void startOfNode() throws FOPException {\n        if (id != null) {\n            checkId(id);\n        }\n        PageSequence pageSequence = getRoot().getLastPageSequence();\n        if (pageSequence != null && pageSequence.hasChangeBars()) {\n            startOfNodeChangeBarList = pageSequence.getClonedChangeBarList();\n        }\n    }\n\n    public void endOfNode() throws FOPException {\n        List<ChangeBar> endOfNodeChangeBarList = null;\n        PageSequence pageSequence = getRoot().getLastPageSequence();\n        if (pageSequence != null) {\n            endOfNodeChangeBarList = pageSequence.getClonedChangeBarList();\n        }\n        if (startOfNodeChangeBarList != null && endOfNodeChangeBarList != null) {\n            nodeChangeBarList = new LinkedList<>(endOfNodeChangeBarList);\n            nodeChangeBarList.retainAll(startOfNodeChangeBarList);\n            if (nodeChangeBarList.isEmpty()) {\n                nodeChangeBarList = null;\n            }\n            startOfNodeChangeBarList = null;\n        }\n        super.endOfNode();\n    }\n\n    private void checkId(String id) throws ValidationException {\n        if (!inMarker() && !id.equals(\"\")) {\n            Set<String> idrefs = getBuilderContext().getIDReferences();\n            if (!idrefs.contains(id)) {\n                idrefs.add(id);\n            } else {\n                getFOValidationEventProducer().idNotUnique(this, getName(), id, true, locator);\n            }\n        }\n    }\n\n    boolean getIsOutOfLineFODescendant() {\n        return isOutOfLineFODescendant;\n    }\n\n    protected void addChildNode(FONode child) throws FOPException {\n        if (child.getNameId() == FO_MARKER) {\n            addMarker((Marker) child);\n        } else {\n            ExtensionAttachment attachment = child.getExtensionAttachment();\n            if (attachment != null) {\n                addExtensionAttachment(attachment);\n            } else {\n                if (firstChild == null) {\n                    firstChild = child;\n                    lastChild = child;\n                } else {\n                    FONode.attachSiblings(lastChild, child);\n                    lastChild = child;\n                }\n            }\n        }\n    }\n\n    protected static void addChildTo(FONode child, FONode parent) throws FOPException {\n        parent.addChildNode(child);\n    }\n\n    public void removeChild(FONode child) {\n        FONode nextChild = null;\n        if (child.siblings != null) {\n            nextChild = child.siblings[1];\n        }\n        if (child == firstChild) {\n            firstChild = nextChild;\n            if (firstChild != null) {\n                firstChild.siblings[0] = null;\n            }\n        } else if (child.siblings != null) {\n            FONode prevChild = child.siblings[0];\n            prevChild.siblings[1] = nextChild;\n            if (nextChild != null) {\n                nextChild.siblings[0] = prevChild;\n            }\n        }\n        if (child == lastChild) {\n            if (child.siblings != null) {\n                lastChild = child.siblings[0];\n            } else {\n                lastChild = null;\n            }\n        }\n    }\n\n    public FObj findNearestAncestorFObj() {\n        FONode par = parent;\n        while (par != null && !(par instanceof FObj)) {\n            par = par.parent;\n        }\n        return (FObj) par;\n    }\n\n    public boolean generatesReferenceAreas() {\n        return false;\n    }\n\n    public FONodeIterator getChildNodes() {\n        if (hasChildren()) {\n            return new FObjIterator(this);\n        }\n        return null;\n    }\n\n    public boolean hasChildren() {\n        return this.firstChild != null;\n    }\n\n    public FONodeIterator getChildNodes(FONode childNode) {\n        FONodeIterator it = getChildNodes();\n        if (it != null) {\n            if (firstChild == childNode) {\n                return it;\n            } else {\n                while (it.hasNext()) {\n                    FONode next = it.next();\n                    if (next.siblings != null && next.siblings[1] == childNode) {\n                        return it;\n                    }\n                }\n                return null;\n            }\n        }\n        return null;\n    }\n\n    void notifyChildRemoval(FONode node) {\n        \n    }\n\n    protected void addMarker(Marker marker) {\n        String mcname = marker.getMarkerClassName();\n        if (firstChild != null) {\n            FONodeIterator iter = getChildNodes();\n            while (iter.hasNext()) {\n                FONode node = iter.next();\n                if (node instanceof FObj || (node instanceof FOText && ((FOText) node).willCreateArea())) {\n                    getFOValidationEventProducer().markerNotInitialChild(this, getName(), mcname, locator);\n                    return;\n                } else if (node instanceof FOText) {\n                    iter.remove();\n                    notifyChildRemoval(node);\n                }\n            }\n        }\n        if (markers == null) {\n            markers = new HashMap<>();\n        }\n        if (!markers.containsKey(mcname)) {\n            markers.put(mcname, marker);\n        } else {\n            getFOValidationEventProducer().markerNotUniqueForSameParent(this, getName(), mcname, locator);\n        }\n    }\n\n    public boolean hasMarkers() {\n        return markers != null && !markers.isEmpty();\n    }\n\n    public Map<String, Marker> getMarkers() {\n        return markers;\n    }\n\n    protected String getContextInfoAlt() {\n        StringBuilder sb = new StringBuilder();\n        if (getLocalName() != null) {\n            sb.append(getName());\n            sb.append(\", \");\n        }\n        if (hasId()) {\n            sb.append(\"id=\").append(getId());\n            return sb.toString();\n        }\n        String s = gatherContextInfo();\n        if (s != null) {\n            sb.append('\"');\n            if (s.length() < 32) {\n                sb.append(s);\n            } else {\n                sb.append(s.substring(0, 32));\n                sb.append(\"...\");\n            }\n            sb.append('\"');\n            return sb.toString();\n        } else {\n            return null;\n        }\n    }\n\n    protected String gatherContextInfo() {\n        if (getLocator() != null) {\n            return super.gatherContextInfo();\n        } else {\n            FONodeIterator iter = getChildNodes();\n            if (iter == null) {\n                return null;\n            }\n            StringBuilder sb = new StringBuilder();\n            while (iter.hasNext()) {\n                FONode node = iter.next();\n                String s = node.gatherContextInfo();\n                if (s != null) {\n                    if (sb.length() > 0) {\n                        sb.append(\", \");\n                    }\n                    sb.append(s);\n                }\n            }\n            return (sb.length() > 0 ? sb.toString() : null);\n        }\n    }\n\n    protected boolean isBlockItem(String nsURI, String lName) {\n        return (FO_URI.equals(nsURI)\n                && (\"block\".equals(lName)\n                        || \"table\".equals(lName)\n                        || \"table-and-caption\".equals(lName)\n                        || \"block-container\".equals(lName)\n                        || \"list-block\".equals(lName)\n                        || \"float\".equals(lName)\n                        || isNeutralItem(nsURI, lName)));\n    }\n\n    protected boolean isInlineItem(String nsURI, String lName) {\n        return (FO_URI.equals(nsURI)\n                && (\"bidi-override\".equals(lName)\n                        || \"change-bar-begin\".equals(lName)\n                        || \"change-bar-end\".equals(lName)\n                        || \"character\".equals(lName)\n                        || \"external-graphic\".equals(lName)\n                        || \"instream-foreign-object\".equals(lName)\n                        || \"inline\".equals(lName)\n                        || \"inline-container\".equals(lName)\n                        || \"leader\".equals(lName)\n                        || \"page-number\".equals(lName)\n                        || \"page-number-citation\".equals(lName)\n                        || \"page-number-citation-last\".equals(lName)\n                        || \"basic-link\".equals(lName)\n                        || (\"multi-toggle\".equals(lName)\n                                && (getNameId() == FO_MULTI_CASE || findAncestor(FO_MULTI_CASE) > 0))\n                        || (\"footnote\".equals(lName) && !isOutOfLineFODescendant)\n                        || isNeutralItem(nsURI, lName)));\n    }\n\n    protected boolean isBlockOrInlineItem(String nsURI, String lName) {\n        return (isBlockItem(nsURI, lName) || isInlineItem(nsURI, lName));\n    }\n\n    protected boolean isNeutralItem(String nsURI, String lName) {\n        return (FO_URI.equals(nsURI)\n                && (\"multi-switch\".equals(lName)\n                        || \"multi-properties\".equals(lName)\n                        || \"wrapper\".equals(lName)\n                        || (!isOutOfLineFODescendant && \"float\".equals(lName))\n                        || \"retrieve-marker\".equals(lName)\n                        || \"retrieve-table-marker\".equals(lName)));\n    }\n\n    protected int findAncestor(int ancestorID) {\n        int found = 1;\n        FONode temp = getParent();\n        while (temp != null) {\n            if (temp.getNameId() == ancestorID) {\n                return found;\n            }\n            found += 1;\n            temp = temp.getParent();\n        }\n        return -1;\n    }\n\n    public void clearChildNodes() {\n        this.firstChild = null;\n        this.lastChild = null;\n    }\n\n    public String getId() {\n        return id;\n    }\n\n    public boolean hasId() {\n        return (id != null && id.length() > 0);\n    }\n\n    public String getLayer() {\n        return layer;\n    }\n\n    public boolean hasLayer() {\n        return (layer != null && layer.length() > 0);\n    }\n\n    public String getNamespaceURI() {\n        return FOElementMapping.URI;\n    }\n\n    public String getNormalNamespacePrefix() {\n        return \"fo\";\n    }\n\n    public boolean isBidiRangeBlockItem() {\n        String ns = getNamespaceURI();\n        String ln = getLocalName();\n        return !isNeutralItem(ns, ln) && isBlockItem(ns, ln);\n    }\n\n    public void setBidiLevel(int bidiLevel) {\n        assert bidiLevel >= 0;\n        if ((this.bidiLevel < 0) || (bidiLevel < this.bidiLevel)) {\n            this.bidiLevel = bidiLevel;\n            if ((parent != null) && !isBidiPropagationBoundary()) {\n                FObj foParent = (FObj) parent;\n                int parentBidiLevel = foParent.getBidiLevel();\n                if ((parentBidiLevel < 0) || (bidiLevel < parentBidiLevel)) {\n                    foParent.setBidiLevel(bidiLevel);\n                }\n            }\n        }\n    }\n\n    public int getBidiLevel() {\n        return bidiLevel;\n    }\n\n    public int getBidiLevelRecursive() {\n        for (FONode fn = this; fn != null; fn = fn.getParent()) {\n            if (fn instanceof FObj) {\n                int level = ((FObj) fn).getBidiLevel();\n                if (level >= 0) {\n                    return level;\n                }\n            }\n            if (isBidiInheritanceBoundary()) {\n                break;\n            }\n        }\n        return -1;\n    }\n\n    protected boolean isBidiBoundary(boolean propagate) {\n        return false;\n    }\n\n    private boolean isBidiInheritanceBoundary() {\n        return isBidiBoundary(false);\n    }\n\n    private boolean isBidiPropagationBoundary() {\n        return isBidiBoundary(true);\n    }\n\n    void addExtensionAttachment(ExtensionAttachment attachment) {\n        if (attachment == null) {\n            throw new NullPointerException(\"Parameter attachment must not be null\");\n        }\n        if (extensionAttachments == null) {\n            extensionAttachments = new ArrayList<>();\n        }\n        if (log.isDebugEnabled()) {\n            log.debug(\"ExtensionAttachment of category \"\n                    + attachment.getCategory() + \" added to \"\n                    + getName() + \": \" + attachment);\n        }\n        extensionAttachments.add(attachment);\n    }\n\n    public List<ExtensionAttachment> getExtensionAttachments() {\n        if (extensionAttachments == null) {\n            return Collections.emptyList();\n        } else {\n            return extensionAttachments;\n        }\n    }\n\n    public boolean hasExtensionAttachments() {\n        return extensionAttachments != null;\n    }\n\n    public void addForeignAttribute(QName attributeName, String value) {\n        if (attributeName == null) {\n            throw new NullPointerException(\"Parameter attributeName must not be null\");\n        }\n        if (foreignAttributes == null) {\n            foreignAttributes = new HashMap<>();\n        }\n        foreignAttributes.put(attributeName, value);\n    }\n\n    public Map<QName, String> getForeignAttributes() {\n        if (foreignAttributes == null) {\n            return Collections.emptyMap();\n        } else {\n            return foreignAttributes;\n        }\n    }\n\n    public String toString() {\n        return super.toString() + \"[@id=\" + this.id + \"]\";\n    }\n\n    public boolean isForceKeepTogether() {\n        return forceKeepTogether;\n    }\n\n    public void setForceKeepTogether(boolean b) {\n        forceKeepTogether = b;\n    }\n\n    public static class FObjIterator implements FONodeIterator {\n        private static final int F_NONE_ALLOWED = 0;\n        private static final int F_SET_ALLOWED = 1;\n        private static final int F_REMOVE_ALLOWED = 2;\n        private FONode currentNode;\n        private final FObj parentNode;\n        private int currentIndex;\n        private int flags = F_NONE_ALLOWED;\n\n        FObjIterator(FObj parent) {\n            this.parentNode = parent;\n            this.currentNode = parent.firstChild;\n            this.currentIndex = 0;\n            this.flags = F_NONE_ALLOWED;\n        }\n\n        public FObj parent() {\n            return parentNode;\n        }\n\n        public FONode next() {\n            if (currentNode != null) {\n                if (currentIndex != 0) {\n                    if (currentNode.siblings != null && currentNode.siblings[1] != null) {\n                        currentNode = currentNode.siblings[1];\n                    } else {\n                        throw new NoSuchElementException();\n                    }\n                }\n                currentIndex++;\n                flags |= (F_SET_ALLOWED | F_REMOVE_ALLOWED);\n                return currentNode;\n            } else {\n                throw new NoSuchElementException();\n            }\n        }\n\n        public FONode previous() {\n            if (currentNode.siblings != null && currentNode.siblings[0] != null) {\n                currentIndex--;\n                currentNode = currentNode.siblings[0];\n                flags |= (F_SET_ALLOWED | F_REMOVE_ALLOWED);\n                return currentNode;\n            } else {\n                throw new NoSuchElementException();\n            }\n        }\n\n        public void set(FONode newNode) {\n            if ((flags & F_SET_ALLOWED) == F_SET_ALLOWED) {\n                if (currentNode == parentNode.firstChild) {\n                    parentNode.firstChild = newNode;\n                } else {\n                    FONode.attachSiblings(currentNode.siblings[0], newNode);\n                }\n                if (currentNode.siblings != null && currentNode.siblings[1] != null) {\n                    FONode.attachSiblings(newNode, currentNode.siblings[1]);\n                }\n                if (currentNode == parentNode.lastChild) {\n                    parentNode.lastChild = newNode;\n                }\n            } else {\n                throw new IllegalStateException();\n            }\n        }\n\n        public void add(FONode newNode) {\n            if (currentIndex == -1) {\n                if (currentNode != null) {\n                    FONode.attachSiblings(newNode, currentNode);\n                }\n                parentNode.firstChild = newNode;\n                currentIndex = 0;\n                currentNode = newNode;\n                if (parentNode.lastChild == null) {\n                    parentNode.lastChild = newNode;\n                }\n            } else {\n                if (currentNode.siblings != null && currentNode.siblings[1] != null) {\n                    FONode.attachSiblings(newNode, currentNode.siblings[1]);\n                }\n                FONode.attachSiblings(currentNode, newNode);\n                if (currentNode == parentNode.lastChild) {\n                    parentNode.lastChild = newNode;\n                }\n            }\n            flags &= F_NONE_ALLOWED;\n        }\n\n        public boolean hasNext() {\n            return (currentNode != null)\n                    && ((currentIndex == 0)\n                            || (currentNode.siblings != null && currentNode.siblings[1] != null));\n        }\n\n        public boolean hasPrevious() {\n            return (currentIndex != 0)\n                    || (currentNode.siblings != null && currentNode.siblings[0] != null);\n        }\n\n        public int nextIndex() {\n            return currentIndex + 1;\n        }\n\n        public int previousIndex() {\n            return currentIndex - 1;\n        }\n\n        public void remove() {\n            if ((flags & F_REMOVE_ALLOWED) == F_REMOVE_ALLOWED) {\n                parentNode.removeChild(currentNode);\n                if (currentIndex == 0) {\n                    currentNode = parentNode.firstChild;\n                } else if (currentNode.siblings != null && currentNode.siblings[0] != null) {\n                    currentNode = currentNode.siblings[0];\n                    currentIndex--;\n                } else {\n                    currentNode = null;\n                }\n                flags &= F_NONE_ALLOWED;\n            } else {\n                throw new IllegalStateException();\n            }\n        }\n\n        public FONode last() {\n            while (currentNode != null && currentNode.siblings != null && currentNode.siblings[1] != null) {\n                currentNode = currentNode.siblings[1];\n                currentIndex++;\n            }\n            return currentNode;\n        }\n\n        public FONode first() {\n            currentNode = parentNode.firstChild;\n            currentIndex = 0;\n            return currentNode;\n        }\n    }\n}\n"
    ],
    "2": [
        "package org.apache.fop.fo;\n\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.NoSuchElementException;\nimport java.util.Set;\nimport java.util.ArrayList;\n\nimport org.xml.sax.Attributes;\nimport org.xml.sax.Locator;\n\nimport org.apache.xmlgraphics.util.QName;\n\nimport org.apache.fop.apps.FOPException;\nimport org.apache.fop.fo.extensions.ExtensionAttachment;\nimport org.apache.fop.fo.flow.ChangeBar;\nimport org.apache.fop.fo.flow.Marker;\nimport org.apache.fop.fo.pagination.PageSequence;\nimport org.apache.fop.fo.properties.Property;\nimport org.apache.fop.fo.properties.PropertyMaker;\n\npublic abstract class FObj extends FONode implements Constants {\n\n    private static final PropertyMaker[] PROPERTY_LIST_TABLE = FOPropertyMapping.getGenericMappings();\n\n    protected FONode firstChild;\n    protected FONode lastChild;\n    private List<ExtensionAttachment> extensionAttachments;\n    private Map<QName, String> foreignAttributes;\n    private boolean isOutOfLineFODescendant;\n    private Map<String, Marker> markers;\n    private int bidiLevel = -1;\n    private String id;\n    private String layer;\n    private boolean forceKeepTogether;\n\n    \n    private Attributes cachedAttributes = null;\n    private PropertyList cachedPropertyList = null;\n    private Map<Property, String> attributeValueToNameCache = null;\n\n    public FObj(FONode parent) {\n        super(parent);\n        if (parent != null && parent instanceof FObj) {\n            if (((FObj) parent).getIsOutOfLineFODescendant()) {\n                isOutOfLineFODescendant = true;\n            } else {\n                int foID = getNameId();\n                if (foID == FO_FLOAT || foID == FO_FOOTNOTE || foID == FO_FOOTNOTE_BODY) {\n                    isOutOfLineFODescendant = true;\n                }\n            }\n        }\n    }\n\n    public FONode clone(FONode parent, boolean removeChildren) throws FOPException {\n        FObj fobj = (FObj) super.clone(parent, removeChildren);\n        if (removeChildren) {\n            fobj.firstChild = null;\n            fobj.lastChild = null;\n        }\n        fobj.attributeValueToNameCache = null;\n        fobj.cachedAttributes = null;\n        fobj.cachedPropertyList = null;\n        return fobj;\n    }\n\n    public static PropertyMaker getPropertyMakerFor(int propId) {\n        return PROPERTY_LIST_TABLE[propId];\n    }\n\n    public void processNode(String elementName, Locator locator, Attributes attlist, PropertyList pList) throws FOPException {\n        setLocator(locator);\n        pList.addAttributesToList(attlist);\n        if (!inMarker() || \"marker\".equals(elementName)) {\n            bind(pList);\n        }\n        \n        attributeValueToNameCache = null;\n        cachedAttributes = null;\n        cachedPropertyList = null;\n        warnOnUnknownProperties(attlist, elementName, pList);\n    }\n\n    private void warnOnUnknownProperties(Attributes attlist, String objName, PropertyList propertyList) throws FOPException {\n        Map<String, Property> unknowns = propertyList.getUnknownPropertyValues();\n        \n        if (attributeValueToNameCache == null || cachedAttributes != attlist || cachedPropertyList != propertyList) {\n            attributeValueToNameCache = buildPropertyToAttributeNameMap(attlist, propertyList);\n            cachedAttributes = attlist;\n            cachedPropertyList = propertyList;\n        }\n        for (Entry<String, Property> entry : unknowns.entrySet()) {\n            FOValidationEventProducer producer = FOValidationEventProducer.Provider.get(getUserAgent().getEventBroadcaster());\n            String attrName = attributeValueToNameCache.get(entry.getValue());\n            if (attrName == null) attrName = \"unknown\";\n            producer.warnOnInvalidPropertyValue(this, objName,\n                    attrName, entry.getKey(), null, getLocator());\n        }\n    }\n\n    private Map<Property, String> buildPropertyToAttributeNameMap(Attributes attList, PropertyList propertyList) throws FOPException {\n        Map<Property, String> propToAttrName = new HashMap<>();\n        int len = attList.getLength();\n        for (int i = 0; i < len; i++) {\n            String attributeName = attList.getQName(i);\n            String attributeValue = attList.getValue(i);\n            Property prop = propertyList.getPropertyForAttribute(attList, attributeName, attributeValue);\n            if (prop != null && !propToAttrName.containsKey(prop)) {\n                propToAttrName.put(prop, attributeName);\n            }\n        }\n        return propToAttrName;\n    }\n\n    private String getAttributeNameForValue(Attributes attList, Property value, PropertyList propertyList) throws FOPException {\n        int len = attList.getLength();\n        for (int i = 0; i < len; i++) {\n            String attributeName = attList.getQName(i);\n            String attributeValue = attList.getValue(i);\n            Property prop = propertyList.getPropertyForAttribute(attList, attributeName, attributeValue);\n            if (prop != null && prop.equals(value)) {\n                return attributeName;\n            }\n        }\n        return \"unknown\";\n    }\n\n    protected PropertyList createPropertyList(PropertyList parent, FOEventHandler foEventHandler) throws FOPException {\n        return getBuilderContext().getPropertyListMaker().make(this, parent);\n    }\n\n    public void bind(PropertyList pList) throws FOPException {\n        id = pList.get(PR_ID).getString();\n        layer = pList.get(PR_X_LAYER).getString();\n    }\n\n    public void startOfNode() throws FOPException {\n        if (id != null) {\n            checkId(id);\n        }\n        PageSequence pageSequence = getRoot().getLastPageSequence();\n        if (pageSequence != null && pageSequence.hasChangeBars()) {\n            startOfNodeChangeBarList = pageSequence.getClonedChangeBarList();\n        }\n    }\n\n    public void endOfNode() throws FOPException {\n        List<ChangeBar> endOfNodeChangeBarList = null;\n        PageSequence pageSequence = getRoot().getLastPageSequence();\n        if (pageSequence != null) {\n            endOfNodeChangeBarList = pageSequence.getClonedChangeBarList();\n        }\n        if (startOfNodeChangeBarList != null && endOfNodeChangeBarList != null) {\n            nodeChangeBarList = new LinkedList<>(endOfNodeChangeBarList);\n            nodeChangeBarList.retainAll(startOfNodeChangeBarList);\n            if (nodeChangeBarList.isEmpty()) {\n                nodeChangeBarList = null;\n            }\n            startOfNodeChangeBarList = null;\n        }\n        super.endOfNode();\n    }\n\n    private void checkId(String id) throws ValidationException {\n        if (!inMarker() && !id.equals(\"\")) {\n            Set<String> idrefs = getBuilderContext().getIDReferences();\n            if (!idrefs.contains(id)) {\n                idrefs.add(id);\n            } else {\n                getFOValidationEventProducer().idNotUnique(this, getName(), id, true, locator);\n            }\n        }\n    }\n\n    boolean getIsOutOfLineFODescendant() {\n        return isOutOfLineFODescendant;\n    }\n\n    protected void addChildNode(FONode child) throws FOPException {\n        if (child.getNameId() == FO_MARKER) {\n            addMarker((Marker) child);\n        } else {\n            ExtensionAttachment attachment = child.getExtensionAttachment();\n            if (attachment != null) {\n                addExtensionAttachment(attachment);\n            } else {\n                if (firstChild == null) {\n                    firstChild = child;\n                    lastChild = child;\n                } else {\n                    FONode.attachSiblings(lastChild, child);\n                    lastChild = child;\n                }\n            }\n        }\n    }\n\n    protected static void addChildTo(FONode child, FONode parent) throws FOPException {\n        parent.addChildNode(child);\n    }\n\n    public void removeChild(FONode child) {\n        FONode nextChild = null;\n        if (child.siblings != null) {\n            nextChild = child.siblings[1];\n        }\n        if (child == firstChild) {\n            firstChild = nextChild;\n            if (firstChild != null) {\n                firstChild.siblings[0] = null;\n            }\n        } else if (child.siblings != null) {\n            FONode prevChild = child.siblings[0];\n            prevChild.siblings[1] = nextChild;\n            if (nextChild != null) {\n                nextChild.siblings[0] = prevChild;\n            }\n        }\n        if (child == lastChild) {\n            if (child.siblings != null) {\n                lastChild = child.siblings[0];\n            } else {\n                lastChild = null;\n            }\n        }\n    }\n\n    public FObj findNearestAncestorFObj() {\n        FONode par = parent;\n        while (par != null && !(par instanceof FObj)) {\n            par = par.parent;\n        }\n        return (FObj) par;\n    }\n\n    public boolean generatesReferenceAreas() {\n        return false;\n    }\n\n    public FONodeIterator getChildNodes() {\n        if (hasChildren()) {\n            return new FObjIterator(this);\n        }\n        return null;\n    }\n\n    public boolean hasChildren() {\n        return this.firstChild != null;\n    }\n\n    public FONodeIterator getChildNodes(FONode childNode) {\n        FONodeIterator it = getChildNodes();\n        if (it != null) {\n            if (firstChild == childNode) {\n                return it;\n            } else {\n                while (it.hasNext()) {\n                    FONode next = it.next();\n                    if (next.siblings != null && next.siblings[1] == childNode) {\n                        return it;\n                    }\n                }\n                return null;\n            }\n        }\n        return null;\n    }\n\n    void notifyChildRemoval(FONode node) {\n        \n    }\n\n    protected void addMarker(Marker marker) {\n        String mcname = marker.getMarkerClassName();\n        if (firstChild != null) {\n            FONodeIterator iter = getChildNodes();\n            while (iter.hasNext()) {\n                FONode node = iter.next();\n                if (node instanceof FObj || (node instanceof FOText && ((FOText) node).willCreateArea())) {\n                    getFOValidationEventProducer().markerNotInitialChild(this, getName(), mcname, locator);\n                    return;\n                } else if (node instanceof FOText) {\n                    iter.remove();\n                    notifyChildRemoval(node);\n                }\n            }\n        }\n        if (markers == null) {\n            markers = new HashMap<>();\n        }\n        if (!markers.containsKey(mcname)) {\n            markers.put(mcname, marker);\n        } else {\n            getFOValidationEventProducer().markerNotUniqueForSameParent(this, getName(), mcname, locator);\n        }\n    }\n\n    public boolean hasMarkers() {\n        return markers != null && !markers.isEmpty();\n    }\n\n    public Map<String, Marker> getMarkers() {\n        return markers;\n    }\n\n    protected String getContextInfoAlt() {\n        StringBuilder sb = new StringBuilder();\n        if (getLocalName() != null) {\n            sb.append(getName());\n            sb.append(\", \");\n        }\n        if (hasId()) {\n            sb.append(\"id=\").append(getId());\n            return sb.toString();\n        }\n        String s = gatherContextInfo();\n        if (s != null) {\n            sb.append('\"');\n            if (s.length() < 32) {\n                sb.append(s);\n            } else {\n                sb.append(s.substring(0, 32));\n                sb.append(\"...\");\n            }\n            sb.append('\"');\n            return sb.toString();\n        } else {\n            return null;\n        }\n    }\n\n    protected String gatherContextInfo() {\n        if (getLocator() != null) {\n            return super.gatherContextInfo();\n        } else {\n            FONodeIterator iter = getChildNodes();\n            if (iter == null) {\n                return null;\n            }\n            StringBuilder sb = new StringBuilder();\n            while (iter.hasNext()) {\n                FONode node = iter.next();\n                String s = node.gatherContextInfo();\n                if (s != null) {\n                    if (sb.length() > 0) {\n                        sb.append(\", \");\n                    }\n                    sb.append(s);\n                }\n            }\n            return (sb.length() > 0 ? sb.toString() : null);\n        }\n    }\n\n    protected boolean isBlockItem(String nsURI, String lName) {\n        return (FO_URI.equals(nsURI)\n                && (\"block\".equals(lName)\n                        || \"table\".equals(lName)\n                        || \"table-and-caption\".equals(lName)\n                        || \"block-container\".equals(lName)\n                        || \"list-block\".equals(lName)\n                        || \"float\".equals(lName)\n                        || isNeutralItem(nsURI, lName)));\n    }\n\n    protected boolean isInlineItem(String nsURI, String lName) {\n        return (FO_URI.equals(nsURI)\n                && (\"bidi-override\".equals(lName)\n                        || \"change-bar-begin\".equals(lName)\n                        || \"change-bar-end\".equals(lName)\n                        || \"character\".equals(lName)\n                        || \"external-graphic\".equals(lName)\n                        || \"instream-foreign-object\".equals(lName)\n                        || \"inline\".equals(lName)\n                        || \"inline-container\".equals(lName)\n                        || \"leader\".equals(lName)\n                        || \"page-number\".equals(lName)\n                        || \"page-number-citation\".equals(lName)\n                        || \"page-number-citation-last\".equals(lName)\n                        || \"basic-link\".equals(lName)\n                        || (\"multi-toggle\".equals(lName)\n                                && (getNameId() == FO_MULTI_CASE || findAncestor(FO_MULTI_CASE) > 0))\n                        || (\"footnote\".equals(lName) && !isOutOfLineFODescendant)\n                        || isNeutralItem(nsURI, lName)));\n    }\n\n    protected boolean isBlockOrInlineItem(String nsURI, String lName) {\n        return (isBlockItem(nsURI, lName) || isInlineItem(nsURI, lName));\n    }\n\n    protected boolean isNeutralItem(String nsURI, String lName) {\n        return (FO_URI.equals(nsURI)\n                && (\"multi-switch\".equals(lName)\n                        || \"multi-properties\".equals(lName)\n                        || \"wrapper\".equals(lName)\n                        || (!isOutOfLineFODescendant && \"float\".equals(lName))\n                        || \"retrieve-marker\".equals(lName)\n                        || \"retrieve-table-marker\".equals(lName)));\n    }\n\n    protected int findAncestor(int ancestorID) {\n        int found = 1;\n        FONode temp = getParent();\n        while (temp != null) {\n            if (temp.getNameId() == ancestorID) {\n                return found;\n            }\n            found += 1;\n            temp = temp.getParent();\n        }\n        return -1;\n    }\n\n    public void clearChildNodes() {\n        this.firstChild = null;\n        this.lastChild = null;\n    }\n\n    public String getId() {\n        return id;\n    }\n\n    public boolean hasId() {\n        return (id != null && id.length() > 0);\n    }\n\n    public String getLayer() {\n        return layer;\n    }\n\n    public boolean hasLayer() {\n        return (layer != null && layer.length() > 0);\n    }\n\n    public String getNamespaceURI() {\n        return FOElementMapping.URI;\n    }\n\n    public String getNormalNamespacePrefix() {\n        return \"fo\";\n    }\n\n    public boolean isBidiRangeBlockItem() {\n        String ns = getNamespaceURI();\n        String ln = getLocalName();\n        return !isNeutralItem(ns, ln) && isBlockItem(ns, ln);\n    }\n\n    public void setBidiLevel(int bidiLevel) {\n        assert bidiLevel >= 0;\n        if ((this.bidiLevel < 0) || (bidiLevel < this.bidiLevel)) {\n            this.bidiLevel = bidiLevel;\n            if ((parent != null) && !isBidiPropagationBoundary()) {\n                FObj foParent = (FObj) parent;\n                int parentBidiLevel = foParent.getBidiLevel();\n                if ((parentBidiLevel < 0) || (bidiLevel < parentBidiLevel)) {\n                    foParent.setBidiLevel(bidiLevel);\n                }\n            }\n        }\n    }\n\n    public int getBidiLevel() {\n        return bidiLevel;\n    }\n\n    public int getBidiLevelRecursive() {\n        for (FONode fn = this; fn != null; fn = fn.getParent()) {\n            if (fn instanceof FObj) {\n                int level = ((FObj) fn).getBidiLevel();\n                if (level >= 0) {\n                    return level;\n                }\n            }\n            if (isBidiInheritanceBoundary()) {\n                break;\n            }\n        }\n        return -1;\n    }\n\n    protected boolean isBidiBoundary(boolean propagate) {\n        return false;\n    }\n\n    private boolean isBidiInheritanceBoundary() {\n        return isBidiBoundary(false);\n    }\n\n    private boolean isBidiPropagationBoundary() {\n        return isBidiBoundary(true);\n    }\n\n    void addExtensionAttachment(ExtensionAttachment attachment) {\n        if (attachment == null) {\n            throw new NullPointerException(\"Parameter attachment must not be null\");\n        }\n        if (extensionAttachments == null) {\n            extensionAttachments = new ArrayList<>();\n        }\n        if (log.isDebugEnabled()) {\n            log.debug(\"ExtensionAttachment of category \"\n                    + attachment.getCategory() + \" added to \"\n                    + getName() + \": \" + attachment);\n        }\n        extensionAttachments.add(attachment);\n    }\n\n    public List<ExtensionAttachment> getExtensionAttachments() {\n        if (extensionAttachments == null) {\n            return Collections.emptyList();\n        } else {\n            return extensionAttachments;\n        }\n    }\n\n    public boolean hasExtensionAttachments() {\n        return extensionAttachments != null;\n    }\n\n    public void addForeignAttribute(QName attributeName, String value) {\n        if (attributeName == null) {\n            throw new NullPointerException(\"Parameter attributeName must not be null\");\n        }\n        if (foreignAttributes == null) {\n            foreignAttributes = new HashMap<>();\n        }\n        foreignAttributes.put(attributeName, value);\n    }\n\n    public Map<QName, String> getForeignAttributes() {\n        if (foreignAttributes == null) {\n            return Collections.emptyMap();\n        } else {\n            return foreignAttributes;\n        }\n    }\n\n    public String toString() {\n        return super.toString() + \"[@id=\" + this.id + \"]\";\n    }\n\n    public boolean isForceKeepTogether() {\n        return forceKeepTogether;\n    }\n\n    public void setForceKeepTogether(boolean b) {\n        forceKeepTogether = b;\n    }\n\n    \n    public static class FObjIterator implements FONodeIterator {\n        private static final int F_NONE_ALLOWED = 0;\n        private static final int F_SET_ALLOWED = 1;\n        private static final int F_REMOVE_ALLOWED = 2;\n        private FONode currentNode;\n        private final FObj parentNode;\n        private int currentIndex;\n        private int flags = F_NONE_ALLOWED;\n\n        FObjIterator(FObj parent) {\n            this.parentNode = parent;\n            this.currentNode = parent.firstChild;\n            this.currentIndex = 0;\n            this.flags = F_NONE_ALLOWED;\n        }\n\n        public FObj parent() {\n            return parentNode;\n        }\n\n        public FONode next() {\n            if (currentNode != null) {\n                if (currentIndex != 0) {\n                    if (currentNode.siblings != null && currentNode.siblings[1] != null) {\n                        currentNode = currentNode.siblings[1];\n                    } else {\n                        throw new NoSuchElementException();\n                    }\n                }\n                currentIndex++;\n                flags |= (F_SET_ALLOWED | F_REMOVE_ALLOWED);\n                return currentNode;\n            } else {\n                throw new NoSuchElementException();\n            }\n        }\n\n        public FONode previous() {\n            if (currentNode.siblings != null && currentNode.siblings[0] != null) {\n                currentIndex--;\n                currentNode = currentNode.siblings[0];\n                flags |= (F_SET_ALLOWED | F_REMOVE_ALLOWED);\n                return currentNode;\n            } else {\n                throw new NoSuchElementException();\n            }\n        }\n\n        public void set(FONode newNode) {\n            if ((flags & F_SET_ALLOWED) == F_SET_ALLOWED) {\n                if (currentNode == parentNode.firstChild) {\n                    parentNode.firstChild = newNode;\n                } else {\n                    FONode.attachSiblings(currentNode.siblings[0], newNode);\n                }\n                if (currentNode.siblings != null && currentNode.siblings[1] != null) {\n                    FONode.attachSiblings(newNode, currentNode.siblings[1]);\n                }\n                if (currentNode == parentNode.lastChild) {\n                    parentNode.lastChild = newNode;\n                }\n            } else {\n                throw new IllegalStateException();\n            }\n        }\n\n        public void add(FONode newNode) {\n            if (currentIndex == -1) {\n                if (currentNode != null) {\n                    FONode.attachSiblings(newNode, currentNode);\n                }\n                parentNode.firstChild = newNode;\n                currentIndex = 0;\n                currentNode = newNode;\n                if (parentNode.lastChild == null) {\n                    parentNode.lastChild = newNode;\n                }\n            } else {\n                if (currentNode.siblings != null && currentNode.siblings[1] != null) {\n                    FONode.attachSiblings(newNode, currentNode.siblings[1]);\n                }\n                FONode.attachSiblings(currentNode, newNode);\n                if (currentNode == parentNode.lastChild) {\n                    parentNode.lastChild = newNode;\n                }\n            }\n            flags &= F_NONE_ALLOWED;\n        }\n\n        public boolean hasNext() {\n            return (currentNode != null)\n                    && ((currentIndex == 0)\n                            || (currentNode.siblings != null && currentNode.siblings[1] != null));\n        }\n\n        public boolean hasPrevious() {\n            return (currentIndex != 0)\n                    || (currentNode.siblings != null && currentNode.siblings[0] != null);\n        }\n\n        public int nextIndex() {\n            return currentIndex + 1;\n        }\n\n        public int previousIndex() {\n            return currentIndex - 1;\n        }\n\n        public void remove() {\n            if ((flags & F_REMOVE_ALLOWED) == F_REMOVE_ALLOWED) {\n                parentNode.removeChild(currentNode);\n                if (currentIndex == 0) {\n                    currentNode = parentNode.firstChild;\n                } else if (currentNode.siblings != null && currentNode.siblings[0] != null) {\n                    currentNode = currentNode.siblings[0];\n                    currentIndex--;\n                } else {\n                    currentNode = null;\n                }\n                flags &= F_NONE_ALLOWED;\n            } else {\n                throw new IllegalStateException();\n            }\n        }\n\n        public FONode last() {\n            while (currentNode != null && currentNode.siblings != null && currentNode.siblings[1] != null) {\n                currentNode = currentNode.siblings[1];\n                currentIndex++;\n            }\n            return currentNode;\n        }\n\n        public FONode first() {\n            currentNode = parentNode.firstChild;\n            currentIndex = 0;\n            return currentNode;\n        }\n    }\n}\n"
    ]
}