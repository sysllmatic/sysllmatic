{
    "0": [
        "\n\n\n\npackage org.apache.fop.layoutmgr.table;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n\nimport org.apache.fop.area.Area;\nimport org.apache.fop.area.Block;\nimport org.apache.fop.datatypes.LengthBase;\nimport org.apache.fop.fo.Constants;\nimport org.apache.fop.fo.FONode;\nimport org.apache.fop.fo.FObj;\nimport org.apache.fop.fo.flow.AbstractGraphics;\nimport org.apache.fop.fo.flow.Marker;\nimport org.apache.fop.fo.flow.Markers;\nimport org.apache.fop.fo.flow.RetrieveTableMarker;\nimport org.apache.fop.fo.flow.table.Table;\nimport org.apache.fop.fo.flow.table.TableColumn;\nimport org.apache.fop.fo.properties.CommonBorderPaddingBackground;\nimport org.apache.fop.fo.properties.KeepProperty;\nimport org.apache.fop.layoutmgr.BlockLevelEventProducer;\nimport org.apache.fop.layoutmgr.BreakElement;\nimport org.apache.fop.layoutmgr.BreakOpportunity;\nimport org.apache.fop.layoutmgr.KnuthElement;\nimport org.apache.fop.layoutmgr.KnuthGlue;\nimport org.apache.fop.layoutmgr.LayoutContext;\nimport org.apache.fop.layoutmgr.LeafPosition;\nimport org.apache.fop.layoutmgr.ListElement;\nimport org.apache.fop.layoutmgr.Position;\nimport org.apache.fop.layoutmgr.PositionIterator;\nimport org.apache.fop.layoutmgr.SpacedBorderedPaddedBlockLayoutManager;\nimport org.apache.fop.layoutmgr.TraitSetter;\nimport org.apache.fop.traits.MinOptMax;\nimport org.apache.fop.traits.SpaceVal;\nimport org.apache.fop.util.BreakUtil;\n\n\npublic class TableLayoutManager extends SpacedBorderedPaddedBlockLayoutManager\n        implements BreakOpportunity {\n\n    \n    private static Log log = LogFactory.getLog(TableLayoutManager.class);\n\n    private TableContentLayoutManager contentLM;\n    private ColumnSetup columns;\n\n    private Block curBlockArea;\n\n    private double tableUnit;\n    private double oldTableUnit;\n    private boolean autoLayout = true;\n\n    private int halfBorderSeparationBPD;\n    private int halfBorderSeparationIPD;\n\n    \n    private List columnBackgroundAreas;\n\n    private Position auxiliaryPosition;\n\n    \n    private List<TableCellLayoutManager> savedTCLMs;\n    private boolean areAllTCLMsSaved;\n\n    private Markers tableMarkers;\n    private Markers tableFragmentMarkers;\n\n    private boolean hasRetrieveTableMarker;\n\n    private boolean repeatedHeader;\n\n    private List<List<KnuthElement>> headerFootnotes = Collections.emptyList();\n\n    private List<List<KnuthElement>> footerFootnotes = Collections.emptyList();\n\n    \n    private static final class ColumnBackgroundInfo {\n        private TableColumn column;\n        private Block backgroundArea;\n        private int xShift;\n\n        private ColumnBackgroundInfo(TableColumn column, Block backgroundArea, int xShift) {\n            this.column = column;\n            this.backgroundArea = backgroundArea;\n            this.xShift = xShift;\n        }\n    }\n\n    \n    public TableLayoutManager(Table node) {\n        super(node);\n        this.columns = new ColumnSetup(node);\n    }\n\n\n    @Override\n    protected CommonBorderPaddingBackground getCommonBorderPaddingBackground() {\n        return getTable().getCommonBorderPaddingBackground();\n    }\n\n\n    \n    public Table getTable() {\n        return (Table)this.fobj;\n    }\n\n    \n    public ColumnSetup getColumns() {\n        return this.columns;\n    }\n\n    \n    public void initialize() {\n        foSpaceBefore = new SpaceVal(\n                getTable().getCommonMarginBlock().spaceBefore, this).getSpace();\n        foSpaceAfter = new SpaceVal(\n                getTable().getCommonMarginBlock().spaceAfter, this).getSpace();\n        startIndent = getTable().getCommonMarginBlock().startIndent.getValue(this);\n        endIndent = getTable().getCommonMarginBlock().endIndent.getValue(this);\n\n        if (getTable().isSeparateBorderModel()) {\n            this.halfBorderSeparationBPD = getTable().getBorderSeparation().getBPD().getLength()\n                    .getValue(this) / 2;\n            this.halfBorderSeparationIPD = getTable().getBorderSeparation().getIPD().getLength()\n                    .getValue(this) / 2;\n        } else {\n            this.halfBorderSeparationBPD = 0;\n            this.halfBorderSeparationIPD = 0;\n        }\n\n        if (!getTable().isAutoLayout()\n                && getTable().getInlineProgressionDimension().getOptimum(this).getEnum()\n                    != EN_AUTO) {\n            autoLayout = false;\n        }\n    }\n\n    private void resetSpaces() {\n        this.discardBorderBefore = false;\n        this.discardBorderAfter = false;\n        this.discardPaddingBefore = false;\n        this.discardPaddingAfter = false;\n        this.effSpaceBefore = null;\n        this.effSpaceAfter = null;\n    }\n\n    \n    public int getHalfBorderSeparationBPD() {\n        return halfBorderSeparationBPD;\n    }\n\n    \n    public int getHalfBorderSeparationIPD() {\n        return halfBorderSeparationIPD;\n    }\n\n    \n    public List getNextKnuthElements(LayoutContext context, int alignment) {\n\n        List returnList = new LinkedList();\n\n        \n        referenceIPD = context.getRefIPD();\n        if (getTable().getInlineProgressionDimension().getOptimum(this).getEnum() != EN_AUTO) {\n            int contentIPD = getTable().getInlineProgressionDimension().getOptimum(this)\n                    .getLength().getValue(this);\n            updateContentAreaIPDwithOverconstrainedAdjust(contentIPD);\n        } else {\n            if (!getTable().isAutoLayout()) {\n                BlockLevelEventProducer eventProducer = BlockLevelEventProducer.Provider.get(\n                        getTable().getUserAgent().getEventBroadcaster());\n                eventProducer.tableFixedAutoWidthNotSupported(this, getTable().getLocator());\n            }\n            updateContentAreaIPDwithOverconstrainedAdjust();\n        }\n        int sumOfColumns = columns.getSumOfColumnWidths(this);\n        if (!autoLayout && sumOfColumns > getContentAreaIPD()) {\n            log.debug(FONode.decorateWithContextInfo(\n                    \"The sum of all column widths is larger than the specified table width.\",\n                    getTable()));\n            updateContentAreaIPDwithOverconstrainedAdjust(sumOfColumns);\n        }\n        int availableIPD = referenceIPD - getIPIndents();\n        if (getContentAreaIPD() > availableIPD) {\n            BlockLevelEventProducer eventProducer = BlockLevelEventProducer.Provider.get(\n                    getTable().getUserAgent().getEventBroadcaster());\n            eventProducer.objectTooWide(this, getTable().getName(),\n                    getContentAreaIPD(), context.getRefIPD(),\n                    getTable().getLocator());\n        }\n\n        \n        if (tableUnit == 0.0) {\n            tableUnit = columns.computeTableUnit(this);\n            if (oldTableUnit > tableUnit && supportResize(fobj)) {\n                tableUnit = oldTableUnit;\n            }\n        }\n\n        if (!firstVisibleMarkServed) {\n            addKnuthElementsForSpaceBefore(returnList, alignment);\n        }\n\n        if (getTable().isSeparateBorderModel()) {\n            addKnuthElementsForBorderPaddingBefore(returnList, !firstVisibleMarkServed);\n            firstVisibleMarkServed = true;\n            \n            \n            \n            addPendingMarks(context);\n        }\n\n\n        \n        List contentKnuthElements;\n        contentLM = new TableContentLayoutManager(this);\n        LayoutContext childLC = LayoutContext.newInstance();\n        \n        childLC.setRefIPD(context.getRefIPD());\n        childLC.copyPendingMarksFrom(context);\n\n        contentKnuthElements = contentLM.getNextKnuthElements(childLC, alignment);\n        \n        for (Object contentKnuthElement : contentKnuthElements) {\n            ListElement el = (ListElement) contentKnuthElement;\n            notifyPos(el.getPosition());\n        }\n        log.debug(contentKnuthElements);\n        wrapPositionElements(contentKnuthElements, returnList);\n\n        context.updateKeepWithPreviousPending(getKeepWithPrevious());\n        context.updateKeepWithPreviousPending(childLC.getKeepWithPreviousPending());\n\n        context.updateKeepWithNextPending(getKeepWithNext());\n        context.updateKeepWithNextPending(childLC.getKeepWithNextPending());\n\n        if (getTable().isSeparateBorderModel()) {\n            addKnuthElementsForBorderPaddingAfter(returnList, true);\n        }\n        addKnuthElementsForSpaceAfter(returnList, alignment);\n\n        if (!context.suppressBreakBefore()) {\n            \n            int breakBefore = BreakUtil.compareBreakClasses(getTable().getBreakBefore(),\n                    childLC.getBreakBefore());\n            if (breakBefore != Constants.EN_AUTO) {\n                returnList.add(0, new BreakElement(new LeafPosition(getParent(), 0), 0,\n                        -KnuthElement.INFINITE, breakBefore, context));\n            }\n        }\n\n        \n        int breakAfter = BreakUtil.compareBreakClasses(getTable().getBreakAfter(),\n                childLC.getBreakAfter());\n        if (breakAfter != Constants.EN_AUTO) {\n            returnList.add(new BreakElement(new LeafPosition(getParent(), 0),\n                    0, -KnuthElement.INFINITE, breakAfter, context));\n        }\n\n        setFinished(true);\n        resetSpaces();\n        return returnList;\n    }\n\n    private boolean supportResize(FONode node) {\n        if (node instanceof AbstractGraphics) {\n            return false;\n        }\n        FONode.FONodeIterator iterator = node.getChildNodes();\n        while (iterator != null && iterator.hasNext()) {\n            FONode x = iterator.next();\n            if (!supportResize(x)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    public Position getAuxiliaryPosition() {\n        \n        if (auxiliaryPosition == null) {\n            auxiliaryPosition = new LeafPosition(this, 0);\n        }\n        return auxiliaryPosition;\n    }\n\n    \n    void registerColumnBackgroundArea(TableColumn column, Block backgroundArea, int xShift) {\n        addBackgroundArea(backgroundArea);\n        if (columnBackgroundAreas == null) {\n            columnBackgroundAreas = new ArrayList();\n        }\n        columnBackgroundAreas.add(new ColumnBackgroundInfo(column, backgroundArea, xShift));\n    }\n\n    \n    public void addAreas(PositionIterator parentIter,\n                         LayoutContext layoutContext) {\n        getParentArea(null);\n        addId();\n\n        \n        if (layoutContext.getSpaceBefore() != 0) {\n            addBlockSpacing(0.0, MinOptMax.getInstance(layoutContext.getSpaceBefore()));\n        }\n\n        int startXOffset = getTable().getCommonMarginBlock().startIndent.getValue(this);\n\n        \n\n        \n        int tableHeight = 0;\n        \n        LayoutContext lc = LayoutContext.offspringOf(layoutContext);\n\n\n        lc.setRefIPD(getContentAreaIPD());\n        contentLM.setStartXOffset(startXOffset);\n        contentLM.addAreas(parentIter, lc);\n\n        if (fobj.getUserAgent().isTableBorderOverpaint()) {\n            new OverPaintBorders(curBlockArea);\n        }\n\n        tableHeight += contentLM.getUsedBPD();\n\n        curBlockArea.setBPD(tableHeight);\n\n        if (columnBackgroundAreas != null) {\n            for (Object columnBackgroundArea : columnBackgroundAreas) {\n                ColumnBackgroundInfo b = (ColumnBackgroundInfo) columnBackgroundArea;\n                TraitSetter.addBackground(b.backgroundArea,\n                        b.column.getCommonBorderPaddingBackground(), this,\n                        b.xShift, -b.backgroundArea.getYOffset(),\n                        b.column.getColumnWidth().getValue(this), tableHeight);\n            }\n            columnBackgroundAreas.clear();\n        }\n\n        if (getTable().isSeparateBorderModel()) {\n            TraitSetter.addBorders(curBlockArea,\n                    getTable().getCommonBorderPaddingBackground(),\n                    discardBorderBefore, discardBorderAfter, false, false, this);\n            TraitSetter.addPadding(curBlockArea,\n                    getTable().getCommonBorderPaddingBackground(),\n                    discardPaddingBefore, discardPaddingAfter, false, false, this);\n        }\n        TraitSetter.addBackground(curBlockArea,\n                getTable().getCommonBorderPaddingBackground(),\n                this);\n        TraitSetter.addMargins(curBlockArea,\n                getTable().getCommonBorderPaddingBackground(),\n                startIndent, endIndent,\n                this);\n        TraitSetter.addBreaks(curBlockArea,\n                getTable().getBreakBefore(), getTable().getBreakAfter());\n        TraitSetter.addSpaceBeforeAfter(curBlockArea, layoutContext.getSpaceAdjust(),\n                effSpaceBefore, effSpaceAfter);\n\n        flush();\n\n        resetSpaces();\n        curBlockArea = null;\n\n        notifyEndOfLayout();\n    }\n\n    \n    public Area getParentArea(Area childArea) {\n        if (curBlockArea == null) {\n            curBlockArea = new Block();\n            curBlockArea.setChangeBarList(getChangeBarList());\n\n            \n            \n             parentLayoutManager.getParentArea(curBlockArea);\n\n            TraitSetter.setProducerID(curBlockArea, getTable().getId());\n\n            curBlockArea.setIPD(getContentAreaIPD());\n\n            setCurrentArea(curBlockArea);\n        }\n        return curBlockArea;\n    }\n\n    \n    public void addChildArea(Area childArea) {\n        if (curBlockArea != null) {\n            curBlockArea.addBlock((Block) childArea);\n        }\n    }\n\n    \n    void addBackgroundArea(Block background) {\n        curBlockArea.addChildArea(background);\n    }\n\n    \n    public int negotiateBPDAdjustment(int adj, KnuthElement lastElement) {\n        \n        return 0;\n    }\n\n    \n    public void discardSpace(KnuthGlue spaceGlue) {\n        \n\n    }\n\n    \n    public KeepProperty getKeepTogetherProperty() {\n        return getTable().getKeepTogether();\n    }\n\n    \n    public KeepProperty getKeepWithPreviousProperty() {\n        return getTable().getKeepWithPrevious();\n    }\n\n    \n    public KeepProperty getKeepWithNextProperty() {\n        return getTable().getKeepWithNext();\n    }\n\n    \n\n    \n    public int getBaseLength(int lengthBase, FObj fobj) {\n        \n        if (fobj instanceof TableColumn && fobj.getParent() == getFObj()) {\n            switch (lengthBase) {\n            case LengthBase.CONTAINING_BLOCK_WIDTH:\n                return getContentAreaIPD();\n            case LengthBase.TABLE_UNITS:\n                return (int) this.tableUnit;\n            default:\n                log.error(\"Unknown base type for LengthBase.\");\n                return 0;\n            }\n        } else {\n            switch (lengthBase) {\n            case LengthBase.TABLE_UNITS:\n                return (int) this.tableUnit;\n            default:\n                return super.getBaseLength(lengthBase, fobj);\n            }\n        }\n    }\n\n    \n    public void reset() {\n        super.reset();\n        curBlockArea = null;\n        oldTableUnit = tableUnit;\n        tableUnit = 0.0;\n    }\n\n    \n    protected void saveTableHeaderTableCellLayoutManagers(TableCellLayoutManager tclm) {\n        if (savedTCLMs == null) {\n            savedTCLMs = new ArrayList<TableCellLayoutManager>();\n        }\n        if (!areAllTCLMsSaved) {\n            savedTCLMs.add(tclm);\n        }\n    }\n\n    \n    protected void repeatAddAreasForSavedTableHeaderTableCellLayoutManagers() {\n        if (savedTCLMs == null) {\n            return;\n        }\n        \n        \n        areAllTCLMsSaved = true;\n        for (TableCellLayoutManager tclm : savedTCLMs) {\n            if (this.repeatedHeader) {\n                tclm.setHasRepeatedHeader(true);\n            }\n            tclm.repeatAddAreas();\n        }\n    }\n\n    \n    public RetrieveTableMarker resolveRetrieveTableMarker(RetrieveTableMarker rtm) {\n        String name = rtm.getRetrieveClassName();\n        int originalPosition = rtm.getPosition();\n        boolean changedPosition = false;\n\n        Marker mark = null;\n        \n        mark = (tableFragmentMarkers == null) ? null : tableFragmentMarkers.resolve(rtm);\n        if (mark == null && rtm.getBoundary() != Constants.EN_TABLE_FRAGMENT) {\n            rtm.changePositionTo(Constants.EN_LAST_ENDING);\n            changedPosition = true;\n            \n            mark = getCurrentPV().resolveMarker(rtm);\n            if (mark == null && rtm.getBoundary() != Constants.EN_PAGE) {\n                \n                mark = (tableMarkers == null) ? null : tableMarkers.resolve(rtm);\n            }\n        }\n        if (changedPosition) {\n            \n            rtm.changePositionTo(originalPosition);\n        }\n        if (mark == null) {\n            log.debug(\"found no marker with name: \" + name);\n            return null;\n        } else {\n            rtm.bindMarker(mark);\n            return rtm;\n        }\n    }\n\n    \n    public void registerMarkers(Map<String, Marker> marks, boolean starting, boolean isfirst,\n            boolean islast) {\n        if (tableMarkers == null) {\n            tableMarkers = new Markers();\n        }\n        tableMarkers.register(marks, starting, isfirst, islast);\n        if (tableFragmentMarkers == null) {\n            tableFragmentMarkers = new Markers();\n        }\n        tableFragmentMarkers.register(marks, starting, isfirst, islast);\n    }\n\n    \n    protected void clearTableFragmentMarkers() {\n        tableFragmentMarkers = null;\n    }\n\n    public void flagAsHavingRetrieveTableMarker() {\n        hasRetrieveTableMarker = true;\n    }\n\n    protected void possiblyRegisterMarkersForTables(Map<String, Marker> markers, boolean isStarting,\n            boolean isFirst, boolean isLast) {\n        \n        \n        if (hasRetrieveTableMarker) {\n            registerMarkers(markers, isStarting, isFirst, isLast);\n        }\n        super.possiblyRegisterMarkersForTables(markers, isStarting, isFirst, isLast);\n    }\n\n    void setHeaderFootnotes(List<List<KnuthElement>> footnotes) {\n        this.headerFootnotes = footnotes;\n    }\n\n    List<List<KnuthElement>> getHeaderFootnotes() {\n        return headerFootnotes;\n    }\n\n    void setFooterFootnotes(List<List<KnuthElement>> footnotes) {\n        this.footerFootnotes = footnotes;\n    }\n\n    public void setRepeateHeader(boolean repeateHeader) {\n        this.repeatedHeader = repeateHeader;\n    }\n\n    List<List<KnuthElement>> getFooterFootnotes() {\n        return footerFootnotes;\n    }\n\n}\n"
    ],
    "1": [
        "package org.apache.fop.layoutmgr.table;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n\nimport org.apache.fop.area.Area;\nimport org.apache.fop.area.Block;\nimport org.apache.fop.datatypes.LengthBase;\nimport org.apache.fop.fo.Constants;\nimport org.apache.fop.fo.FONode;\nimport org.apache.fop.fo.FObj;\nimport org.apache.fop.fo.flow.AbstractGraphics;\nimport org.apache.fop.fo.flow.Marker;\nimport org.apache.fop.fo.flow.Markers;\nimport org.apache.fop.fo.flow.RetrieveTableMarker;\nimport org.apache.fop.fo.flow.table.Table;\nimport org.apache.fop.fo.flow.table.TableColumn;\nimport org.apache.fop.fo.properties.CommonBorderPaddingBackground;\nimport org.apache.fop.fo.properties.KeepProperty;\nimport org.apache.fop.layoutmgr.BlockLevelEventProducer;\nimport org.apache.fop.layoutmgr.BreakElement;\nimport org.apache.fop.layoutmgr.BreakOpportunity;\nimport org.apache.fop.layoutmgr.KnuthElement;\nimport org.apache.fop.layoutmgr.KnuthGlue;\nimport org.apache.fop.layoutmgr.LayoutContext;\nimport org.apache.fop.layoutmgr.LeafPosition;\nimport org.apache.fop.layoutmgr.ListElement;\nimport org.apache.fop.layoutmgr.Position;\nimport org.apache.fop.layoutmgr.PositionIterator;\nimport org.apache.fop.layoutmgr.SpacedBorderedPaddedBlockLayoutManager;\nimport org.apache.fop.layoutmgr.TraitSetter;\nimport org.apache.fop.traits.MinOptMax;\nimport org.apache.fop.traits.SpaceVal;\nimport org.apache.fop.util.BreakUtil;\n\npublic class TableLayoutManager extends SpacedBorderedPaddedBlockLayoutManager implements BreakOpportunity {\n\n    private static final Log log = LogFactory.getLog(TableLayoutManager.class);\n\n    private TableContentLayoutManager contentLM;\n    private final ColumnSetup columns;\n    private Block curBlockArea;\n    private double tableUnit;\n    private double oldTableUnit;\n    private boolean autoLayout = true;\n    private int halfBorderSeparationBPD;\n    private int halfBorderSeparationIPD;\n    private List<ColumnBackgroundInfo> columnBackgroundAreas;\n    private Position auxiliaryPosition;\n    private List<TableCellLayoutManager> savedTCLMs;\n    private boolean areAllTCLMsSaved;\n    private Markers tableMarkers;\n    private Markers tableFragmentMarkers;\n    private boolean hasRetrieveTableMarker;\n    private boolean repeatedHeader;\n    private List<List<KnuthElement>> headerFootnotes = Collections.emptyList();\n    private List<List<KnuthElement>> footerFootnotes = Collections.emptyList();\n\n    private static final class ColumnBackgroundInfo {\n        private final TableColumn column;\n        private final Block backgroundArea;\n        private final int xShift;\n        private ColumnBackgroundInfo(TableColumn column, Block backgroundArea, int xShift) {\n            this.column = column;\n            this.backgroundArea = backgroundArea;\n            this.xShift = xShift;\n        }\n    }\n\n    public TableLayoutManager(Table node) {\n        super(node);\n        this.columns = new ColumnSetup(node);\n    }\n\n    @Override\n    protected CommonBorderPaddingBackground getCommonBorderPaddingBackground() {\n        return getTable().getCommonBorderPaddingBackground();\n    }\n\n    public Table getTable() {\n        return (Table) this.fobj;\n    }\n\n    public ColumnSetup getColumns() {\n        return this.columns;\n    }\n\n    public void initialize() {\n        Table table = getTable();\n        foSpaceBefore = new SpaceVal(table.getCommonMarginBlock().spaceBefore, this).getSpace();\n        foSpaceAfter = new SpaceVal(table.getCommonMarginBlock().spaceAfter, this).getSpace();\n        startIndent = table.getCommonMarginBlock().startIndent.getValue(this);\n        endIndent = table.getCommonMarginBlock().endIndent.getValue(this);\n\n        if (table.isSeparateBorderModel()) {\n            halfBorderSeparationBPD = table.getBorderSeparation().getBPD().getLength().getValue(this) / 2;\n            halfBorderSeparationIPD = table.getBorderSeparation().getIPD().getLength().getValue(this) / 2;\n        } else {\n            halfBorderSeparationBPD = 0;\n            halfBorderSeparationIPD = 0;\n        }\n\n        if (!table.isAutoLayout()\n                && table.getInlineProgressionDimension().getOptimum(this).getEnum() != EN_AUTO) {\n            autoLayout = false;\n        }\n    }\n\n    private void resetSpaces() {\n        this.discardBorderBefore = false;\n        this.discardBorderAfter = false;\n        this.discardPaddingBefore = false;\n        this.discardPaddingAfter = false;\n        this.effSpaceBefore = null;\n        this.effSpaceAfter = null;\n    }\n\n    public int getHalfBorderSeparationBPD() {\n        return halfBorderSeparationBPD;\n    }\n\n    public int getHalfBorderSeparationIPD() {\n        return halfBorderSeparationIPD;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public List getNextKnuthElements(LayoutContext context, int alignment) {\n        Table table = getTable();\n        List returnList = new ArrayList();\n        referenceIPD = context.getRefIPD();\n        int tableIPDenum = table.getInlineProgressionDimension().getOptimum(this).getEnum();\n\n        if (tableIPDenum != EN_AUTO) {\n            int contentIPD = table.getInlineProgressionDimension().getOptimum(this).getLength().getValue(this);\n            updateContentAreaIPDwithOverconstrainedAdjust(contentIPD);\n        } else {\n            if (!table.isAutoLayout()) {\n                BlockLevelEventProducer eventProducer = BlockLevelEventProducer.Provider.get(\n                        table.getUserAgent().getEventBroadcaster());\n                eventProducer.tableFixedAutoWidthNotSupported(this, table.getLocator());\n            }\n            updateContentAreaIPDwithOverconstrainedAdjust();\n        }\n        int sumOfColumns = columns.getSumOfColumnWidths(this);\n        if (!autoLayout && sumOfColumns > getContentAreaIPD()) {\n            if (log.isDebugEnabled()) {\n                log.debug(FONode.decorateWithContextInfo(\n                        \"The sum of all column widths is larger than the specified table width.\", table));\n            }\n            updateContentAreaIPDwithOverconstrainedAdjust(sumOfColumns);\n        }\n        int availableIPD = referenceIPD - getIPIndents();\n        if (getContentAreaIPD() > availableIPD) {\n            BlockLevelEventProducer eventProducer = BlockLevelEventProducer.Provider.get(\n                    table.getUserAgent().getEventBroadcaster());\n            eventProducer.objectTooWide(this, table.getName(), getContentAreaIPD(), context.getRefIPD(), table.getLocator());\n        }\n\n        if (tableUnit == 0.0) {\n            tableUnit = columns.computeTableUnit(this);\n            if (oldTableUnit > tableUnit && supportResize(fobj)) {\n                tableUnit = oldTableUnit;\n            }\n        }\n\n        if (!firstVisibleMarkServed) {\n            addKnuthElementsForSpaceBefore(returnList, alignment);\n        }\n\n        if (table.isSeparateBorderModel()) {\n            addKnuthElementsForBorderPaddingBefore(returnList, !firstVisibleMarkServed);\n            firstVisibleMarkServed = true;\n            addPendingMarks(context);\n        }\n\n        contentLM = new TableContentLayoutManager(this);\n        LayoutContext childLC = LayoutContext.newInstance();\n        childLC.setRefIPD(context.getRefIPD());\n        childLC.copyPendingMarksFrom(context);\n\n        List contentKnuthElements = contentLM.getNextKnuthElements(childLC, alignment);\n        for (Object elObj : contentKnuthElements) {\n            ListElement el = (ListElement) elObj;\n            notifyPos(el.getPosition());\n        }\n        if (log.isDebugEnabled()) {\n            log.debug(contentKnuthElements);\n        }\n        wrapPositionElements(contentKnuthElements, returnList);\n\n        context.updateKeepWithPreviousPending(getKeepWithPrevious());\n        context.updateKeepWithPreviousPending(childLC.getKeepWithPreviousPending());\n        context.updateKeepWithNextPending(getKeepWithNext());\n        context.updateKeepWithNextPending(childLC.getKeepWithNextPending());\n\n        if (table.isSeparateBorderModel()) {\n            addKnuthElementsForBorderPaddingAfter(returnList, true);\n        }\n        addKnuthElementsForSpaceAfter(returnList, alignment);\n\n        if (!context.suppressBreakBefore()) {\n            int breakBefore = BreakUtil.compareBreakClasses(table.getBreakBefore(), childLC.getBreakBefore());\n            if (breakBefore != Constants.EN_AUTO) {\n                returnList.add(0, new BreakElement(new LeafPosition(getParent(), 0), 0,\n                        -KnuthElement.INFINITE, breakBefore, context));\n            }\n        }\n\n        int breakAfter = BreakUtil.compareBreakClasses(table.getBreakAfter(), childLC.getBreakAfter());\n        if (breakAfter != Constants.EN_AUTO) {\n            returnList.add(new BreakElement(new LeafPosition(getParent(), 0),\n                    0, -KnuthElement.INFINITE, breakAfter, context));\n        }\n\n        setFinished(true);\n        resetSpaces();\n        return returnList;\n    }\n\n    private boolean supportResize(FONode node) {\n        if (node instanceof AbstractGraphics) {\n            return false;\n        }\n        FONode.FONodeIterator iterator = node.getChildNodes();\n        while (iterator != null && iterator.hasNext()) {\n            FONode x = iterator.next();\n            if (!supportResize(x)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public Position getAuxiliaryPosition() {\n        if (auxiliaryPosition == null) {\n            auxiliaryPosition = new LeafPosition(this, 0);\n        }\n        return auxiliaryPosition;\n    }\n\n    void registerColumnBackgroundArea(TableColumn column, Block backgroundArea, int xShift) {\n        addBackgroundArea(backgroundArea);\n        if (columnBackgroundAreas == null) {\n            columnBackgroundAreas = new ArrayList<>();\n        }\n        columnBackgroundAreas.add(new ColumnBackgroundInfo(column, backgroundArea, xShift));\n    }\n\n    public void addAreas(PositionIterator parentIter, LayoutContext layoutContext) {\n        getParentArea(null);\n        addId();\n\n        if (layoutContext.getSpaceBefore() != 0) {\n            addBlockSpacing(0.0, MinOptMax.getInstance(layoutContext.getSpaceBefore()));\n        }\n\n        int startXOffset = getTable().getCommonMarginBlock().startIndent.getValue(this);\n        int tableHeight = 0;\n        LayoutContext lc = LayoutContext.offspringOf(layoutContext);\n        lc.setRefIPD(getContentAreaIPD());\n        contentLM.setStartXOffset(startXOffset);\n        contentLM.addAreas(parentIter, lc);\n\n        if (fobj.getUserAgent().isTableBorderOverpaint()) {\n            new OverPaintBorders(curBlockArea);\n        }\n\n        tableHeight += contentLM.getUsedBPD();\n        curBlockArea.setBPD(tableHeight);\n\n        if (columnBackgroundAreas != null) {\n            for (ColumnBackgroundInfo b : columnBackgroundAreas) {\n                TraitSetter.addBackground(b.backgroundArea,\n                        b.column.getCommonBorderPaddingBackground(), this,\n                        b.xShift, -b.backgroundArea.getYOffset(),\n                        b.column.getColumnWidth().getValue(this), tableHeight);\n            }\n            columnBackgroundAreas.clear();\n        }\n\n        if (getTable().isSeparateBorderModel()) {\n            TraitSetter.addBorders(curBlockArea,\n                    getTable().getCommonBorderPaddingBackground(),\n                    discardBorderBefore, discardBorderAfter, false, false, this);\n            TraitSetter.addPadding(curBlockArea,\n                    getTable().getCommonBorderPaddingBackground(),\n                    discardPaddingBefore, discardPaddingAfter, false, false, this);\n        }\n        TraitSetter.addBackground(curBlockArea, getTable().getCommonBorderPaddingBackground(), this);\n        TraitSetter.addMargins(curBlockArea, getTable().getCommonBorderPaddingBackground(), startIndent, endIndent, this);\n        TraitSetter.addBreaks(curBlockArea, getTable().getBreakBefore(), getTable().getBreakAfter());\n        TraitSetter.addSpaceBeforeAfter(curBlockArea, layoutContext.getSpaceAdjust(), effSpaceBefore, effSpaceAfter);\n        flush();\n        resetSpaces();\n        curBlockArea = null;\n        notifyEndOfLayout();\n    }\n\n    public Area getParentArea(Area childArea) {\n        if (curBlockArea == null) {\n            curBlockArea = new Block();\n            curBlockArea.setChangeBarList(getChangeBarList());\n            parentLayoutManager.getParentArea(curBlockArea);\n            TraitSetter.setProducerID(curBlockArea, getTable().getId());\n            curBlockArea.setIPD(getContentAreaIPD());\n            setCurrentArea(curBlockArea);\n        }\n        return curBlockArea;\n    }\n\n    public void addChildArea(Area childArea) {\n        if (curBlockArea != null) {\n            curBlockArea.addBlock((Block) childArea);\n        }\n    }\n\n    void addBackgroundArea(Block background) {\n        curBlockArea.addChildArea(background);\n    }\n\n    public int negotiateBPDAdjustment(int adj, KnuthElement lastElement) {\n        return 0;\n    }\n\n    public void discardSpace(KnuthGlue spaceGlue) {\n        \n    }\n\n    public KeepProperty getKeepTogetherProperty() {\n        return getTable().getKeepTogether();\n    }\n\n    public KeepProperty getKeepWithPreviousProperty() {\n        return getTable().getKeepWithPrevious();\n    }\n\n    public KeepProperty getKeepWithNextProperty() {\n        return getTable().getKeepWithNext();\n    }\n\n    public int getBaseLength(int lengthBase, FObj fobj) {\n        if (fobj instanceof TableColumn && fobj.getParent() == getFObj()) {\n            switch (lengthBase) {\n            case LengthBase.CONTAINING_BLOCK_WIDTH:\n                return getContentAreaIPD();\n            case LengthBase.TABLE_UNITS:\n                return (int) this.tableUnit;\n            default:\n                log.error(\"Unknown base type for LengthBase.\");\n                return 0;\n            }\n        } else {\n            switch (lengthBase) {\n            case LengthBase.TABLE_UNITS:\n                return (int) this.tableUnit;\n            default:\n                return super.getBaseLength(lengthBase, fobj);\n            }\n        }\n    }\n\n    public void reset() {\n        super.reset();\n        curBlockArea = null;\n        oldTableUnit = tableUnit;\n        tableUnit = 0.0;\n    }\n\n    protected void saveTableHeaderTableCellLayoutManagers(TableCellLayoutManager tclm) {\n        if (savedTCLMs == null) {\n            savedTCLMs = new ArrayList<>();\n        }\n        if (!areAllTCLMsSaved) {\n            savedTCLMs.add(tclm);\n        }\n    }\n\n    protected void repeatAddAreasForSavedTableHeaderTableCellLayoutManagers() {\n        if (savedTCLMs == null) {\n            return;\n        }\n        areAllTCLMsSaved = true;\n        for (TableCellLayoutManager tclm : savedTCLMs) {\n            if (this.repeatedHeader) {\n                tclm.setHasRepeatedHeader(true);\n            }\n            tclm.repeatAddAreas();\n        }\n    }\n\n    public RetrieveTableMarker resolveRetrieveTableMarker(RetrieveTableMarker rtm) {\n        String name = rtm.getRetrieveClassName();\n        int originalPosition = rtm.getPosition();\n        boolean changedPosition = false;\n        Marker mark = null;\n        mark = (tableFragmentMarkers == null) ? null : tableFragmentMarkers.resolve(rtm);\n        if (mark == null && rtm.getBoundary() != Constants.EN_TABLE_FRAGMENT) {\n            rtm.changePositionTo(Constants.EN_LAST_ENDING);\n            changedPosition = true;\n            mark = getCurrentPV().resolveMarker(rtm);\n            if (mark == null && rtm.getBoundary() != Constants.EN_PAGE) {\n                mark = (tableMarkers == null) ? null : tableMarkers.resolve(rtm);\n            }\n        }\n        if (changedPosition) {\n            rtm.changePositionTo(originalPosition);\n        }\n        if (mark == null) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"found no marker with name: \" + name);\n            }\n            return null;\n        } else {\n            rtm.bindMarker(mark);\n            return rtm;\n        }\n    }\n\n    public void registerMarkers(Map<String, Marker> marks, boolean starting, boolean isfirst, boolean islast) {\n        if (tableMarkers == null) {\n            tableMarkers = new Markers();\n        }\n        tableMarkers.register(marks, starting, isfirst, islast);\n        if (tableFragmentMarkers == null) {\n            tableFragmentMarkers = new Markers();\n        }\n        tableFragmentMarkers.register(marks, starting, isfirst, islast);\n    }\n\n    protected void clearTableFragmentMarkers() {\n        tableFragmentMarkers = null;\n    }\n\n    public void flagAsHavingRetrieveTableMarker() {\n        hasRetrieveTableMarker = true;\n    }\n\n    protected void possiblyRegisterMarkersForTables(Map<String, Marker> markers, boolean isStarting, boolean isFirst, boolean isLast) {\n        if (hasRetrieveTableMarker) {\n            registerMarkers(markers, isStarting, isFirst, isLast);\n        }\n        super.possiblyRegisterMarkersForTables(markers, isStarting, isFirst, isLast);\n    }\n\n    void setHeaderFootnotes(List<List<KnuthElement>> footnotes) {\n        this.headerFootnotes = footnotes;\n    }\n\n    List<List<KnuthElement>> getHeaderFootnotes() {\n        return headerFootnotes;\n    }\n\n    void setFooterFootnotes(List<List<KnuthElement>> footnotes) {\n        this.footerFootnotes = footnotes;\n    }\n\n    public void setRepeateHeader(boolean repeateHeader) {\n        this.repeatedHeader = repeateHeader;\n    }\n\n    List<List<KnuthElement>> getFooterFootnotes() {\n        return footerFootnotes;\n    }\n}\n"
    ],
    "2": [
        "package org.apache.fop.layoutmgr.table;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n\nimport org.apache.fop.area.Area;\nimport org.apache.fop.area.Block;\nimport org.apache.fop.datatypes.LengthBase;\nimport org.apache.fop.fo.Constants;\nimport org.apache.fop.fo.FONode;\nimport org.apache.fop.fo.FObj;\nimport org.apache.fop.fo.flow.AbstractGraphics;\nimport org.apache.fop.fo.flow.Marker;\nimport org.apache.fop.fo.flow.Markers;\nimport org.apache.fop.fo.flow.RetrieveTableMarker;\nimport org.apache.fop.fo.flow.table.Table;\nimport org.apache.fop.fo.flow.table.TableColumn;\nimport org.apache.fop.fo.properties.CommonBorderPaddingBackground;\nimport org.apache.fop.fo.properties.KeepProperty;\nimport org.apache.fop.layoutmgr.BlockLevelEventProducer;\nimport org.apache.fop.layoutmgr.BreakElement;\nimport org.apache.fop.layoutmgr.BreakOpportunity;\nimport org.apache.fop.layoutmgr.KnuthElement;\nimport org.apache.fop.layoutmgr.KnuthGlue;\nimport org.apache.fop.layoutmgr.LayoutContext;\nimport org.apache.fop.layoutmgr.LeafPosition;\nimport org.apache.fop.layoutmgr.ListElement;\nimport org.apache.fop.layoutmgr.Position;\nimport org.apache.fop.layoutmgr.PositionIterator;\nimport org.apache.fop.layoutmgr.SpacedBorderedPaddedBlockLayoutManager;\nimport org.apache.fop.layoutmgr.TraitSetter;\nimport org.apache.fop.traits.MinOptMax;\nimport org.apache.fop.traits.SpaceVal;\nimport org.apache.fop.util.BreakUtil;\n\npublic class TableLayoutManager extends SpacedBorderedPaddedBlockLayoutManager implements BreakOpportunity {\n\n    private static final Log log = LogFactory.getLog(TableLayoutManager.class);\n\n    private TableContentLayoutManager contentLM;\n    private final ColumnSetup columns;\n    private Block curBlockArea;\n    private double tableUnit;\n    private double oldTableUnit;\n    private boolean autoLayout = true;\n    private int halfBorderSeparationBPD;\n    private int halfBorderSeparationIPD;\n    private final List<ColumnBackgroundInfo> columnBackgroundAreas;\n    private Position auxiliaryPosition;\n    private final List<TableCellLayoutManager> savedTCLMs;\n    private boolean areAllTCLMsSaved;\n    private Markers tableMarkers;\n    private Markers tableFragmentMarkers;\n    private boolean hasRetrieveTableMarker;\n    private boolean repeatedHeader;\n    private List<List<KnuthElement>> headerFootnotes = Collections.emptyList();\n    private List<List<KnuthElement>> footerFootnotes = Collections.emptyList();\n    \n    private int memoizedSumOfColumns = -1;\n    private double memoizedTableUnit = -1;\n\n    private static final class ColumnBackgroundInfo {\n        private final TableColumn column;\n        private final Block backgroundArea;\n        private final int xShift;\n        private ColumnBackgroundInfo(TableColumn column, Block backgroundArea, int xShift) {\n            this.column = column;\n            this.backgroundArea = backgroundArea;\n            this.xShift = xShift;\n        }\n    }\n\n    public TableLayoutManager(Table node) {\n        super(node);\n        this.columns = new ColumnSetup(node);\n        \n        this.columnBackgroundAreas = new ArrayList<>();\n        this.savedTCLMs = new ArrayList<>();\n    }\n\n    @Override\n    protected CommonBorderPaddingBackground getCommonBorderPaddingBackground() {\n        return getTable().getCommonBorderPaddingBackground();\n    }\n\n    public Table getTable() {\n        return (Table) this.fobj;\n    }\n\n    public ColumnSetup getColumns() {\n        return this.columns;\n    }\n\n    public void initialize() {\n        final Table table = getTable();\n        final org.apache.fop.fo.properties.CommonMarginBlock margin = table.getCommonMarginBlock();\n        foSpaceBefore = new SpaceVal(margin.spaceBefore, this).getSpace();\n        foSpaceAfter = new SpaceVal(margin.spaceAfter, this).getSpace();\n        startIndent = margin.startIndent.getValue(this);\n        endIndent = margin.endIndent.getValue(this);\n\n        if (table.isSeparateBorderModel()) {\n            halfBorderSeparationBPD = table.getBorderSeparation().getBPD().getLength().getValue(this) / 2;\n            halfBorderSeparationIPD = table.getBorderSeparation().getIPD().getLength().getValue(this) / 2;\n        } else {\n            halfBorderSeparationBPD = 0;\n            halfBorderSeparationIPD = 0;\n        }\n\n        if (!table.isAutoLayout()\n                && table.getInlineProgressionDimension().getOptimum(this).getEnum() != EN_AUTO) {\n            autoLayout = false;\n        }\n        \n        memoizedSumOfColumns = -1;\n        memoizedTableUnit = -1;\n    }\n\n    private void resetSpaces() {\n        this.discardBorderBefore = false;\n        this.discardBorderAfter = false;\n        this.discardPaddingBefore = false;\n        this.discardPaddingAfter = false;\n        this.effSpaceBefore = null;\n        this.effSpaceAfter = null;\n    }\n\n    public int getHalfBorderSeparationBPD() {\n        return halfBorderSeparationBPD;\n    }\n\n    public int getHalfBorderSeparationIPD() {\n        return halfBorderSeparationIPD;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public List getNextKnuthElements(LayoutContext context, int alignment) {\n        final Table table = getTable();\n        List returnList = new ArrayList(32);\n        referenceIPD = context.getRefIPD();\n        final int tableIPDenum = table.getInlineProgressionDimension().getOptimum(this).getEnum();\n\n        if (tableIPDenum != EN_AUTO) {\n            final int contentIPD = table.getInlineProgressionDimension().getOptimum(this).getLength().getValue(this);\n            updateContentAreaIPDwithOverconstrainedAdjust(contentIPD);\n        } else {\n            if (!table.isAutoLayout()) {\n                if (log.isDebugEnabled()) {\n                    BlockLevelEventProducer eventProducer = BlockLevelEventProducer.Provider.get(\n                            table.getUserAgent().getEventBroadcaster());\n                    eventProducer.tableFixedAutoWidthNotSupported(this, table.getLocator());\n                }\n            }\n            updateContentAreaIPDwithOverconstrainedAdjust();\n        }\n        int sumOfColumns;\n        if (memoizedSumOfColumns >= 0) {\n            sumOfColumns = memoizedSumOfColumns;\n        } else {\n            sumOfColumns = columns.getSumOfColumnWidths(this);\n            memoizedSumOfColumns = sumOfColumns;\n        }\n        if (!autoLayout && sumOfColumns > getContentAreaIPD()) {\n            if (log.isDebugEnabled()) {\n                log.debug(FONode.decorateWithContextInfo(\n                        \"The sum of all column widths is larger than the specified table width.\", table));\n            }\n            updateContentAreaIPDwithOverconstrainedAdjust(sumOfColumns);\n        }\n        int availableIPD = referenceIPD - getIPIndents();\n        if (getContentAreaIPD() > availableIPD) {\n            if (log.isDebugEnabled()) {\n                BlockLevelEventProducer eventProducer = BlockLevelEventProducer.Provider.get(\n                        table.getUserAgent().getEventBroadcaster());\n                eventProducer.objectTooWide(this, table.getName(), getContentAreaIPD(), context.getRefIPD(), table.getLocator());\n            }\n        }\n\n        if (tableUnit == 0.0) {\n            double tu;\n            if (memoizedTableUnit >= 0) {\n                tu = memoizedTableUnit;\n            } else {\n                tu = columns.computeTableUnit(this);\n                memoizedTableUnit = tu;\n            }\n            tableUnit = tu;\n            if (oldTableUnit > tableUnit && supportResize(fobj)) {\n                tableUnit = oldTableUnit;\n            }\n        }\n\n        if (!firstVisibleMarkServed) {\n            addKnuthElementsForSpaceBefore(returnList, alignment);\n        }\n\n        if (table.isSeparateBorderModel()) {\n            addKnuthElementsForBorderPaddingBefore(returnList, !firstVisibleMarkServed);\n            firstVisibleMarkServed = true;\n            addPendingMarks(context);\n        }\n\n        contentLM = new TableContentLayoutManager(this);\n        LayoutContext childLC = LayoutContext.newInstance();\n        childLC.setRefIPD(context.getRefIPD());\n        childLC.copyPendingMarksFrom(context);\n\n        List contentKnuthElements = contentLM.getNextKnuthElements(childLC, alignment);\n        for (int i = 0, sz = contentKnuthElements.size(); i < sz; i++) {\n            ListElement el = (ListElement) contentKnuthElements.get(i);\n            notifyPos(el.getPosition());\n        }\n        if (log.isDebugEnabled()) {\n            log.debug(contentKnuthElements);\n        }\n        wrapPositionElements(contentKnuthElements, returnList);\n\n        context.updateKeepWithPreviousPending(getKeepWithPrevious());\n        context.updateKeepWithPreviousPending(childLC.getKeepWithPreviousPending());\n        context.updateKeepWithNextPending(getKeepWithNext());\n        context.updateKeepWithNextPending(childLC.getKeepWithNextPending());\n\n        if (table.isSeparateBorderModel()) {\n            addKnuthElementsForBorderPaddingAfter(returnList, true);\n        }\n        addKnuthElementsForSpaceAfter(returnList, alignment);\n\n        if (!context.suppressBreakBefore()) {\n            int breakBefore = BreakUtil.compareBreakClasses(table.getBreakBefore(), childLC.getBreakBefore());\n            if (breakBefore != Constants.EN_AUTO) {\n                returnList.add(0, new BreakElement(new LeafPosition(getParent(), 0), 0,\n                        -KnuthElement.INFINITE, breakBefore, context));\n            }\n        }\n\n        int breakAfter = BreakUtil.compareBreakClasses(table.getBreakAfter(), childLC.getBreakAfter());\n        if (breakAfter != Constants.EN_AUTO) {\n            returnList.add(new BreakElement(new LeafPosition(getParent(), 0),\n                    0, -KnuthElement.INFINITE, breakAfter, context));\n        }\n\n        setFinished(true);\n        resetSpaces();\n        return returnList;\n    }\n\n    private boolean supportResize(FONode node) {\n        if (node instanceof AbstractGraphics) {\n            return false;\n        }\n        FONode.FONodeIterator iterator = node.getChildNodes();\n        while (iterator != null && iterator.hasNext()) {\n            FONode x = iterator.next();\n            if (!supportResize(x)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public Position getAuxiliaryPosition() {\n        if (auxiliaryPosition == null) {\n            auxiliaryPosition = new LeafPosition(this, 0);\n        }\n        return auxiliaryPosition;\n    }\n\n    void registerColumnBackgroundArea(TableColumn column, Block backgroundArea, int xShift) {\n        addBackgroundArea(backgroundArea);\n        columnBackgroundAreas.add(new ColumnBackgroundInfo(column, backgroundArea, xShift));\n    }\n\n    public void addAreas(PositionIterator parentIter, LayoutContext layoutContext) {\n        getParentArea(null);\n        addId();\n\n        if (layoutContext.getSpaceBefore() != 0) {\n            addBlockSpacing(0.0, MinOptMax.getInstance(layoutContext.getSpaceBefore()));\n        }\n\n        final Table table = getTable();\n        int startXOffset = table.getCommonMarginBlock().startIndent.getValue(this);\n        int tableHeight = 0;\n        LayoutContext lc = LayoutContext.offspringOf(layoutContext);\n        lc.setRefIPD(getContentAreaIPD());\n        contentLM.setStartXOffset(startXOffset);\n        contentLM.addAreas(parentIter, lc);\n\n        if (fobj.getUserAgent().isTableBorderOverpaint()) {\n            new OverPaintBorders(curBlockArea);\n        }\n\n        tableHeight += contentLM.getUsedBPD();\n        curBlockArea.setBPD(tableHeight);\n\n        if (!columnBackgroundAreas.isEmpty()) {\n            \n            \n            for (ColumnBackgroundInfo b : columnBackgroundAreas) {\n                TraitSetter.addBackground(b.backgroundArea,\n                        b.column.getCommonBorderPaddingBackground(), this,\n                        b.xShift, -b.backgroundArea.getYOffset(),\n                        b.column.getColumnWidth().getValue(this), tableHeight);\n            }\n            columnBackgroundAreas.clear();\n        }\n\n        if (table.isSeparateBorderModel()) {\n            TraitSetter.addBorders(curBlockArea,\n                    table.getCommonBorderPaddingBackground(),\n                    discardBorderBefore, discardBorderAfter, false, false, this);\n            TraitSetter.addPadding(curBlockArea,\n                    table.getCommonBorderPaddingBackground(),\n                    discardPaddingBefore, discardPaddingAfter, false, false, this);\n        }\n        TraitSetter.addBackground(curBlockArea, table.getCommonBorderPaddingBackground(), this);\n        TraitSetter.addMargins(curBlockArea, table.getCommonBorderPaddingBackground(), startIndent, endIndent, this);\n        TraitSetter.addBreaks(curBlockArea, table.getBreakBefore(), table.getBreakAfter());\n        TraitSetter.addSpaceBeforeAfter(curBlockArea, layoutContext.getSpaceAdjust(), effSpaceBefore, effSpaceAfter);\n        flush();\n        resetSpaces();\n        curBlockArea = null;\n        notifyEndOfLayout();\n    }\n\n    public Area getParentArea(Area childArea) {\n        if (curBlockArea == null) {\n            curBlockArea = new Block();\n            curBlockArea.setChangeBarList(getChangeBarList());\n            parentLayoutManager.getParentArea(curBlockArea);\n            TraitSetter.setProducerID(curBlockArea, getTable().getId());\n            curBlockArea.setIPD(getContentAreaIPD());\n            setCurrentArea(curBlockArea);\n        }\n        return curBlockArea;\n    }\n\n    public void addChildArea(Area childArea) {\n        if (curBlockArea != null) {\n            curBlockArea.addBlock((Block) childArea);\n        }\n    }\n\n    void addBackgroundArea(Block background) {\n        curBlockArea.addChildArea(background);\n    }\n\n    public int negotiateBPDAdjustment(int adj, KnuthElement lastElement) {\n        return 0;\n    }\n\n    public void discardSpace(KnuthGlue spaceGlue) {\n        \n    }\n\n    public KeepProperty getKeepTogetherProperty() {\n        return getTable().getKeepTogether();\n    }\n\n    public KeepProperty getKeepWithPreviousProperty() {\n        return getTable().getKeepWithPrevious();\n    }\n\n    public KeepProperty getKeepWithNextProperty() {\n        return getTable().getKeepWithNext();\n    }\n\n    public int getBaseLength(int lengthBase, FObj fobj) {\n        if (fobj instanceof TableColumn && fobj.getParent() == getFObj()) {\n            switch (lengthBase) {\n            case LengthBase.CONTAINING_BLOCK_WIDTH:\n                return getContentAreaIPD();\n            case LengthBase.TABLE_UNITS:\n                return (int) this.tableUnit;\n            default:\n                log.error(\"Unknown base type for LengthBase.\");\n                return 0;\n            }\n        } else {\n            switch (lengthBase) {\n            case LengthBase.TABLE_UNITS:\n                return (int) this.tableUnit;\n            default:\n                return super.getBaseLength(lengthBase, fobj);\n            }\n        }\n    }\n\n    public void reset() {\n        super.reset();\n        curBlockArea = null;\n        oldTableUnit = tableUnit;\n        tableUnit = 0.0;\n        memoizedSumOfColumns = -1;\n        memoizedTableUnit = -1;\n    }\n\n    protected void saveTableHeaderTableCellLayoutManagers(TableCellLayoutManager tclm) {\n        if (!areAllTCLMsSaved) {\n            savedTCLMs.add(tclm);\n        }\n    }\n\n    protected void repeatAddAreasForSavedTableHeaderTableCellLayoutManagers() {\n        if (savedTCLMs.isEmpty()) {\n            return;\n        }\n        areAllTCLMsSaved = true;\n        for (TableCellLayoutManager tclm : savedTCLMs) {\n            if (this.repeatedHeader) {\n                tclm.setHasRepeatedHeader(true);\n            }\n            tclm.repeatAddAreas();\n        }\n    }\n\n    public RetrieveTableMarker resolveRetrieveTableMarker(RetrieveTableMarker rtm) {\n        String name = rtm.getRetrieveClassName();\n        int originalPosition = rtm.getPosition();\n        boolean changedPosition = false;\n        Marker mark = null;\n        mark = (tableFragmentMarkers == null) ? null : tableFragmentMarkers.resolve(rtm);\n        if (mark == null && rtm.getBoundary() != Constants.EN_TABLE_FRAGMENT) {\n            rtm.changePositionTo(Constants.EN_LAST_ENDING);\n            changedPosition = true;\n            mark = getCurrentPV().resolveMarker(rtm);\n            if (mark == null && rtm.getBoundary() != Constants.EN_PAGE) {\n                mark = (tableMarkers == null) ? null : tableMarkers.resolve(rtm);\n            }\n        }\n        if (changedPosition) {\n            rtm.changePositionTo(originalPosition);\n        }\n        if (mark == null) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"found no marker with name: \" + name);\n            }\n            return null;\n        } else {\n            rtm.bindMarker(mark);\n            return rtm;\n        }\n    }\n\n    public void registerMarkers(Map<String, Marker> marks, boolean starting, boolean isfirst, boolean islast) {\n        if (tableMarkers == null) {\n            tableMarkers = new Markers();\n        }\n        tableMarkers.register(marks, starting, isfirst, islast);\n        if (tableFragmentMarkers == null) {\n            tableFragmentMarkers = new Markers();\n        }\n        tableFragmentMarkers.register(marks, starting, isfirst, islast);\n    }\n\n    protected void clearTableFragmentMarkers() {\n        tableFragmentMarkers = null;\n    }\n\n    public void flagAsHavingRetrieveTableMarker() {\n        hasRetrieveTableMarker = true;\n    }\n\n    protected void possiblyRegisterMarkersForTables(Map<String, Marker> markers, boolean isStarting, boolean isFirst, boolean isLast) {\n        if (hasRetrieveTableMarker) {\n            registerMarkers(markers, isStarting, isFirst, isLast);\n        }\n        super.possiblyRegisterMarkersForTables(markers, isStarting, isFirst, isLast);\n    }\n\n    void setHeaderFootnotes(List<List<KnuthElement>> footnotes) {\n        this.headerFootnotes = footnotes;\n    }\n\n    List<List<KnuthElement>> getHeaderFootnotes() {\n        return headerFootnotes;\n    }\n\n    void setFooterFootnotes(List<List<KnuthElement>> footnotes) {\n        this.footerFootnotes = footnotes;\n    }\n\n    public void setRepeateHeader(boolean repeateHeader) {\n        this.repeatedHeader = repeateHeader;\n    }\n\n    List<List<KnuthElement>> getFooterFootnotes() {\n        return footerFootnotes;\n    }\n}\n"
    ]
}