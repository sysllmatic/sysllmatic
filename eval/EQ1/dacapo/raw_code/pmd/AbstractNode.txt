{
    "0": [
        "\n\npackage net.sourceforge.pmd.lang.ast;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.logging.Logger;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.jaxen.BaseXPath;\nimport org.jaxen.JaxenException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\n\nimport net.sourceforge.pmd.PMDVersion;\nimport net.sourceforge.pmd.annotation.InternalApi;\nimport net.sourceforge.pmd.lang.ast.xpath.Attribute;\nimport net.sourceforge.pmd.lang.ast.xpath.AttributeAxisIterator;\nimport net.sourceforge.pmd.lang.ast.xpath.DocumentNavigator;\nimport net.sourceforge.pmd.lang.ast.xpath.internal.ContextualizedNavigator;\nimport net.sourceforge.pmd.lang.ast.xpath.internal.DeprecatedAttrLogger;\nimport net.sourceforge.pmd.lang.dfa.DataFlowNode;\nimport net.sourceforge.pmd.util.DataMap;\nimport net.sourceforge.pmd.util.DataMap.DataKey;\nimport net.sourceforge.pmd.util.DataMap.SimpleDataKey;\n\n\n\npublic abstract class AbstractNode implements Node {\n\n    private static final Logger LOG = Logger.getLogger(AbstractNode.class.getName());\n\n    private static final SimpleDataKey<Object> LEGACY_USER_DATA = DataMap.simpleDataKey(\"legacy user data\");\n\n    private final DataMap<DataKey<?, ?>> userData = DataMap.newDataMap();\n\n    \n    @Deprecated\n    protected Node parent;\n    @Deprecated\n    protected Node[] children;\n    \n    @Deprecated\n    protected int childIndex;\n    \n    @Deprecated\n    protected int id;\n    \n    @Deprecated\n    protected int beginLine = -1;\n    \n    @Deprecated\n    protected int endLine;\n    \n    @Deprecated\n    protected int beginColumn = -1;\n    \n    @Deprecated\n    protected int endColumn;\n    \n    @Deprecated\n    protected GenericToken firstToken;\n    @Deprecated\n    protected GenericToken lastToken;\n    private DataFlowNode dataFlowNode;\n    \n    private String image;\n\n    public AbstractNode(final int id) {\n        this.id = id;\n    }\n\n    public AbstractNode(final int id, final int theBeginLine, final int theEndLine, final int theBeginColumn,\n                        final int theEndColumn) {\n        this(id);\n\n        beginLine = theBeginLine;\n        endLine = theEndLine;\n        beginColumn = theBeginColumn;\n        endColumn = theEndColumn;\n    }\n\n\n    @Override\n    public Node getParent() {\n        return jjtGetParent();\n    }\n\n    @Override\n    public int getIndexInParent() {\n        return jjtGetChildIndex();\n    }\n\n    @Override\n    public Node getChild(final int index) {\n        if (children == null) {\n            throw new IndexOutOfBoundsException();\n        }\n        return children[index];\n    }\n\n    @Override\n    public int getNumChildren() {\n        return jjtGetNumChildren();\n    }\n\n\n    \n    @Deprecated\n    public boolean isSingleLine() {\n        return beginLine == endLine;\n    }\n\n    @Override\n    @Deprecated\n    @InternalApi\n    public void jjtOpen() {\n        \n    }\n\n    @Override\n    @Deprecated\n    @InternalApi\n    public void jjtClose() {\n        \n    }\n\n    @Override\n    @Deprecated\n    @InternalApi\n    public void jjtSetParent(final Node parent) {\n        this.parent = parent;\n    }\n\n    @Override\n    @Deprecated\n    public Node jjtGetParent() {\n        return parent;\n    }\n\n    @Override\n    @Deprecated\n    @InternalApi\n    public void jjtAddChild(final Node child, final int index) {\n        if (children == null) {\n            children = new Node[index + 1];\n        } else if (index >= children.length) {\n            final Node[] newChildren = new Node[index + 1];\n            System.arraycopy(children, 0, newChildren, 0, children.length);\n            children = newChildren;\n        }\n        children[index] = child;\n        child.jjtSetChildIndex(index);\n    }\n\n    @Override\n    @Deprecated\n    @InternalApi\n    public void jjtSetChildIndex(final int index) {\n        childIndex = index;\n    }\n\n    @Override\n    @Deprecated\n    public int jjtGetChildIndex() {\n        return childIndex;\n    }\n\n\n    @Override\n    @Deprecated\n    public Node jjtGetChild(final int index) {\n        return children[index];\n    }\n\n    @Override\n    @Deprecated\n    public int jjtGetNumChildren() {\n        return children == null ? 0 : children.length;\n    }\n\n\n    \n    @Override\n    @Deprecated\n    public int jjtGetId() {\n        return id;\n    }\n\n    @Override\n    public String getImage() {\n        return image;\n    }\n\n    @Override\n    @Deprecated\n    public void setImage(final String image) {\n        this.image = image;\n    }\n\n    @Override\n    public boolean hasImageEqualTo(final String image) {\n        return Objects.equals(this.getImage(), image);\n    }\n\n    @Override\n    public int getBeginLine() {\n        return beginLine;\n    }\n\n    \n    @Deprecated\n    @InternalApi\n    public void testingOnlySetBeginLine(int i) {\n        this.beginLine = i;\n    }\n\n    @Override\n    public int getBeginColumn() {\n        if (beginColumn == -1) {\n            if (children != null && children.length > 0) {\n                return children[0].getBeginColumn();\n            } else {\n                throw new RuntimeException(\"Unable to determine beginning line of Node.\");\n            }\n        } else {\n            return beginColumn;\n        }\n    }\n\n    \n    @Deprecated\n    @InternalApi\n    public void testingOnlySetBeginColumn(final int i) {\n        this.beginColumn = i;\n    }\n\n    @Override\n    public int getEndLine() {\n        return endLine;\n    }\n\n    \n    @Deprecated\n    @InternalApi\n    public void testingOnlySetEndLine(final int i) {\n        this.endLine = i;\n    }\n\n    @Override\n    public int getEndColumn() {\n        return endColumn;\n    }\n\n    \n    @Deprecated\n    @InternalApi\n    public void testingOnlySetEndColumn(final int i) {\n        this.endColumn = i;\n    }\n\n    @Override\n    public DataFlowNode getDataFlowNode() {\n        if (this.dataFlowNode == null) {\n            if (this.parent != null) {\n                return parent.getDataFlowNode();\n            }\n            return null; \n        }\n        return dataFlowNode;\n    }\n\n    @Override\n    public void setDataFlowNode(final DataFlowNode dataFlowNode) {\n        this.dataFlowNode = dataFlowNode;\n    }\n\n    @Override\n    public Node getNthParent(final int n) {\n        if (n <= 0) {\n            throw new IllegalArgumentException();\n        }\n        Node result = this.getParent();\n        for (int i = 1; i < n; i++) {\n            if (result == null) {\n                return null;\n            }\n            result = result.getParent();\n        }\n        return result;\n    }\n\n    @Override\n    public <T> T getFirstParentOfType(final Class<T> parentType) {\n        Node parentNode = getParent();\n        while (parentNode != null && !parentType.isInstance(parentNode)) {\n            parentNode = parentNode.getParent();\n        }\n        return parentType.cast(parentNode);\n    }\n\n    @Override\n    public <T> List<T> getParentsOfType(final Class<T> parentType) {\n        final List<T> parents = new ArrayList<>();\n        Node parentNode = getParent();\n        while (parentNode != null) {\n            if (parentType.isInstance(parentNode)) {\n                parents.add(parentType.cast(parentNode));\n            }\n            parentNode = parentNode.getParent();\n        }\n        return parents;\n    }\n\n    @SafeVarargs\n    @Override\n    @Deprecated\n    public final <T> T getFirstParentOfAnyType(final Class<? extends T>... parentTypes) {\n        Node parentNode = getParent();\n        while (parentNode != null) {\n            for (final Class<? extends T> c : parentTypes) {\n                if (c.isInstance(parentNode)) {\n                    return c.cast(parentNode);\n                }\n            }\n            parentNode = parentNode.getParent();\n        }\n        return null;\n    }\n\n    @Override\n    public <T> List<T> findDescendantsOfType(final Class<? extends T> targetType) {\n        final List<T> list = new ArrayList<>();\n        findDescendantsOfType(this, targetType, list, false);\n        return list;\n    }\n\n    @Override\n    public <T> List<T> findDescendantsOfType(final Class<T> targetType, final boolean crossBoundaries) {\n        final List<T> list = new ArrayList<>();\n        findDescendantsOfType(this, targetType, list, crossBoundaries);\n        return list;\n    }\n\n    \n    @Deprecated\n    @Override\n    public <T> void findDescendantsOfType(final Class<T> targetType, final List<T> results,\n                                          final boolean crossBoundaries) {\n        findDescendantsOfType(this, targetType, results, crossBoundaries);\n    }\n\n    private static <T> void findDescendantsOfType(final Node node, final Class<? extends T> targetType, final List<T> results,\n                                                  final boolean crossFindBoundaries) {\n\n        for (Node child : node.children()) {\n            if (targetType.isAssignableFrom(child.getClass())) {\n                results.add(targetType.cast(child));\n            }\n\n            if (crossFindBoundaries || !child.isFindBoundary()) {\n                findDescendantsOfType(child, targetType, results, crossFindBoundaries);\n            }\n        }\n    }\n\n    @Override\n    public <T> List<T> findChildrenOfType(final Class<T> targetType) {\n        final List<T> list = new ArrayList<>();\n        for (Node child : children()) {\n            if (targetType.isInstance(child)) {\n                list.add(targetType.cast(child));\n            }\n        }\n        return list;\n    }\n\n    @Override\n    public boolean isFindBoundary() {\n        return false;\n    }\n\n    @Override\n    @Deprecated\n    public Document getAsDocument() {\n        try {\n            final DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            final DocumentBuilder db = dbf.newDocumentBuilder();\n            final Document document = db.newDocument();\n            appendElement(document);\n            return document;\n        } catch (final ParserConfigurationException pce) {\n            throw new RuntimeException(pce);\n        }\n    }\n\n    protected void appendElement(final org.w3c.dom.Node parentNode) {\n        final DocumentNavigator docNav = new DocumentNavigator();\n        Document ownerDocument = parentNode.getOwnerDocument();\n        if (ownerDocument == null) {\n            \n            \n            ownerDocument = (Document) parentNode;\n        }\n        final String elementName = docNav.getElementName(this);\n        final Element element = ownerDocument.createElement(elementName);\n        parentNode.appendChild(element);\n        for (final Iterator<Attribute> iter = docNav.getAttributeAxisIterator(this); iter.hasNext();) {\n            final Attribute attr = iter.next();\n            element.setAttribute(attr.getName(), attr.getStringValue());\n        }\n        for (final Iterator<Node> iter = docNav.getChildAxisIterator(this); iter.hasNext();) {\n            final AbstractNode child = (AbstractNode) iter.next();\n            child.appendElement(element);\n        }\n    }\n\n    @Override\n    public <T> T getFirstDescendantOfType(final Class<T> descendantType) {\n        return getFirstDescendantOfType(descendantType, this);\n    }\n\n    @Override\n    public <T> T getFirstChildOfType(final Class<T> childType) {\n        for (Node child : children()) {\n            if (childType.isInstance(child)) {\n                return childType.cast(child);\n            }\n        }\n        return null;\n    }\n\n    private static <T> T getFirstDescendantOfType(final Class<T> descendantType, final Node node) {\n        for (Node n1 : node.children()) {\n            if (descendantType.isAssignableFrom(n1.getClass())) {\n                return descendantType.cast(n1);\n            }\n            if (!n1.isFindBoundary()) {\n                final T n2 = getFirstDescendantOfType(descendantType, n1);\n                if (n2 != null) {\n                    return n2;\n                }\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public final <T> boolean hasDescendantOfType(final Class<T> type) {\n        return getFirstDescendantOfType(type) != null;\n    }\n\n    \n    @Deprecated\n    public final boolean hasDecendantOfAnyType(final Class<?>... types) {\n        return hasDescendantOfAnyType(types);\n    }\n\n    \n    @Deprecated\n    public final boolean hasDescendantOfAnyType(final Class<?>... types) {\n        \n        \n        \n        \n        \n        for (final Class<?> type : types) {\n            if (hasDescendantOfType(type)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public List<Node> findChildNodesWithXPath(final String xpathString) throws JaxenException {\n        return new BaseXPath(xpathString, new ContextualizedNavigator(DeprecatedAttrLogger.createAdHocLogger()))\n                .selectNodes(this);\n    }\n\n    @Override\n    public boolean hasDescendantMatchingXPath(final String xpathString) {\n        try {\n            return !findChildNodesWithXPath(xpathString).isEmpty();\n        } catch (final JaxenException e) {\n            throw new RuntimeException(\"XPath expression \" + xpathString + \" failed: \" + e.getLocalizedMessage(), e);\n        }\n    }\n\n    @Override\n    @Deprecated\n    public Object getUserData() {\n        return userData.get(LEGACY_USER_DATA);\n    }\n\n    @Override\n    @Deprecated\n    public void setUserData(final Object userData) {\n        this.userData.set(LEGACY_USER_DATA, userData);\n    }\n\n    @Override\n    public DataMap<DataKey<?, ?>> getUserMap() {\n        return userData;\n    }\n\n    \n    @Deprecated\n    public GenericToken jjtGetFirstToken() {\n        return firstToken;\n    }\n\n    \n    @Deprecated\n    public void jjtSetFirstToken(final GenericToken token) {\n        this.firstToken = token;\n    }\n\n    \n    @Deprecated\n    public GenericToken jjtGetLastToken() {\n        return lastToken;\n    }\n\n    \n    @Deprecated\n    public void jjtSetLastToken(final GenericToken token) {\n        this.lastToken = token;\n    }\n\n\n    @Override\n    public Iterable<? extends Node> children() {\n        return new Iterable<Node>() {\n            @Override\n            public Iterator<Node> iterator() {\n                return childrenIterator(AbstractNode.this);\n            }\n        };\n    }\n\n\n    private static Iterator<Node> childrenIterator(final Node parent) {\n        assert parent != null : \"parent should not be null\";\n\n        final int numChildren = parent.getNumChildren();\n        if (numChildren == 0) {\n            return Collections.emptyIterator();\n        }\n\n        return new Iterator<Node>() {\n\n            private int i = 0;\n\n            @Override\n            public boolean hasNext() {\n                return i < numChildren;\n            }\n\n            @Override\n            public Node next() {\n                return parent.getChild(i++);\n            }\n\n            @Override\n            public void remove() {\n                throw new UnsupportedOperationException(\"Remove\");\n            }\n        };\n    }\n\n    \n    @Deprecated\n    @InternalApi\n    @Override\n    public void remove() {\n        \n        final Node parent = getParent();\n        if (parent != null) {\n            parent.removeChildAtIndex(getIndexInParent());\n            jjtSetParent(null);\n        }\n\n        \n    }\n\n    \n    @Deprecated\n    @InternalApi\n    @Override\n    public void removeChildAtIndex(final int childIndex) {\n        if (0 <= childIndex && childIndex < getNumChildren()) {\n            \n            children = ArrayUtils.remove(children, childIndex);\n            \n            for (int i = childIndex; i < getNumChildren(); i++) {\n                getChild(i).jjtSetChildIndex(i);\n            }\n        }\n    }\n\n    \n    @Override\n    \n    public String getXPathNodeName() {\n        LOG.warning(\"getXPathNodeName should be overridden in classes derived from AbstractNode. \"\n                + \"The implementation is provided for compatibility with existing implementors,\"\n                + \"but could be declared abstract as soon as release \" + PMDVersion.getNextMajorRelease()\n                + \".\");\n        return toString();\n    }\n\n    \n    @Deprecated\n    @Override\n    public String toString() {\n        return getXPathNodeName();\n    }\n\n    @Override\n    public Iterator<Attribute> getXPathAttributesIterator() {\n        return new AttributeAxisIterator(this);\n    }\n}\n"
    ],
    "1": [
        "package net.sourceforge.pmd.lang.ast;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.logging.Logger;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.jaxen.BaseXPath;\nimport org.jaxen.JaxenException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\n\nimport net.sourceforge.pmd.PMDVersion;\nimport net.sourceforge.pmd.annotation.InternalApi;\nimport net.sourceforge.pmd.lang.ast.xpath.Attribute;\nimport net.sourceforge.pmd.lang.ast.xpath.AttributeAxisIterator;\nimport net.sourceforge.pmd.lang.ast.xpath.DocumentNavigator;\nimport net.sourceforge.pmd.lang.ast.xpath.internal.ContextualizedNavigator;\nimport net.sourceforge.pmd.lang.ast.xpath.internal.DeprecatedAttrLogger;\nimport net.sourceforge.pmd.lang.dfa.DataFlowNode;\nimport net.sourceforge.pmd.util.DataMap;\nimport net.sourceforge.pmd.util.DataMap.DataKey;\nimport net.sourceforge.pmd.util.DataMap.SimpleDataKey;\n\npublic abstract class AbstractNode implements Node {\n\n    private static final Logger LOG = Logger.getLogger(AbstractNode.class.getName());\n    private static final SimpleDataKey<Object> LEGACY_USER_DATA = DataMap.simpleDataKey(\"legacy user data\");\n    private final DataMap<DataKey<?, ?>> userData = DataMap.newDataMap();\n\n    @Deprecated\n    protected Node parent;\n    @Deprecated\n    protected Node[] children;\n    \n    @Deprecated\n    protected int childIndex;\n    @Deprecated\n    protected int id;\n    @Deprecated\n    protected int beginLine = -1;\n    @Deprecated\n    protected int endLine;\n    @Deprecated\n    protected int beginColumn = -1;\n    @Deprecated\n    protected int endColumn;\n    @Deprecated\n    protected GenericToken firstToken;\n    @Deprecated\n    protected GenericToken lastToken;\n    private DataFlowNode dataFlowNode;\n    private String image;\n\n    public AbstractNode(final int id) {\n        this.id = id;\n    }\n\n    public AbstractNode(final int id, final int theBeginLine, final int theEndLine, final int theBeginColumn,\n                        final int theEndColumn) {\n        this(id);\n        beginLine = theBeginLine;\n        endLine = theEndLine;\n        beginColumn = theBeginColumn;\n        endColumn = theEndColumn;\n    }\n\n    @Override\n    public Node getParent() {\n        return jjtGetParent();\n    }\n\n    @Override\n    public int getIndexInParent() {\n        return jjtGetChildIndex();\n    }\n\n    @Override\n    public Node getChild(final int index) {\n        if (children == null) {\n            throw new IndexOutOfBoundsException();\n        }\n        return children[index];\n    }\n\n    @Override\n    public int getNumChildren() {\n        return jjtGetNumChildren();\n    }\n\n    @Deprecated\n    public boolean isSingleLine() {\n        return beginLine == endLine;\n    }\n\n    @Override\n    @Deprecated\n    @InternalApi\n    public void jjtOpen() {}\n\n    @Override\n    @Deprecated\n    @InternalApi\n    public void jjtClose() {}\n\n    @Override\n    @Deprecated\n    @InternalApi\n    public void jjtSetParent(final Node parent) {\n        this.parent = parent;\n    }\n\n    @Override\n    @Deprecated\n    public Node jjtGetParent() {\n        return parent;\n    }\n\n    @Override\n    @Deprecated\n    @InternalApi\n    public void jjtAddChild(final Node child, final int index) {\n        if (children == null) {\n            children = new Node[index + 1];\n        } else if (index >= children.length) {\n            final Node[] newChildren = new Node[index + 1];\n            System.arraycopy(children, 0, newChildren, 0, children.length);\n            children = newChildren;\n        }\n        children[index] = child;\n        child.jjtSetChildIndex(index);\n    }\n\n    @Override\n    @Deprecated\n    @InternalApi\n    public void jjtSetChildIndex(final int index) {\n        childIndex = index;\n    }\n\n    @Override\n    @Deprecated\n    public int jjtGetChildIndex() {\n        return childIndex;\n    }\n\n    @Override\n    @Deprecated\n    public Node jjtGetChild(final int index) {\n        return children[index];\n    }\n\n    @Override\n    @Deprecated\n    public int jjtGetNumChildren() {\n        return children == null ? 0 : children.length;\n    }\n\n    @Override\n    @Deprecated\n    public int jjtGetId() {\n        return id;\n    }\n\n    @Override\n    public String getImage() {\n        return image;\n    }\n\n    @Override\n    @Deprecated\n    public void setImage(final String image) {\n        this.image = image;\n    }\n\n    @Override\n    public boolean hasImageEqualTo(final String image) {\n        return Objects.equals(this.getImage(), image);\n    }\n\n    @Override\n    public int getBeginLine() {\n        return beginLine;\n    }\n\n    @Deprecated\n    @InternalApi\n    public void testingOnlySetBeginLine(int i) {\n        this.beginLine = i;\n    }\n\n    @Override\n    public int getBeginColumn() {\n        if (beginColumn == -1) {\n            if (children != null && children.length > 0) {\n                return children[0].getBeginColumn();\n            } else {\n                throw new RuntimeException(\"Unable to determine beginning line of Node.\");\n            }\n        } else {\n            return beginColumn;\n        }\n    }\n\n    @Deprecated\n    @InternalApi\n    public void testingOnlySetBeginColumn(final int i) {\n        this.beginColumn = i;\n    }\n\n    @Override\n    public int getEndLine() {\n        return endLine;\n    }\n\n    @Deprecated\n    @InternalApi\n    public void testingOnlySetEndLine(final int i) {\n        this.endLine = i;\n    }\n\n    @Override\n    public int getEndColumn() {\n        return endColumn;\n    }\n\n    @Deprecated\n    @InternalApi\n    public void testingOnlySetEndColumn(final int i) {\n        this.endColumn = i;\n    }\n\n    @Override\n    public DataFlowNode getDataFlowNode() {\n        if (this.dataFlowNode == null) {\n            if (this.parent != null) {\n                return parent.getDataFlowNode();\n            }\n            return null; \n        }\n        return dataFlowNode;\n    }\n\n    @Override\n    public void setDataFlowNode(final DataFlowNode dataFlowNode) {\n        this.dataFlowNode = dataFlowNode;\n    }\n\n    @Override\n    public Node getNthParent(final int n) {\n        if (n <= 0) {\n            throw new IllegalArgumentException();\n        }\n        Node result = this.getParent();\n        for (int i = 1; i < n; i++) {\n            if (result == null) {\n                return null;\n            }\n            result = result.getParent();\n        }\n        return result;\n    }\n\n    @Override\n    public <T> T getFirstParentOfType(final Class<T> parentType) {\n        Node parentNode = getParent();\n        while (parentNode != null && !parentType.isInstance(parentNode)) {\n            parentNode = parentNode.getParent();\n        }\n        return parentType.cast(parentNode);\n    }\n\n    @Override\n    public <T> List<T> getParentsOfType(final Class<T> parentType) {\n        final List<T> parents = new ArrayList<>();\n        Node parentNode = getParent();\n        while (parentNode != null) {\n            if (parentType.isInstance(parentNode)) {\n                parents.add(parentType.cast(parentNode));\n            }\n            parentNode = parentNode.getParent();\n        }\n        return parents;\n    }\n\n    @SafeVarargs\n    @Override\n    @Deprecated\n    public final <T> T getFirstParentOfAnyType(final Class<? extends T>... parentTypes) {\n        Node parentNode = getParent();\n        while (parentNode != null) {\n            for (final Class<? extends T> c : parentTypes) {\n                if (c.isInstance(parentNode)) {\n                    return c.cast(parentNode);\n                }\n            }\n            parentNode = parentNode.getParent();\n        }\n        return null;\n    }\n\n    @Override\n    public <T> List<T> findDescendantsOfType(final Class<? extends T> targetType) {\n        final List<T> list = new ArrayList<>();\n        findDescendantsOfType(this, targetType, list, false);\n        return list;\n    }\n\n    @Override\n    public <T> List<T> findDescendantsOfType(final Class<T> targetType, final boolean crossBoundaries) {\n        final List<T> list = new ArrayList<>();\n        findDescendantsOfType(this, targetType, list, crossBoundaries);\n        return list;\n    }\n\n    @Deprecated\n    @Override\n    public <T> void findDescendantsOfType(final Class<T> targetType, final List<T> results,\n                                          final boolean crossBoundaries) {\n        findDescendantsOfType(this, targetType, results, crossBoundaries);\n    }\n\n    private static <T> void findDescendantsOfType(final Node node, final Class<? extends T> targetType, final List<T> results,\n                                                  final boolean crossFindBoundaries) {\n        Iterator<? extends Node> childIterator = node.children().iterator();\n        while (childIterator.hasNext()) {\n            Node child = childIterator.next();\n            if (targetType.isAssignableFrom(child.getClass())) {\n                results.add(targetType.cast(child));\n            }\n\n            if (crossFindBoundaries || !child.isFindBoundary()) {\n                findDescendantsOfType(child, targetType, results, crossFindBoundaries);\n            }\n        }\n    }\n\n    @Override\n    public <T> List<T> findChildrenOfType(final Class<T> targetType) {\n        final List<T> list = new ArrayList<>();\n        Iterator<? extends Node> childIterator = children().iterator();\n        while (childIterator.hasNext()) {\n            Node child = childIterator.next();\n            if (targetType.isInstance(child)) {\n                list.add(targetType.cast(child));\n            }\n        }\n        return list;\n    }\n\n    @Override\n    public boolean isFindBoundary() {\n        return false;\n    }\n\n    @Override\n    @Deprecated\n    public Document getAsDocument() {\n        try {\n            final DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            final DocumentBuilder db = dbf.newDocumentBuilder();\n            final Document document = db.newDocument();\n            appendElement(document);\n            return document;\n        } catch (final ParserConfigurationException pce) {\n            throw new RuntimeException(pce);\n        }\n    }\n\n    protected void appendElement(final org.w3c.dom.Node parentNode) {\n        final DocumentNavigator docNav = new DocumentNavigator();\n        Document ownerDocument = parentNode.getOwnerDocument();\n        if (ownerDocument == null) {\n            ownerDocument = (Document) parentNode;\n        }\n        final String elementName = docNav.getElementName(this);\n        final Element element = ownerDocument.createElement(elementName);\n        parentNode.appendChild(element);\n\n        Iterator<Attribute> attributeIterator = docNav.getAttributeAxisIterator(this);\n        while (attributeIterator.hasNext()) {\n            final Attribute attr = attributeIterator.next();\n            element.setAttribute(attr.getName(), attr.getStringValue());\n        }\n\n        Iterator<Node> childIterator = docNav.getChildAxisIterator(this);\n        while (childIterator.hasNext()) {\n            final AbstractNode child = (AbstractNode) childIterator.next();\n            child.appendElement(element);\n        }\n    }\n\n    @Override\n    public <T> T getFirstDescendantOfType(final Class<T> descendantType) {\n        return getFirstDescendantOfType(descendantType, this);\n    }\n\n    @Override\n    public <T> T getFirstChildOfType(final Class<T> childType) {\n        Iterator<? extends Node> childIterator = children().iterator();\n        while (childIterator.hasNext()) {\n            Node child = childIterator.next();\n            if (childType.isInstance(child)) {\n                return childType.cast(child);\n            }\n        }\n        return null;\n    }\n\n    private static <T> T getFirstDescendantOfType(final Class<T> descendantType, final Node node) {\n        Iterator<? extends Node> childIterator = node.children().iterator();\n        while (childIterator.hasNext()) {\n            Node n1 = childIterator.next();\n            if (descendantType.isAssignableFrom(n1.getClass())) {\n                return descendantType.cast(n1);\n            }\n            if (!n1.isFindBoundary()) {\n                final T n2 = getFirstDescendantOfType(descendantType, n1);\n                if (n2 != null) {\n                    return n2;\n                }\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public final <T> boolean hasDescendantOfType(final Class<T> type) {\n        return getFirstDescendantOfType(type) != null;\n    }\n\n    @Deprecated\n    public final boolean hasDecendantOfAnyType(final Class<?>... types) {\n        return hasDescendantOfAnyType(types);\n    }\n\n    @Deprecated\n    public final boolean hasDescendantOfAnyType(final Class<?>... types) {\n        for (final Class<?> type : types) {\n            if (hasDescendantOfType(type)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public List<Node> findChildNodesWithXPath(final String xpathString) throws JaxenException {\n        return new BaseXPath(xpathString, new ContextualizedNavigator(DeprecatedAttrLogger.createAdHocLogger()))\n                .selectNodes(this);\n    }\n\n    @Override\n    public boolean hasDescendantMatchingXPath(final String xpathString) {\n        try {\n            return !findChildNodesWithXPath(xpathString).isEmpty();\n        } catch (final JaxenException e) {\n            throw new RuntimeException(\"XPath expression \" + xpathString + \" failed: \" + e.getLocalizedMessage(), e);\n        }\n    }\n\n    @Override\n    @Deprecated\n    public Object getUserData() {\n        return userData.get(LEGACY_USER_DATA);\n    }\n\n    @Override\n    @Deprecated\n    public void setUserData(final Object userData) {\n        this.userData.set(LEGACY_USER_DATA, userData);\n    }\n\n    @Override\n    public DataMap<DataKey<?, ?>> getUserMap() {\n        return userData;\n    }\n\n    @Deprecated\n    public GenericToken jjtGetFirstToken() {\n        return firstToken;\n    }\n\n    @Deprecated\n    public void jjtSetFirstToken(final GenericToken token) {\n        this.firstToken = token;\n    }\n\n    @Deprecated\n    public GenericToken jjtGetLastToken() {\n        return lastToken;\n    }\n\n    @Deprecated\n    public void jjtSetLastToken(final GenericToken token) {\n        this.lastToken = token;\n    }\n\n    @Override\n    public Iterable<? extends Node> children() {\n        return new Iterable<Node>() {\n            @Override\n            public Iterator<Node> iterator() {\n                return childrenIterator(AbstractNode.this);\n            }\n        };\n    }\n\n    private static Iterator<Node> childrenIterator(final Node parent) {\n        assert parent != null : \"parent should not be null\";\n\n        final int numChildren = parent.getNumChildren();\n        if (numChildren == 0) {\n            return Collections.emptyIterator();\n        }\n\n        return new Iterator<Node>() {\n\n            private int i = 0;\n\n            @Override\n            public boolean hasNext() {\n                return i < numChildren;\n            }\n\n            @Override\n            public Node next() {\n                return parent.getChild(i++);\n            }\n\n            @Override\n            public void remove() {\n                throw new UnsupportedOperationException(\"Remove\");\n            }\n        };\n    }\n\n    @Deprecated\n    @InternalApi\n    @Override\n    public void remove() {\n        final Node parent = getParent();\n        if (parent != null) {\n            parent.removeChildAtIndex(getIndexInParent());\n            jjtSetParent(null);\n        }\n    }\n\n    @Deprecated\n    @InternalApi\n    @Override\n    public void removeChildAtIndex(final int childIndex) {\n        if (0 <= childIndex && childIndex < getNumChildren()) {\n            Node[] newChildren = new Node[getNumChildren() - 1];\n            System.arraycopy(children, 0, newChildren, 0, childIndex);\n            System.arraycopy(children, childIndex + 1, newChildren, childIndex, getNumChildren() - childIndex - 1);\n            children = newChildren;\n            for (int i = childIndex; i < getNumChildren(); i++) {\n                getChild(i).jjtSetChildIndex(i);\n            }\n        }\n    }\n\n    @Override\n    public String getXPathNodeName() {\n        LOG.warning(\"getXPathNodeName should be overridden in classes derived from AbstractNode. \"\n                + \"The implementation is provided for compatibility with existing implementors,\" +\n                \"but could be declared abstract as soon as release \" + PMDVersion.getNextMajorRelease()\n                + \".\");\n        return toString();\n    }\n\n    @Deprecated\n    @Override\n    public String toString() {\n        return getXPathNodeName();\n    }\n\n    @Override\n    public Iterator<Attribute> getXPathAttributesIterator() {\n        return new AttributeAxisIterator(this);\n    }\n}"
    ],
    "2": [
        "package net.sourceforge.pmd.lang.ast;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.logging.Logger;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.jaxen.BaseXPath;\nimport org.jaxen.JaxenException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\n\nimport net.sourceforge.pmd.PMDVersion;\nimport net.sourceforge.pmd.annotation.InternalApi;\nimport net.sourceforge.pmd.lang.ast.xpath.Attribute;\nimport net.sourceforge.pmd.lang.ast.xpath.AttributeAxisIterator;\nimport net.sourceforge.pmd.lang.ast.xpath.DocumentNavigator;\nimport net.sourceforge.pmd.lang.ast.xpath.internal.ContextualizedNavigator;\nimport net.sourceforge.pmd.lang.ast.xpath.internal.DeprecatedAttrLogger;\nimport net.sourceforge.pmd.lang.dfa.DataFlowNode;\nimport net.sourceforge.pmd.util.DataMap;\nimport net.sourceforge.pmd.util.DataMap.DataKey;\nimport net.sourceforge.pmd.util.DataMap.SimpleDataKey;\n\npublic abstract class AbstractNode implements Node {\n\n    private static final Logger LOG = Logger.getLogger(AbstractNode.class.getName());\n    private static final SimpleDataKey<Object> LEGACY_USER_DATA = DataMap.simpleDataKey(\"legacy user data\");\n    private final DataMap<DataKey<?, ?>> userData = DataMap.newDataMap();\n\n    protected Node parent;\n    protected List<Node> children = new ArrayList<>();\n    protected int childIndex;\n    protected int id;\n    protected int beginLine = -1;\n    protected int endLine;\n    protected int beginColumn = -1;\n    protected int endColumn;\n    protected GenericToken firstToken;\n    protected GenericToken lastToken;\n    private DataFlowNode dataFlowNode;\n    private String image;\n\n    public AbstractNode(final int id) {\n        this.id = id;\n    }\n\n    public AbstractNode(final int id, final int theBeginLine, final int theEndLine, final int theBeginColumn,\n                        final int theEndColumn) {\n        this(id);\n        beginLine = theBeginLine;\n        endLine = theEndLine;\n        beginColumn = theBeginColumn;\n        endColumn = theEndColumn;\n    }\n\n    @Override\n    public Node getParent() {\n        return parent;\n    }\n\n    @Override\n    public int getIndexInParent() {\n        return childIndex;\n    }\n\n    @Override\n    public Node getChild(final int index) {\n        if (children == null || children.isEmpty()) {\n            throw new IndexOutOfBoundsException();\n        }\n        return children.get(index);\n    }\n\n    @Override\n    public int getNumChildren() {\n        return children.size();\n    }\n\n    public boolean isSingleLine() {\n        return beginLine == endLine;\n    }\n\n    @Override\n    @InternalApi\n    public void jjtOpen() {}\n\n    @Override\n    @InternalApi\n    public void jjtClose() {}\n\n    @Override\n    @InternalApi\n    public void jjtSetParent(final Node parent) {\n        this.parent = parent;\n    }\n\n    @Override\n    public Node jjtGetParent() {\n        return parent;\n    }\n\n    @Override\n    @InternalApi\n    public void jjtAddChild(final Node child, final int index) {\n        while (children.size() <= index) {\n            children.add(null);\n        }\n        children.set(index, child);\n        child.jjtSetChildIndex(index);\n    }\n\n    @Override\n    @InternalApi\n    public void jjtSetChildIndex(final int index) {\n        childIndex = index;\n    }\n\n    @Override\n    public int jjtGetChildIndex() {\n        return childIndex;\n    }\n\n    @Override\n    public Node jjtGetChild(final int index) {\n        return children.get(index);\n    }\n\n    @Override\n    public int jjtGetNumChildren() {\n        return children.size();\n    }\n\n    @Override\n    public int jjtGetId() {\n        return id;\n    }\n\n    @Override\n    public String getImage() {\n        return image;\n    }\n\n    @Override\n    public void setImage(final String image) {\n        this.image = image;\n    }\n\n    @Override\n    public boolean hasImageEqualTo(final String image) {\n        return Objects.equals(this.getImage(), image);\n    }\n\n    @Override\n    public int getBeginLine() {\n        return beginLine;\n    }\n\n    @InternalApi\n    public void testingOnlySetBeginLine(int i) {\n        this.beginLine = i;\n    }\n\n    @Override\n    public int getBeginColumn() {\n        if (beginColumn == -1) {\n            if (children != null && !children.isEmpty()) {\n                return children.get(0).getBeginColumn();\n            } else {\n                throw new RuntimeException(\"Unable to determine beginning line of Node.\");\n            }\n        } else {\n            return beginColumn;\n        }\n    }\n\n    @InternalApi\n    public void testingOnlySetBeginColumn(final int i) {\n        this.beginColumn = i;\n    }\n\n    @Override\n    public int getEndLine() {\n        return endLine;\n    }\n\n    @InternalApi\n    public void testingOnlySetEndLine(final int i) {\n        this.endLine = i;\n    }\n\n    @Override\n    public int getEndColumn() {\n        return endColumn;\n    }\n\n    @InternalApi\n    public void testingOnlySetEndColumn(final int i) {\n        this.endColumn = i;\n    }\n\n    @Override\n    public DataFlowNode getDataFlowNode() {\n        if (this.dataFlowNode == null) {\n            if (this.parent != null) {\n                return parent.getDataFlowNode();\n            }\n            return null; \n        }\n        return dataFlowNode;\n    }\n\n    @Override\n    public void setDataFlowNode(final DataFlowNode dataFlowNode) {\n        this.dataFlowNode = dataFlowNode;\n    }\n\n    @Override\n    public Node getNthParent(final int n) {\n        if (n <= 0) {\n            throw new IllegalArgumentException();\n        }\n        Node result = this.getParent();\n        for (int i = 1; i < n; i++) {\n            if (result == null) {\n                return null;\n            }\n            result = result.getParent();\n        }\n        return result;\n    }\n\n    @Override\n    public <T> T getFirstParentOfType(final Class<T> parentType) {\n        Node parentNode = getParent();\n        while (parentNode != null && !parentType.isInstance(parentNode)) {\n            parentNode = parentNode.getParent();\n        }\n        return parentType.cast(parentNode);\n    }\n\n    @Override\n    public <T> List<T> getParentsOfType(final Class<T> parentType) {\n        final List<T> parents = new ArrayList<>();\n        Node parentNode = getParent();\n        while (parentNode != null) {\n            if (parentType.isInstance(parentNode)) {\n                parents.add(parentType.cast(parentNode));\n            }\n            parentNode = parentNode.getParent();\n        }\n        return parents;\n    }\n\n    @SafeVarargs\n    @Override\n    public final <T> T getFirstParentOfAnyType(final Class<? extends T>... parentTypes) {\n        Node parentNode = getParent();\n        while (parentNode != null) {\n            for (final Class<? extends T> c : parentTypes) {\n                if (c.isInstance(parentNode)) {\n                    return c.cast(parentNode);\n                }\n            }\n            parentNode = parentNode.getParent();\n        }\n        return null;\n    }\n\n    @Override\n    public <T> List<T> findDescendantsOfType(final Class<? extends T> targetType) {\n        final List<T> list = new ArrayList<>();\n        findDescendantsOfType(this, targetType, list, false);\n        return list;\n    }\n\n    @Override\n    public <T> List<T> findDescendantsOfType(final Class<T> targetType, final boolean crossBoundaries) {\n        final List<T> list = new ArrayList<>();\n        findDescendantsOfType(this, targetType, list, crossBoundaries);\n        return list;\n    }\n\n    public <T> void findDescendantsOfType(final Class<T> targetType, final List<T> results,\n                                          final boolean crossBoundaries) {\n        findDescendantsOfType(this, targetType, results, crossBoundaries);\n    }\n\n    private static <T> void findDescendantsOfType(final Node node, final Class<? extends T> targetType, final List<T> results,\n                                                  final boolean crossFindBoundaries) {\n        for (Node child : node.children()) {\n            if (targetType.isAssignableFrom(child.getClass())) {\n                results.add(targetType.cast(child));\n            }\n\n            if (crossFindBoundaries || !child.isFindBoundary()) {\n                findDescendantsOfType(child, targetType, results, crossFindBoundaries);\n            }\n        }\n    }\n\n    @Override\n    public <T> List<T> findChildrenOfType(final Class<T> targetType) {\n        final List<T> list = new ArrayList<>();\n        for (Node child : children()) {\n            if (targetType.isInstance(child)) {\n                list.add(targetType.cast(child));\n            }\n        }\n        return list;\n    }\n\n    @Override\n    public boolean isFindBoundary() {\n        return false;\n    }\n\n    @Override\n    public Document getAsDocument() {\n        try {\n            final DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            final DocumentBuilder db = dbf.newDocumentBuilder();\n            final Document document = db.newDocument();\n            appendElement(document);\n            return document;\n        } catch (final ParserConfigurationException pce) {\n            throw new RuntimeException(pce);\n        }\n    }\n\n    protected void appendElement(final org.w3c.dom.Node parentNode) {\n        final DocumentNavigator docNav = new DocumentNavigator();\n        Document ownerDocument = parentNode.getOwnerDocument();\n        if (ownerDocument == null) {\n            ownerDocument = (Document) parentNode;\n        }\n        final String elementName = docNav.getElementName(this);\n        final Element element = ownerDocument.createElement(elementName);\n        parentNode.appendChild(element);\n\n        Iterator<Attribute> attributeIterator = docNav.getAttributeAxisIterator(this);\n        while (attributeIterator.hasNext()) {\n            final Attribute attr = attributeIterator.next();\n            element.setAttribute(attr.getName(), attr.getStringValue());\n        }\n\n        Iterator<Node> childIterator = docNav.getChildAxisIterator(this);\n        while (childIterator.hasNext()) {\n            final AbstractNode child = (AbstractNode) childIterator.next();\n            child.appendElement(element);\n        }\n    }\n\n    @Override\n    public <T> T getFirstDescendantOfType(final Class<T> descendantType) {\n        return getFirstDescendantOfType(descendantType, this);\n    }\n\n    @Override\n    public <T> T getFirstChildOfType(final Class<T> childType) {\n        for (Node child : children()) {\n            if (childType.isInstance(child)) {\n                return childType.cast(child);\n            }\n        }\n        return null;\n    }\n\n    private static <T> T getFirstDescendantOfType(final Class<T> descendantType, final Node node) {\n        for (Node n1 : node.children()) {\n            if (descendantType.isAssignableFrom(n1.getClass())) {\n                return descendantType.cast(n1);\n            }\n            if (!n1.isFindBoundary()) {\n                final T n2 = getFirstDescendantOfType(descendantType, n1);\n                if (n2 != null) {\n                    return n2;\n                }\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public final <T> boolean hasDescendantOfType(final Class<T> type) {\n        return getFirstDescendantOfType(type) != null;\n    }\n\n    public final boolean hasDecendantOfAnyType(final Class<?>... types) {\n        return hasDescendantOfAnyType(types);\n    }\n\n    public final boolean hasDescendantOfAnyType(final Class<?>... types) {\n        for (final Class<?> type : types) {\n            if (hasDescendantOfType(type)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public List<Node> findChildNodesWithXPath(final String xpathString) throws JaxenException {\n        return new BaseXPath(xpathString, new ContextualizedNavigator(DeprecatedAttrLogger.createAdHocLogger()))\n                .selectNodes(this);\n    }\n\n    @Override\n    public boolean hasDescendantMatchingXPath(final String xpathString) {\n        try {\n            return !findChildNodesWithXPath(xpathString).isEmpty();\n        } catch (final JaxenException e) {\n            throw new RuntimeException(\"XPath expression \" + xpathString + \" failed: \" + e.getLocalizedMessage(), e);\n        }\n    }\n\n    @Override\n    public Object getUserData() {\n        return userData.get(LEGACY_USER_DATA);\n    }\n\n    @Override\n    public void setUserData(final Object userData) {\n        this.userData.set(LEGACY_USER_DATA, userData);\n    }\n\n    @Override\n    public DataMap<DataKey<?, ?>> getUserMap() {\n        return userData;\n    }\n\n    public GenericToken jjtGetFirstToken() {\n        return firstToken;\n    }\n\n    public void jjtSetFirstToken(final GenericToken token) {\n        this.firstToken = token;\n    }\n\n    public GenericToken jjtGetLastToken() {\n        return lastToken;\n    }\n\n    public void jjtSetLastToken(final GenericToken token) {\n        this.lastToken = token;\n    }\n\n    @Override\n    public Iterable<? extends Node> children() {\n        return children;\n    }\n\n    private static Iterator<Node> childrenIterator(final Node parent) {\n        assert parent != null : \"parent should not be null\";\n\n        final int numChildren = parent.getNumChildren();\n        if (numChildren == 0) {\n            return Collections.emptyIterator();\n        }\n\n        return new Iterator<Node>() {\n\n            private int i = 0;\n\n            @Override\n            public boolean hasNext() {\n                return i < numChildren;\n            }\n\n            @Override\n            public Node next() {\n                return parent.getChild(i++);\n            }\n\n            @Override\n            public void remove() {\n                throw new UnsupportedOperationException(\"Remove\");\n            }\n        };\n    }\n\n    @InternalApi\n    @Override\n    public void remove() {\n        final Node parent = getParent();\n        if (parent != null) {\n            parent.removeChildAtIndex(getIndexInParent());\n            jjtSetParent(null);\n        }\n    }\n\n    @InternalApi\n    @Override\n    public void removeChildAtIndex(final int childIndex) {\n        if (0 <= childIndex && childIndex < getNumChildren()) {\n            children.remove(childIndex);\n            for (int i = childIndex; i < getNumChildren(); i++) {\n                getChild(i).jjtSetChildIndex(i);\n            }\n        }\n    }\n\n    @Override\n    public String getXPathNodeName() {\n        LOG.warning(\"getXPathNodeName should be overridden in classes derived from AbstractNode. \"\n                + \"The implementation is provided for compatibility with existing implementors,\" +\n                \"but could be declared abstract as soon as release \" + PMDVersion.getNextMajorRelease()\n                + \".\");\n        return toString();\n    }\n\n    @Override\n    public String toString() {\n        return getXPathNodeName();\n    }\n\n    @Override\n    public Iterator<Attribute> getXPathAttributesIterator() {\n        return new AttributeAxisIterator(this);\n    }\n}\n"
    ]
}