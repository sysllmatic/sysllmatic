{
    "0": [
        "\n\npackage net.sourceforge.pmd.util;\n\nimport java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FilterInputStream;\nimport java.io.FilterOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.nio.ByteBuffer;\nimport java.nio.CharBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetDecoder;\nimport java.nio.charset.CharsetEncoder;\nimport java.nio.charset.CodingErrorAction;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.charset.UnsupportedCharsetException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Objects;\n\nimport org.apache.commons.lang3.StringUtils;\n\nimport net.sourceforge.pmd.annotation.InternalApi;\n\n\n@InternalApi\n@Deprecated\npublic final class IOUtil {\n\n    private static final int BUFFER_SIZE = 8192;\n\n    private IOUtil() {\n    }\n\n    \n    public static Writer createWriter() {\n        return createWriter(null);\n    }\n\n    \n    private static Charset getDefaultCharset() {\n        String csn = AccessController.doPrivileged(new PrivilegedAction<String>() {\n            @Override\n            public String run() {\n                return System.getProperty(\"file.encoding\");\n            }\n        });\n        try {\n            return Charset.forName(csn);\n        } catch (UnsupportedCharsetException e) {\n            return StandardCharsets.UTF_8;\n        }\n    }\n\n    \n    public static Writer createWriter(String reportFile) {\n        return createWriter(getDefaultCharset(), reportFile);\n    }\n\n    \n    public static Writer createWriter(Charset charset, String reportFile) {\n        try {\n            if (StringUtils.isBlank(reportFile)) {\n                return new OutputStreamWriter(new FilterOutputStream(System.out) {\n                    @Override\n                    public void close() {\n                        \n                    }\n                }, charset);\n            }\n            Path path = new File(reportFile).toPath().toAbsolutePath();\n            Files.createDirectories(path.getParent()); \n            \n            return Files.newBufferedWriter(path, charset);\n        } catch (IOException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }\n\n    public static Reader skipBOM(Reader source) {\n        Reader in = new BufferedReader(source);\n        try {\n            in.mark(1);\n            int firstCharacter = in.read();\n            if (firstCharacter != '\\ufeff') {\n                in.reset();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(\"Error while trying to skip BOM marker\", e);\n        }\n        return in;\n    }\n\n    public static void tryCloseClassLoader(ClassLoader classLoader) {\n        if (classLoader instanceof Closeable) {\n            closeQuietly((Closeable) classLoader);\n        }\n    }\n\n    \n    @SuppressWarnings(\"PMD.CloseResource\") \n    public static IOException closeAll(Collection<? extends AutoCloseable> closeables) {\n        IOException composed = null;\n        for (AutoCloseable it : closeables) {\n            try {\n                it.close();\n            } catch (Exception e) {\n                if (composed == null) {\n                    composed = new IOException(\"Cannot close resource \" + it, e);\n                } else {\n                    composed.addSuppressed(e);\n                }\n            }\n        }\n        return composed;\n    }\n\n    \n    public static void ensureClosed(List<? extends AutoCloseable> toClose,\n                                    Exception pendingException) throws Exception {\n        Exception closeException = closeAll(toClose);\n        if (closeException != null) {\n            if (pendingException != null) {\n                closeException.addSuppressed(pendingException);\n                throw closeException;\n            }\n            \n        } else if (pendingException != null) {\n            throw pendingException;\n        }\n    }\n\n\n    \n    \n    \n    \n    \n\n    public static void closeQuietly(Closeable closeable) {\n        try {\n            closeable.close();\n        } catch (IOException ignored) {\n            \n        }\n    }\n\n    public static byte[] toByteArray(InputStream stream) throws IOException {\n        byte[] result = new byte[0];\n        byte[] buffer = new byte[BUFFER_SIZE];\n        int count = stream.read(buffer);\n        while (count > -1) {\n            byte[] newResult = new byte[result.length + count];\n            System.arraycopy(result, 0, newResult, 0, result.length);\n            System.arraycopy(buffer, 0, newResult, result.length, count);\n            result = newResult;\n            count = stream.read(buffer);\n        }\n        return result;\n    }\n\n    public static long skipFully(InputStream stream, long n) throws IOException {\n        if (n < 0) {\n            throw new IllegalArgumentException();\n        }\n\n        long bytesToSkip = n;\n        byte[] buffer = new byte[(int) Math.min(BUFFER_SIZE, bytesToSkip)];\n        while (bytesToSkip > 0) {\n            int count = stream.read(buffer, 0, (int) Math.min(BUFFER_SIZE, bytesToSkip));\n            if (count < 0) {\n                \n                break;\n            }\n            bytesToSkip -= count;\n        }\n        return n - bytesToSkip;\n    }\n\n    public static String normalizePath(String path) {\n        Path path1 = Paths.get(path);\n        path1.isAbsolute();\n        String normalized = path1.normalize().toString();\n        if (normalized.contains(\".\" + File.separator) || normalized.contains(\"..\" + File.separator) || \"\".equals(normalized)) {\n            return null;\n        }\n        return normalized;\n    }\n\n    public static boolean equalsNormalizedPaths(String path1, String path2) {\n        return Objects.equals(normalizePath(path1), normalizePath(path2));\n    }\n\n    public static String getFilenameExtension(String name) {\n        String filename = Paths.get(name).getFileName().toString();\n        int dot = filename.lastIndexOf('.');\n        if (dot > -1) {\n            return filename.substring(dot + 1);\n        }\n        return \"\";\n    }\n\n    public static String getFilenameBase(String name) {\n        String filename = Paths.get(name).getFileName().toString();\n        int dot = filename.lastIndexOf('.');\n        if (dot > -1) {\n            return filename.substring(0, dot);\n        }\n        return filename;\n    }\n\n    public static void copy(InputStream from, OutputStream to) throws IOException {\n        byte[] buffer = new byte[BUFFER_SIZE];\n        int count = from.read(buffer);\n        while (count > -1) {\n            to.write(buffer, 0, count);\n            count = from.read(buffer);\n        }\n    }\n\n    public static void copy(Reader from, Writer to) throws IOException {\n        char[] buffer = new char[BUFFER_SIZE];\n        int count = from.read(buffer);\n        while (count > -1) {\n            to.write(buffer, 0, count);\n            count = from.read(buffer);\n        }\n    }\n\n    public static String readFileToString(File file) throws IOException {\n        return readFileToString(file, Charset.defaultCharset());\n    }\n\n    public static String readFileToString(File file, Charset charset) throws IOException {\n        byte[] bytes = Files.readAllBytes(file.toPath());\n        return charset.decode(ByteBuffer.wrap(bytes)).toString();\n    }\n\n    public static String readToString(Reader reader) throws IOException {\n        StringBuilder sb = new StringBuilder(BUFFER_SIZE);\n        char[] buffer = new char[BUFFER_SIZE];\n        int count = reader.read(buffer);\n        while (count > -1) {\n            sb.append(buffer, 0, count);\n            count = reader.read(buffer);\n        }\n        return sb.toString();\n    }\n\n    public static String readToString(InputStream stream, Charset charset) throws IOException {\n        byte[] bytes = toByteArray(stream);\n        return charset.decode(ByteBuffer.wrap(bytes)).toString();\n    }\n\n    public static InputStream fromReader(Reader reader) throws IOException {\n        class ReaderInputStream extends InputStream {\n            private final Reader reader;\n            private final CharBuffer charBuffer = CharBuffer.allocate(BUFFER_SIZE);\n            private final ByteBuffer byteBuffer = ByteBuffer.allocate(BUFFER_SIZE);\n            private final CharsetEncoder encoder;\n\n            private boolean eof;\n\n            ReaderInputStream(Reader reader) {\n                this.reader = reader;\n                encoder = Charset.defaultCharset().newEncoder()\n                        .onMalformedInput(CodingErrorAction.REPLACE)\n                        .onUnmappableCharacter(CodingErrorAction.REPLACE);\n                charBuffer.clear();\n                byteBuffer.clear();\n                byteBuffer.flip(); \n            }\n\n            @Override\n            public int read() throws IOException {\n                if (!byteBuffer.hasRemaining()) {\n                    if (charBuffer.hasRemaining() && !eof) {\n                        int count = reader.read(charBuffer);\n                        eof = count == -1;\n                    }\n                    byteBuffer.clear();\n                    charBuffer.flip();\n                    encoder.encode(charBuffer, byteBuffer, eof);\n                    byteBuffer.flip();\n                    charBuffer.compact();\n                }\n\n                if (byteBuffer.hasRemaining()) {\n                    return byteBuffer.get();\n                }\n\n                return -1;\n            }\n\n            @Override\n            public int available() throws IOException {\n                return byteBuffer.remaining();\n            }\n\n            @Override\n            public void close() throws IOException {\n                reader.close();\n            }\n        }\n\n        return new ReaderInputStream(reader);\n    }\n\n    public static OutputStream fromWriter(Writer writer, String encoding) throws UnsupportedCharsetException {\n        class WriterOutputStream extends OutputStream {\n            private final Writer writer;\n            private final CharsetDecoder decoder;\n            private final ByteBuffer byteBuffer = ByteBuffer.allocate(BUFFER_SIZE);\n            private final CharBuffer charBuffer = CharBuffer.allocate(BUFFER_SIZE);\n\n            WriterOutputStream(Writer writer, String encoding) throws UnsupportedCharsetException {\n                this.writer = writer;\n                Charset charset = Charset.forName(encoding);\n                decoder = charset.newDecoder()\n                        .onMalformedInput(CodingErrorAction.REPLACE)\n                        .onUnmappableCharacter(CodingErrorAction.REPLACE);\n                byteBuffer.clear();\n                charBuffer.clear();\n            }\n\n            @Override\n            public void write(int b) throws IOException {\n                if (!byteBuffer.hasRemaining()) {\n                    decodeByteBuffer(false);\n                }\n                byteBuffer.put((byte) b);\n            }\n\n            @Override\n            public void flush() throws IOException {\n                decodeByteBuffer(false);\n            }\n\n            private void decodeByteBuffer(boolean isClosing) throws IOException {\n                byteBuffer.flip();\n                charBuffer.clear();\n                decoder.decode(byteBuffer, charBuffer, isClosing);\n                writer.write(charBuffer.array(), 0, charBuffer.position());\n                writer.flush();\n                byteBuffer.compact();\n            }\n\n            @Override\n            public void close() throws IOException {\n                flush();\n                decodeByteBuffer(true);\n                writer.close();\n            }\n        }\n\n        return new WriterOutputStream(writer, encoding);\n    }\n\n    \n    public static class BomAwareInputStream extends FilterInputStream {\n\n        private byte[] begin;\n        int beginIndex;\n\n        private String charset;\n\n        public BomAwareInputStream(InputStream in) {\n            super(in);\n            begin = determineBom();\n        }\n\n        private byte[] determineBom() {\n            byte[] bytes = new byte[3];\n            try {\n                int count = in.read(bytes);\n                if (count == 3 && bytes[0] == (byte) 0xef && bytes[1] == (byte) 0xbb && bytes[2] == (byte) 0xbf) {\n                    charset = StandardCharsets.UTF_8.name();\n                    return new byte[0]; \n                } else if (count >= 2 && bytes[0] == (byte) 0xfe && bytes[1] == (byte) 0xff) {\n                    charset = StandardCharsets.UTF_16BE.name();\n                    return new byte[] { bytes[2] };\n                } else if (count >= 2 && bytes[0] == (byte) 0xff && bytes[1] == (byte) 0xfe) {\n                    charset = StandardCharsets.UTF_16LE.name();\n                    return new byte[] { bytes[2] };\n                } else if (count == 3) {\n                    return bytes;\n                }\n\n                if (count < 0) {\n                    return new byte[0];\n                }\n\n                byte[] read = new byte[count];\n                for (int i = 0; i < count; i++) {\n                    read[i] = bytes[i];\n                }\n                return read;\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        @Override\n        public int read() throws IOException {\n            if (beginIndex < begin.length) {\n                return begin[beginIndex++];\n            }\n            return super.read();\n        }\n\n        @Override\n        public int read(byte[] b, int off, int len) throws IOException {\n            if (beginIndex < begin.length) {\n                int count = 0;\n                for (; count < len && beginIndex < begin.length; beginIndex++) {\n                    b[off + count] = begin[beginIndex];\n                    count++;\n                }\n                return count;\n            }\n            return super.read(b, off, len);\n        }\n\n        public boolean hasBom() {\n            return charset != null;\n        }\n\n        public String getBomCharsetName() {\n            return charset;\n        }\n    }\n}\n"
    ],
    "1": [
        "package net.sourceforge.pmd.util;\n\nimport java.io.BufferedReader;\nimport java.io.ByteArrayOutputStream;\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FilterInputStream;\nimport java.io.FilterOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.nio.ByteBuffer;\nimport java.nio.CharBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetDecoder;\nimport java.nio.charset.CharsetEncoder;\nimport java.nio.charset.CodingErrorAction;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.charset.UnsupportedCharsetException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Objects;\n\nimport org.apache.commons.lang3.StringUtils;\n\nimport net.sourceforge.pmd.annotation.InternalApi;\n\n@InternalApi\n@Deprecated\npublic final class IOUtil {\n\n    private static final int BUFFER_SIZE = 8192;\n\n    private IOUtil() {\n    }\n\n    public static Writer createWriter() {\n        return createWriter(null);\n    }\n\n    private static Charset getDefaultCharset() {\n        String csn = AccessController.doPrivileged(new PrivilegedAction<String>() {\n            @Override\n            public String run() {\n                return System.getProperty(\"file.encoding\");\n            }\n        });\n        try {\n            return Charset.forName(csn);\n        } catch (UnsupportedCharsetException e) {\n            return StandardCharsets.UTF_8;\n        }\n    }\n\n    public static Writer createWriter(String reportFile) {\n        return createWriter(getDefaultCharset(), reportFile);\n    }\n\n    public static Writer createWriter(Charset charset, String reportFile) {\n        try {\n            if (StringUtils.isBlank(reportFile)) {\n                return new OutputStreamWriter(new FilterOutputStream(System.out) {\n                    @Override\n                    public void close() {\n                        \n                    }\n                }, charset);\n            }\n            Path path = new File(reportFile).toPath().toAbsolutePath();\n            Files.createDirectories(path.getParent());\n            return Files.newBufferedWriter(path, charset);\n        } catch (IOException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }\n\n    public static Reader skipBOM(Reader source) {\n        try {\n            if (source.markSupported()) {\n                source.mark(1);\n                int firstCharacter = source.read();\n                if (firstCharacter != '\\ufeff') {\n                    source.reset();\n                }\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(\"Error while trying to skip BOM marker\", e);\n        }\n        return new BufferedReader(source);\n    }\n\n    public static void tryCloseClassLoader(ClassLoader classLoader) {\n        if (classLoader instanceof Closeable) {\n            closeQuietly((Closeable) classLoader);\n        }\n    }\n\n    @SuppressWarnings(\"PMD.CloseResource\")\n    public static IOException closeAll(Collection<? extends AutoCloseable> closeables) {\n        IOException composed = null;\n        for (AutoCloseable it : closeables) {\n            try {\n                it.close();\n            } catch (Exception e) {\n                if (composed == null) {\n                    composed = new IOException(\"Cannot close resource \" + it, e);\n                } else {\n                    composed.addSuppressed(e);\n                }\n            }\n        }\n        return composed;\n    }\n\n    public static void ensureClosed(List<? extends AutoCloseable> toClose, Exception pendingException) throws Exception {\n        Exception closeException = closeAll(toClose);\n        if (closeException != null) {\n            if (pendingException != null) {\n                closeException.addSuppressed(pendingException);\n                throw closeException;\n            }\n        } else if (pendingException != null) {\n            throw pendingException;\n        }\n    }\n\n    public static void closeQuietly(Closeable closeable) {\n        try {\n            closeable.close();\n        } catch (IOException ignored) {\n            \n        }\n    }\n\n    public static byte[] toByteArray(InputStream stream) throws IOException {\n        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n        byte[] buffer = new byte[BUFFER_SIZE];\n        int count;\n        while ((count = stream.read(buffer)) != -1) {\n            outputStream.write(buffer, 0, count);\n        }\n        return outputStream.toByteArray();\n    }\n\n    public static long skipFully(InputStream stream, long n) throws IOException {\n        if (n < 0) {\n            throw new IllegalArgumentException();\n        }\n\n        long bytesToSkip = n;\n        byte[] buffer = new byte[(int) Math.min(BUFFER_SIZE, bytesToSkip)];\n        while (bytesToSkip > 0) {\n            int count = stream.read(buffer, 0, (int) Math.min(BUFFER_SIZE, bytesToSkip));\n            if (count < 0) {\n                \n                break;\n            }\n            bytesToSkip -= count;\n        }\n        return n - bytesToSkip;\n    }\n\n    public static String normalizePath(String path) {\n        Path path1 = Paths.get(path);\n        path1.isAbsolute();\n        String normalized = path1.normalize().toString();\n        if (normalized.contains(\".\" + File.separator) || normalized.contains(\"..\" + File.separator) || \"\".equals(normalized)) {\n            return null;\n        }\n        return normalized;\n    }\n\n    public static boolean equalsNormalizedPaths(String path1, String path2) {\n        return Objects.equals(normalizePath(path1), normalizePath(path2));\n    }\n\n    public static String getFilenameExtension(String name) {\n        String filename = Paths.get(name).getFileName().toString();\n        int dot = filename.lastIndexOf('.');\n        if (dot > -1) {\n            return filename.substring(dot + 1);\n        }\n        return \"\";\n    }\n\n    public static String getFilenameBase(String name) {\n        String filename = Paths.get(name).getFileName().toString();\n        int dot = filename.lastIndexOf('.');\n        if (dot > -1) {\n            return filename.substring(0, dot);\n        }\n        return filename;\n    }\n\n    public static void copy(InputStream from, OutputStream to) throws IOException {\n        byte[] buffer = new byte[BUFFER_SIZE];\n        int count;\n        while ((count = from.read(buffer)) != -1) {\n            to.write(buffer, 0, count);\n        }\n    }\n\n    public static void copy(Reader from, Writer to) throws IOException {\n        char[] buffer = new char[BUFFER_SIZE];\n        int count;\n        while ((count = from.read(buffer)) != -1) {\n            to.write(buffer, 0, count);\n        }\n    }\n\n    public static String readFileToString(File file) throws IOException {\n        return readFileToString(file, Charset.defaultCharset());\n    }\n\n    public static String readFileToString(File file, Charset charset) throws IOException {\n        byte[] bytes = Files.readAllBytes(file.toPath());\n        return charset.decode(ByteBuffer.wrap(bytes)).toString();\n    }\n\n    public static String readToString(Reader reader) throws IOException {\n        StringBuilder sb = new StringBuilder(BUFFER_SIZE);\n        char[] buffer = new char[BUFFER_SIZE];\n        int count;\n        while ((count = reader.read(buffer)) != -1) {\n            sb.append(buffer, 0, count);\n        }\n        return sb.toString();\n    }\n\n    public static String readToString(InputStream stream, Charset charset) throws IOException {\n        byte[] bytes = toByteArray(stream);\n        return charset.decode(ByteBuffer.wrap(bytes)).toString();\n    }\n\n    public static InputStream fromReader(Reader reader) throws IOException {\n        class ReaderInputStream extends InputStream {\n            private final Reader reader;\n            private final CharBuffer charBuffer = CharBuffer.allocate(BUFFER_SIZE);\n            private final ByteBuffer byteBuffer = ByteBuffer.allocate(BUFFER_SIZE);\n            private final CharsetEncoder encoder;\n\n            private boolean eof;\n\n            ReaderInputStream(Reader reader) {\n                this.reader = reader;\n                encoder = Charset.defaultCharset().newEncoder()\n                        .onMalformedInput(CodingErrorAction.REPLACE)\n                        .onUnmappableCharacter(CodingErrorAction.REPLACE);\n                charBuffer.clear();\n                byteBuffer.clear();\n                byteBuffer.flip(); \n            }\n\n            @Override\n            public int read() throws IOException {\n                if (!byteBuffer.hasRemaining()) {\n                    if (charBuffer.hasRemaining() && !eof) {\n                        int count = reader.read(charBuffer);\n                        eof = count == -1;\n                    }\n                    byteBuffer.clear();\n                    charBuffer.flip();\n                    encoder.encode(charBuffer, byteBuffer, eof);\n                    byteBuffer.flip();\n                    charBuffer.compact();\n                }\n\n                if (byteBuffer.hasRemaining()) {\n                    return byteBuffer.get();\n                }\n\n                return -1;\n            }\n\n            @Override\n            public int available() throws IOException {\n                return byteBuffer.remaining();\n            }\n\n            @Override\n            public void close() throws IOException {\n                reader.close();\n            }\n        }\n\n        return new ReaderInputStream(reader);\n    }\n\n    public static OutputStream fromWriter(Writer writer, String encoding) throws UnsupportedCharsetException {\n        class WriterOutputStream extends OutputStream {\n            private final Writer writer;\n            private final CharsetDecoder decoder;\n            private final ByteBuffer byteBuffer = ByteBuffer.allocate(BUFFER_SIZE);\n            private final CharBuffer charBuffer = CharBuffer.allocate(BUFFER_SIZE);\n\n            WriterOutputStream(Writer writer, String encoding) throws UnsupportedCharsetException {\n                this.writer = writer;\n                Charset charset = Charset.forName(encoding);\n                decoder = charset.newDecoder()\n                        .onMalformedInput(CodingErrorAction.REPLACE)\n                        .onUnmappableCharacter(CodingErrorAction.REPLACE);\n                byteBuffer.clear();\n                charBuffer.clear();\n            }\n\n            @Override\n            public void write(int b) throws IOException {\n                if (!byteBuffer.hasRemaining()) {\n                    decodeByteBuffer(false);\n                }\n                byteBuffer.put((byte) b);\n            }\n\n            @Override\n            public void flush() throws IOException {\n                decodeByteBuffer(false);\n            }\n\n            private void decodeByteBuffer(boolean isClosing) throws IOException {\n                byteBuffer.flip();\n                charBuffer.clear();\n                decoder.decode(byteBuffer, charBuffer, isClosing);\n                writer.write(charBuffer.array(), 0, charBuffer.position());\n                writer.flush();\n                byteBuffer.compact();\n            }\n\n            @Override\n            public void close() throws IOException {\n                flush();\n                decodeByteBuffer(true);\n                writer.close();\n            }\n        }\n\n        return new WriterOutputStream(writer, encoding);\n    }\n\n    public static class BomAwareInputStream extends FilterInputStream {\n\n        private byte[] begin;\n        int beginIndex;\n\n        private String charset;\n\n        public BomAwareInputStream(InputStream in) {\n            super(in);\n            begin = determineBom();\n        }\n\n        private byte[] determineBom() {\n            byte[] bytes = new byte[3];\n            try {\n                int count = in.read(bytes);\n                if (count == 3 && bytes[0] == (byte) 0xef && bytes[1] == (byte) 0xbb && bytes[2] == (byte) 0xbf) {\n                    charset = StandardCharsets.UTF_8.name();\n                    return new byte[0]; \n                } else if (count >= 2 && bytes[0] == (byte) 0xfe && bytes[1] == (byte) 0xff) {\n                    charset = StandardCharsets.UTF_16BE.name();\n                    return new byte[] { bytes[2] };\n                } else if (count >= 2 && bytes[0] == (byte) 0xff && bytes[1] == (byte) 0xfe) {\n                    charset = StandardCharsets.UTF_16LE.name();\n                    return new byte[] { bytes[2] };\n                } else if (count == 3) {\n                    return bytes;\n                }\n\n                if (count < 0) {\n                    return new byte[0];\n                }\n\n                byte[] read = new byte[count];\n                for (int i = 0; i < count; i++) {\n                    read[i] = bytes[i];\n                }\n                return read;\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        @Override\n        public int read() throws IOException {\n            if (beginIndex < begin.length) {\n                return begin[beginIndex++];\n            }\n            return super.read();\n        }\n\n        @Override\n        public int read(byte[] b, int off, int len) throws IOException {\n            if (beginIndex < begin.length) {\n                int count = 0;\n                for (; count < len && beginIndex < begin.length; beginIndex++) {\n                    b[off + count] = begin[beginIndex];\n                    count++;\n                }\n                return count;\n            }\n            return super.read(b, off, len);\n        }\n\n        public boolean hasBom() {\n            return charset != null;\n        }\n\n        public String getBomCharsetName() {\n            return charset;\n        }\n    }\n}\n"
    ],
    "2": [
        "package net.sourceforge.pmd.util;\n\nimport java.io.BufferedReader;\nimport java.io.ByteArrayOutputStream;\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FilterInputStream;\nimport java.io.FilterOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.nio.ByteBuffer;\nimport java.nio.CharBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetDecoder;\nimport java.nio.charset.CharsetEncoder;\nimport java.nio.charset.CodingErrorAction;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.charset.UnsupportedCharsetException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Objects;\n\nimport org.apache.commons.lang3.StringUtils;\n\nimport net.sourceforge.pmd.annotation.InternalApi;\n\n@InternalApi\n@Deprecated\npublic final class IOUtil {\n\n    private static final int BUFFER_SIZE = 8192;\n\n    private IOUtil() {\n    }\n\n    public static Writer createWriter() {\n        return createWriter(null);\n    }\n\n    private static Charset getDefaultCharset() {\n        String csn = AccessController.doPrivileged(new PrivilegedAction<String>() {\n            @Override\n            public String run() {\n                return System.getProperty(\"file.encoding\");\n            }\n        });\n        try {\n            return Charset.forName(csn);\n        } catch (UnsupportedCharsetException e) {\n            return StandardCharsets.UTF_8;\n        }\n    }\n\n    public static Writer createWriter(String reportFile) {\n        return createWriter(getDefaultCharset(), reportFile);\n    }\n\n    public static Writer createWriter(Charset charset, String reportFile) {\n        try {\n            if (StringUtils.isBlank(reportFile)) {\n                return new OutputStreamWriter(new FilterOutputStream(System.out) {\n                    @Override\n                    public void close() {\n                        \n                    }\n                }, charset);\n            }\n            Path path = new File(reportFile).toPath().toAbsolutePath();\n            Files.createDirectories(path.getParent());\n            return Files.newBufferedWriter(path, charset);\n        } catch (IOException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }\n\n    public static Reader skipBOM(Reader source) {\n        try {\n            if (!source.markSupported()) {\n                source = new BufferedReader(source);\n            }\n            source.mark(1);\n            int firstCharacter = source.read();\n            if (firstCharacter != '\\ufeff') {\n                source.reset();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(\"Error while trying to skip BOM marker\", e);\n        }\n        return source;\n    }\n\n    public static void tryCloseClassLoader(ClassLoader classLoader) {\n        if (classLoader instanceof Closeable) {\n            closeQuietly((Closeable) classLoader);\n        }\n    }\n\n    @SuppressWarnings(\"PMD.CloseResource\")\n    public static IOException closeAll(Collection<? extends AutoCloseable> closeables) {\n        IOException composed = null;\n        for (AutoCloseable it : closeables) {\n            try {\n                it.close();\n            } catch (Exception e) {\n                if (composed == null) {\n                    composed = new IOException(\"Cannot close resource \" + it, e);\n                } else {\n                    composed.addSuppressed(e);\n                }\n            }\n        }\n        return composed;\n    }\n\n    public static void ensureClosed(List<? extends AutoCloseable> toClose, Exception pendingException) throws Exception {\n        Exception closeException = closeAll(toClose);\n        if (closeException != null) {\n            if (pendingException != null) {\n                closeException.addSuppressed(pendingException);\n                throw closeException;\n            }\n        } else if (pendingException != null) {\n            throw pendingException;\n        }\n    }\n\n    public static void closeQuietly(Closeable closeable) {\n        try {\n            closeable.close();\n        } catch (IOException ignored) {\n            \n        }\n    }\n\n    public static byte[] toByteArray(InputStream stream) throws IOException {\n        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n        byte[] buffer = new byte[BUFFER_SIZE];\n        int count;\n        while ((count = stream.read(buffer)) != -1) {\n            outputStream.write(buffer, 0, count);\n        }\n        return outputStream.toByteArray();\n    }\n\n    public static long skipFully(InputStream stream, long n) throws IOException {\n        if (n < 0) {\n            throw new IllegalArgumentException();\n        }\n\n        long bytesToSkip = n;\n        byte[] buffer = new byte[(int) Math.min(BUFFER_SIZE, bytesToSkip)];\n        while (bytesToSkip > 0) {\n            int count = stream.read(buffer, 0, (int) Math.min(BUFFER_SIZE, bytesToSkip));\n            if (count < 0) {\n                \n                break;\n            }\n            bytesToSkip -= count;\n        }\n        return n - bytesToSkip;\n    }\n\n    public static String normalizePath(String path) {\n        Path path1 = Paths.get(path);\n        path1.isAbsolute();\n        String normalized = path1.normalize().toString();\n        if (normalized.contains(\".\" + File.separator) || normalized.contains(\"..\" + File.separator) || \"\".equals(normalized)) {\n            return null;\n        }\n        return normalized;\n    }\n\n    public static boolean equalsNormalizedPaths(String path1, String path2) {\n        return Objects.equals(normalizePath(path1), normalizePath(path2));\n    }\n\n    public static String getFilenameExtension(String name) {\n        String filename = Paths.get(name).getFileName().toString();\n        int dot = filename.lastIndexOf('.');\n        if (dot > -1) {\n            return filename.substring(dot + 1);\n        }\n        return \"\";\n    }\n\n    public static String getFilenameBase(String name) {\n        String filename = Paths.get(name).getFileName().toString();\n        int dot = filename.lastIndexOf('.');\n        if (dot > -1) {\n            return filename.substring(0, dot);\n        }\n        return filename;\n    }\n\n    public static void copy(InputStream from, OutputStream to) throws IOException {\n        byte[] buffer = new byte[BUFFER_SIZE];\n        int count;\n        while ((count = from.read(buffer)) != -1) {\n            to.write(buffer, 0, count);\n        }\n    }\n\n    public static void copy(Reader from, Writer to) throws IOException {\n        char[] buffer = new char[BUFFER_SIZE];\n        int count;\n        while ((count = from.read(buffer)) != -1) {\n            to.write(buffer, 0, count);\n        }\n    }\n\n    public static String readFileToString(File file) throws IOException {\n        return readFileToString(file, Charset.defaultCharset());\n    }\n\n    public static String readFileToString(File file, Charset charset) throws IOException {\n        byte[] bytes = Files.readAllBytes(file.toPath());\n        return charset.decode(ByteBuffer.wrap(bytes)).toString();\n    }\n\n    public static String readToString(Reader reader) throws IOException {\n        StringBuilder sb = new StringBuilder(BUFFER_SIZE);\n        char[] buffer = new char[BUFFER_SIZE];\n        int count;\n        while ((count = reader.read(buffer)) != -1) {\n            sb.append(buffer, 0, count);\n        }\n        return sb.toString();\n    }\n\n    public static String readToString(InputStream stream, Charset charset) throws IOException {\n        byte[] bytes = toByteArray(stream);\n        return charset.decode(ByteBuffer.wrap(bytes)).toString();\n    }\n\n    public static InputStream fromReader(Reader reader) throws IOException {\n        class ReaderInputStream extends InputStream {\n            private final Reader reader;\n            private final CharBuffer charBuffer = CharBuffer.allocate(BUFFER_SIZE);\n            private final ByteBuffer byteBuffer = ByteBuffer.allocate(BUFFER_SIZE);\n            private final CharsetEncoder encoder;\n\n            private boolean eof;\n\n            ReaderInputStream(Reader reader) {\n                this.reader = reader;\n                encoder = Charset.defaultCharset().newEncoder()\n                        .onMalformedInput(CodingErrorAction.REPLACE)\n                        .onUnmappableCharacter(CodingErrorAction.REPLACE);\n                charBuffer.clear();\n                byteBuffer.clear();\n                byteBuffer.flip(); \n            }\n\n            @Override\n            public int read() throws IOException {\n                if (!byteBuffer.hasRemaining()) {\n                    if (charBuffer.hasRemaining() && !eof) {\n                        int count = reader.read(charBuffer);\n                        eof = count == -1;\n                    }\n                    byteBuffer.clear();\n                    charBuffer.flip();\n                    encoder.encode(charBuffer, byteBuffer, eof);\n                    byteBuffer.flip();\n                    charBuffer.compact();\n                }\n\n                if (byteBuffer.hasRemaining()) {\n                    return byteBuffer.get();\n                }\n\n                return -1;\n            }\n\n            @Override\n            public int available() throws IOException {\n                return byteBuffer.remaining();\n            }\n\n            @Override\n            public void close() throws IOException {\n                reader.close();\n            }\n        }\n\n        return new ReaderInputStream(reader);\n    }\n\n    public static OutputStream fromWriter(Writer writer, String encoding) throws UnsupportedCharsetException {\n        class WriterOutputStream extends OutputStream {\n            private final Writer writer;\n            private final CharsetDecoder decoder;\n            private final ByteBuffer byteBuffer = ByteBuffer.allocate(BUFFER_SIZE);\n            private final CharBuffer charBuffer = CharBuffer.allocate(BUFFER_SIZE);\n\n            WriterOutputStream(Writer writer, String encoding) throws UnsupportedCharsetException {\n                this.writer = writer;\n                Charset charset = Charset.forName(encoding);\n                decoder = charset.newDecoder()\n                        .onMalformedInput(CodingErrorAction.REPLACE)\n                        .onUnmappableCharacter(CodingErrorAction.REPLACE);\n                byteBuffer.clear();\n                charBuffer.clear();\n            }\n\n            @Override\n            public void write(int b) throws IOException {\n                if (!byteBuffer.hasRemaining()) {\n                    decodeByteBuffer(false);\n                }\n                byteBuffer.put((byte) b);\n            }\n\n            @Override\n            public void flush() throws IOException {\n                decodeByteBuffer(false);\n            }\n\n            private void decodeByteBuffer(boolean isClosing) throws IOException {\n                byteBuffer.flip();\n                charBuffer.clear();\n                decoder.decode(byteBuffer, charBuffer, isClosing);\n                writer.write(charBuffer.array(), 0, charBuffer.position());\n                writer.flush();\n                byteBuffer.compact();\n            }\n\n            @Override\n            public void close() throws IOException {\n                flush();\n                decodeByteBuffer(true);\n                writer.close();\n            }\n        }\n\n        return new WriterOutputStream(writer, encoding);\n    }\n\n    public static class BomAwareInputStream extends FilterInputStream {\n\n        private byte[] begin;\n        int beginIndex;\n\n        private String charset;\n\n        public BomAwareInputStream(InputStream in) {\n            super(in);\n            begin = determineBom();\n        }\n\n        private byte[] determineBom() {\n            byte[] bytes = new byte[3];\n            try {\n                int count = in.read(bytes);\n                if (count == 3 && bytes[0] == (byte) 0xef && bytes[1] == (byte) 0xbb && bytes[2] == (byte) 0xbf) {\n                    charset = StandardCharsets.UTF_8.name();\n                    return new byte[0]; \n                } else if (count >= 2 && bytes[0] == (byte) 0xfe && bytes[1] == (byte) 0xff) {\n                    charset = StandardCharsets.UTF_16BE.name();\n                    return new byte[] { bytes[2] };\n                } else if (count >= 2 && bytes[0] == (byte) 0xff && bytes[1] == (byte) 0xfe) {\n                    charset = StandardCharsets.UTF_16LE.name();\n                    return new byte[] { bytes[2] };\n                } else if (count == 3) {\n                    return bytes;\n                }\n\n                if (count < 0) {\n                    return new byte[0];\n                }\n\n                byte[] read = new byte[count];\n                for (int i = 0; i < count; i++) {\n                    read[i] = bytes[i];\n                }\n                return read;\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        @Override\n        public int read() throws IOException {\n            if (beginIndex < begin.length) {\n                return begin[beginIndex++];\n            }\n            return super.read();\n        }\n\n        @Override\n        public int read(byte[] b, int off, int len) throws IOException {\n            if (beginIndex < begin.length) {\n                int count = 0;\n                for (; count < len && beginIndex < begin.length; beginIndex++) {\n                    b[off + count] = begin[beginIndex];\n                    count++;\n                }\n                return count;\n            }\n            return super.read(b, off, len);\n        }\n\n        public boolean hasBom() {\n            return charset != null;\n        }\n\n        public String getBomCharsetName() {\n            return charset;\n        }\n    }\n}\n"
    ]
}