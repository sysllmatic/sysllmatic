{
    "0": [
        "package jnt.scimark2;\n\npublic class LUOptimized {\n    private final double[][] LU_;\n    private final int[] pivot_;\n\n    public static void main(String[] args) {\n        Random R = new Random(101010);\n        int N = 1000;\n        \n        double[][] A = RandomMatrix(N, N, R);\n        double[][] lu = new double[N][N];\n        int[] pivot = new int[N];\n\n        CopyMatrix(lu, A);\n\n        int status = factor(lu, pivot);\n        if (status != 0) {\n            System.err.println(\"LU factorization failed due to singular matrix.\");\n            return;\n        }\n        \n        double[] b = RandomVector(N, R);\n        double[] x = NewVectorCopy(b);\n\n        solve(lu, pivot, x);\n        System.out.println(normabs(b, matvec(A, x)) / N);\n    }\n\n    public LUOptimized(double[][] A) {\n        int M = A.length;\n        int N = A[0].length;\n\n        LU_ = new double[M][N];\n\n        insert_copy(LU_, A);\n\n        pivot_ = new int[M];\n\n        factor(LU_, pivot_);\n    }\n\n    private static double[] NewVectorCopy(double[] x) {\n        int N = x.length;\n\n        double[] y = new double[N];\n        System.arraycopy(x, 0, y, 0, N);\n\n        return y;\n    }\n\n    private static double[][] RandomMatrix(int M, int N, Random R) {\n        double[][] A = new double[M][N];\n\n        for (int i = 0; i < N; i++)\n            for (int j = 0; j < N; j++)\n                A[i][j] = R.nextDouble();\n        return A;\n    }\n\n    private static double[] RandomVector(int N, Random R) {\n        double[] A = new double[N];\n\n        for (int i = 0; i < N; i++)\n            A[i] = R.nextDouble();\n        return A;\n    }\n\n    private static double[] matvec(double[][] A, double[] x) {\n        int N = x.length;\n        double[] y = new double[N];\n\n        matvec(A, x, y);\n\n        return y;\n    }\n\n    private static void matvec(double[][] A, double[] x, double[] y) {\n        int M = A.length;\n        int N = A[0].length;\n\n        for (int i = 0; i < M; i++) {\n            double sum = 0.0;\n            double[] Ai = A[i];\n            for (int j = 0; j < N; j++)\n                sum += Ai[j] * x[j];\n\n            y[i] = sum;\n        }\n    }\n\n    private static double normabs(double[] x, double[] y) {\n        int N = x.length;\n        double sum = 0.0;\n\n        for (int i = 0; i < N; i++)\n            sum += Math.abs(x[i] - y[i]);\n\n        return sum;\n    }\n\n    private static void CopyMatrix(double[][] B, double[][] A) {\n        int M = A.length;\n        int N = A[0].length;\n\n        int remainder = N & 3;         // N mod 4;\n\n        for (int i = 0; i < M; i++) {\n            double[] Bi = B[i];\n            double[] Ai = A[i];\n            System.arraycopy(Ai, 0, Bi, 0, remainder);\n            for (int j = remainder; j < N; j += 4) {\n                Bi[j] = Ai[j];\n                Bi[j + 1] = Ai[j + 1];\n                Bi[j + 2] = Ai[j + 2];\n                Bi[j + 3] = Ai[j + 3];\n            }\n        }\n    }\n\n    protected static double[] new_copy(double[] x) {\n        int N = x.length;\n        double[] T = new double[N];\n        System.arraycopy(x, 0, T, 0, N);\n        return T;\n    }\n\n    protected static double[][] new_copy(double[][] A) {\n        int M = A.length;\n        int N = A[0].length;\n\n        double[][] T = new double[M][N];\n\n        for (int i = 0; i < M; i++) {\n            double[] Ti = T[i];\n            double[] Ai = A[i];\n            System.arraycopy(Ai, 0, Ti, 0, N);\n        }\n\n        return T;\n    }\n\n    public static int[] new_copy(int[] x) {\n        int N = x.length;\n        int[] T = new int[N];\n        System.arraycopy(x, 0, T, 0, N);\n        return T;\n    }\n\n    protected static void insert_copy(double[][] B, double[][] A) {\n        int M = A.length;\n        int N = A[0].length;\n\n        int remainder = N & 3;         // N mod 4;\n\n        for (int i = 0; i < M; i++) {\n            double[] Bi = B[i];\n            double[] Ai = A[i];\n            System.arraycopy(Ai, 0, Bi, 0, remainder);\n            for (int j = remainder; j < N; j += 4) {\n                Bi[j] = Ai[j];\n                Bi[j + 1] = Ai[j + 1];\n                Bi[j + 2] = Ai[j + 2];\n                Bi[j + 3] = Ai[j + 3];\n            }\n        }\n    }\n\n    /**\n     * LU factorization (in place).\n     *\n     * @param A     (in/out) On input, the matrix to be factored.\n     *              On output, the compact LU factorization.\n     * @param pivot (out) The pivot vector records the\n     *              reordering of the rows of A during factorization.\n     * @return 0, if OK, nozero value, othewise.\n     */\n    public static int factor(double[][] A, int[] pivot) {\n\n\n        int N = A.length;\n        int M = A[0].length;\n\n        int minMN = Math.min(M, N);\n\n        for (int j = 0; j < minMN; j++) {\n            // find pivot in column j and  test for singularity.\n\n            int jp = j;\n\n            double t = Math.abs(A[j][j]);\n            for (int i = j + 1; i < M; i++) {\n                double ab = Math.abs(A[i][j]);\n                if (ab > t) {\n                    jp = i;\n                    t = ab;\n                }\n            }\n\n            pivot[j] = jp;\n\n            // jp now has the index of maximum element\n            // of column j, below the diagonal\n\n            if (A[jp][j] == 0)\n                return 1;       // factorization failed because of zero pivot\n\n\n            if (jp != j) {\n                // swap rows j and jp\n                double[] tA = A[j];\n                A[j] = A[jp];\n                A[jp] = tA;\n            }\n\n            if (j < M - 1)                // compute elements j+1:M of jth column\n            {\n                // note A(j,j), was A(jp,p) previously which was\n                // guarranteed not to be zero (Label #1)\n                //\n                double recp = 1.0 / A[j][j];\n\n                for (int k = j + 1; k < M; k++)\n                    A[k][j] *= recp;\n            }\n\n\n            if (j < minMN - 1) {\n                // rank-1 update to trailing submatrix:   E = E - x*y;\n                //\n                // E is the region A(j+1:M, j+1:N)\n                // x is the column vector A(j+1:M,j)\n                // y is row vector A(j,j+1:N)\n\n\n                for (int ii = j + 1; ii < M; ii++) {\n                    double[] Aii = A[ii];\n                    double[] Aj = A[j];\n                    double AiiJ = Aii[j];\n                    for (int jj = j + 1; jj < N; jj++)\n                        Aii[jj] -= AiiJ * Aj[jj];\n\n                }\n            }\n        }\n\n        return 0;\n    }\n\n    /**\n     * Solve a linear system, using a prefactored matrix\n     * in LU form.\n     *\n     * @param LU  (in) the factored matrix in LU form.\n     * @param pvt (in) the pivot vector which lists\n     *            the reordering used during the factorization\n     *            stage.\n     * @param b   (in/out) On input, the right-hand side.\n     *            On output, the solution vector.\n     */\n    public static void solve(double[][] LU, int[] pvt, double[] b) {\n        int M = LU.length;\n        int N = LU[0].length;\n        int ii = 0;\n\n        for (int i = 0; i < M; i++) {\n            int ip = pvt[i];\n            double sum = b[ip];\n\n            b[ip] = b[i];\n            if (ii == 0)\n                for (int j = ii; j < i; j++)\n                    sum -= LU[i][j] * b[j];\n            else if (sum == 0.0)\n                ii = i;\n            b[i] = sum;\n        }\n\n        for (int i = N - 1; i >= 0; i--) {\n            double sum = b[i];\n            for (int j = i + 1; j < N; j++)\n                sum -= LU[i][j] * b[j];\n            b[i] = sum / LU[i][i];\n        }\n    }\n\n    public double[][] getLU() {\n        return new_copy(LU_);\n    }\n\n    /**\n     * Solve a linear system, with pre-computed factorization.\n     *\n     * @param b (in) the right-hand side.\n     * @return solution vector.\n     */\n    public double[] solve(double[] b) {\n        double[] x = new_copy(b);\n\n        solve(LU_, pivot_, x);\n        return x;\n    }\n}\n",
        21.82,
        0.39,
        981343825.4,
        63224.0,
        2.565,
        5165.46,
        303
    ],
    "1": [
        "package jnt.scimark2;\n\nimport java.util.Random;\n\npublic class LUOptimized {\n    private final double[][] LU_;\n    private final int[] pivot_;\n\n    public static void main(String[] args) {\n        Random R = new Random(101010);\n        int N = 1000;\n        \n        double[][] A = RandomMatrix(N, N, R);\n        double[][] lu = new double[N][N];\n        int[] pivot = new int[N];\n\n        CopyMatrix(lu, A);\n\n        int status = factor(lu, pivot);\n        if (status != 0) {\n            System.err.println(\"LU factorization failed due to singular matrix.\");\n            return;\n        }\n        \n        double[] b = RandomVector(N, R);\n        double[] x = NewVectorCopy(b);\n\n        solve(lu, pivot, x);\n        System.out.println(normabs(b, matvec(A, x)) / N);\n    }\n\n    public LUOptimized(double[][] A) {\n        int M = A.length;\n        int N = A[0].length;\n\n        LU_ = new double[M][N];\n\n        insert_copy(LU_, A);\n\n        pivot_ = new int[M];\n\n        factor(LU_, pivot_);\n    }\n\n    private static double[] NewVectorCopy(double[] x) {\n        int N = x.length;\n\n        double[] y = new double[N];\n        System.arraycopy(x, 0, y, 0, N);\n\n        return y;\n    }\n\n    private static double[][] RandomMatrix(int M, int N, Random R) {\n        double[][] A = new double[M][N];\n\n        for (int i = 0; i < M; i++) {\n            for (int j = 0; j < N; j++) {\n                A[i][j] = R.nextDouble();\n            }\n        }\n\n        return A;\n    }\n\n    private static double[] RandomVector(int N, Random R) {\n        double[] A = new double[N];\n\n        for (int i = 0; i < N; i++) {\n            A[i] = R.nextDouble();\n        }\n\n        return A;\n    }\n\n    private static double[] matvec(double[][] A, double[] x) {\n        int N = x.length;\n        double[] y = new double[N];\n\n        matvec(A, x, y);\n\n        return y;\n    }\n\n    private static void matvec(double[][] A, double[] x, double[] y) {\n        int M = A.length;\n        int N = A[0].length;\n\n        for (int i = 0; i < M; i++) {\n            double sum = 0.0;\n            double[] Ai = A[i];\n            for (int j = 0; j < N; j++) {\n                sum += Ai[j] * x[j];\n            }\n\n            y[i] = sum;\n        }\n    }\n\n    private static double normabs(double[] x, double[] y) {\n        int N = x.length;\n        double sum = 0.0;\n\n        for (int i = 0; i < N; i++) {\n            sum += Math.abs(x[i] - y[i]);\n        }\n\n        return sum;\n    }\n\n    private static void CopyMatrix(double[][] B, double[][] A) {\n        int M = A.length;\n        int N = A[0].length;\n\n        for (int i = 0; i < M; i++) {\n            System.arraycopy(A[i], 0, B[i], 0, N);\n        }\n    }\n\n    protected static double[] new_copy(double[] x) {\n        int N = x.length;\n        double[] T = new double[N];\n        System.arraycopy(x, 0, T, 0, N);\n        return T;\n    }\n\n    protected static double[][] new_copy(double[][] A) {\n        int M = A.length;\n        int N = A[0].length;\n\n        double[][] T = new double[M][N];\n\n        for (int i = 0; i < M; i++) {\n            System.arraycopy(A[i], 0, T[i], 0, N);\n        }\n\n        return T;\n    }\n\n    public static int[] new_copy(int[] x) {\n        int N = x.length;\n        int[] T = new int[N];\n        System.arraycopy(x, 0, T, 0, N);\n        return T;\n    }\n\n    protected static void insert_copy(double[][] B, double[][] A) {\n        int M = A.length;\n        int N = A[0].length;\n\n        for (int i = 0; i < M; i++) {\n            System.arraycopy(A[i], 0, B[i], 0, N);\n        }\n    }\n\n    public static int factor(double[][] A, int[] pivot) {\n        int N = A.length;\n        int M = A[0].length;\n\n        int minMN = Math.min(M, N);\n\n        for (int j = 0; j < minMN; j++) {\n            int jp = j;\n            double t = Math.abs(A[j][j]);\n            for (int i = j + 1; i < M; i++) {\n                double ab = Math.abs(A[i][j]);\n                if (ab > t) {\n                    jp = i;\n                    t = ab;\n                }\n            }\n\n            pivot[j] = jp;\n\n            if (A[jp][j] == 0) return 1;\n\n            if (jp != j) {\n                double[] tA = A[j];\n                A[j] = A[jp];\n                A[jp] = tA;\n            }\n\n            if (j < M - 1) {\n                double recp = 1.0 / A[j][j];\n                for (int k = j + 1; k < M; k++) {\n                    A[k][j] *= recp;\n                }\n            }\n\n            if (j < minMN - 1) {\n                for (int ii = j + 1; ii < M; ii++) {\n                    double[] Aii = A[ii];\n                    double[] Aj = A[j];\n                    double AiiJ = Aii[j];\n                    for (int jj = j + 1; jj < N; jj++) {\n                        Aii[jj] -= AiiJ * Aj[jj];\n                    }\n                }\n            }\n        }\n\n        return 0;\n    }\n\n    public static void solve(double[][] LU, int[] pvt, double[] b) {\n        int M = LU.length;\n        int N = LU[0].length;\n        int ii = 0;\n\n        for (int i = 0; i < M; i++) {\n            int ip = pvt[i];\n            double sum = b[ip];\n\n            b[ip] = b[i];\n            if (ii == 0) {\n                for (int j = ii; j < i; j++) {\n                    sum -= LU[i][j] * b[j];\n                }\n            } else if (sum == 0.0) {\n                ii = i;\n            }\n            b[i] = sum;\n        }\n\n        for (int i = N - 1; i >= 0; i--) {\n            double sum = b[i];\n            for (int j = i + 1; j < N; j++) {\n                sum -= LU[i][j] * b[j];\n            }\n            b[i] = sum / LU[i][i];\n        }\n    }\n\n    public double[][] getLU() {\n        return new_copy(LU_);\n    }\n\n    public double[] solve(double[] b) {\n        double[] x = new_copy(b);\n        solve(LU_, pivot_, x);\n        return x;\n    }\n}\n",
        0.75,
        0.989,
        0.9432938636851357,
        1.0020540650200334,
        0.9879341130604288,
        1.094328481877703,
        243
    ],
    "2": [
        "package jnt.scimark2;\n\nimport java.util.concurrent.ForkJoinPool;\nimport java.util.concurrent.RecursiveAction;\nimport java.util.stream.IntStream;\nimport java.util.Random;\n\npublic class LUOptimized {\n    private final double[][] LU_;\n    private final int[] pivot_;\n\n    public static void main(String[] args) {\n        Random R = new Random(101010);\n        int N = 1000;\n\n        double[][] A = RandomMatrix(N, N, R);\n        double[][] lu = new double[N][N];\n        int[] pivot = new int[N];\n\n        CopyMatrix(lu, A);\n\n        int status = factor(lu, pivot);\n        if (status != 0) {\n            System.err.println(\"LU factorization failed due to singular matrix.\");\n            return;\n        }\n\n        double[] b = RandomVector(N, R);\n        double[] x = NewVectorCopy(b);\n\n        solve(lu, pivot, x);\n        System.out.println(normabs(b, matvec(A, x)) / N);\n    }\n\n    public LUOptimized(double[][] A) {\n        int M = A.length;\n        int N = A[0].length;\n\n        LU_ = new double[M][N];\n\n        insert_copy(LU_, A);\n\n        pivot_ = new int[M];\n\n        factor(LU_, pivot_);\n    }\n\n    private static double[] NewVectorCopy(double[] x) {\n        int N = x.length;\n\n        double[] y = new double[N];\n        System.arraycopy(x, 0, y, 0, N);\n\n        return y;\n    }\n\n    private static double[][] RandomMatrix(int M, int N, Random R) {\n        double[][] A = new double[M][N];\n\n        for (int i = 0; i < M; i++) {\n            for (int j = 0; j < N; j++) {\n                A[i][j] = R.nextDouble();\n            }\n        }\n\n        return A;\n    }\n\n    private static double[] RandomVector(int N, Random R) {\n        double[] A = new double[N];\n\n        for (int i = 0; i < N; i++) {\n            A[i] = R.nextDouble();\n        }\n\n        return A;\n    }\n\n    private static double[] matvec(double[][] A, double[] x) {\n        int N = x.length;\n        double[] y = new double[N];\n\n        parallelMatvec(A, x, y);\n\n        return y;\n    }\n\n    private static void parallelMatvec(double[][] A, double[] x, double[] y) {\n        ForkJoinPool pool = new ForkJoinPool();\n        pool.invoke(new RecursiveAction() {\n            @Override\n            protected void compute() {\n                invokeAll(IntStream.range(0, A.length).mapToObj(i ->\n                        new RecursiveAction() {\n                            @Override\n                            protected void compute() {\n                                double sum = 0.0;\n                                for (int j = 0; j < x.length; j++) {\n                                    sum += A[i][j] * x[j];\n                                }\n                                y[i] = sum;\n                            }\n                        }).toArray(RecursiveAction[]::new));\n            }\n        });\n    }\n\n    private static double normabs(double[] x, double[] y) {\n        int N = x.length;\n        double sum = 0.0;\n\n        for (int i = 0; i < N; i++) {\n            sum += Math.abs(x[i] - y[i]);\n        }\n\n        return sum;\n    }\n\n    private static void CopyMatrix(double[][] B, double[][] A) {\n        int M = A.length;\n        int N = A[0].length;\n\n        for (int i = 0; i < M; i++) {\n            System.arraycopy(A[i], 0, B[i], 0, N);\n        }\n    }\n\n    protected static double[] new_copy(double[] x) {\n        int N = x.length;\n        double[] T = new double[N];\n        System.arraycopy(x, 0, T, 0, N);\n        return T;\n    }\n\n    protected static double[][] new_copy(double[][] A) {\n        int M = A.length;\n        int N = A[0].length;\n\n        double[][] T = new double[M][N];\n\n        for (int i = 0; i < M; i++) {\n            System.arraycopy(A[i], 0, T[i], 0, N);\n        }\n\n        return T;\n    }\n\n    public static int[] new_copy(int[] x) {\n        int N = x.length;\n        int[] T = new int[N];\n        System.arraycopy(x, 0, T, 0, N);\n        return T;\n    }\n\n    protected static void insert_copy(double[][] B, double[][] A) {\n        int M = A.length;\n        int N = A[0].length;\n\n        for (int i = 0; i < M; i++) {\n            System.arraycopy(A[i], 0, B[i], 0, N);\n        }\n    }\n\n    public static int factor(double[][] A, int[] pivot) {\n        int N = A.length;\n        int M = A[0].length;\n\n        int minMN = Math.min(M, N);\n\n        for (int j = 0; j < minMN; j++) {\n            int jp = j;\n            double t = Math.abs(A[j][j]);\n            for (int i = j + 1; i < M; i++) {\n                double ab = Math.abs(A[i][j]);\n                if (ab > t) {\n                    jp = i;\n                    t = ab;\n                }\n            }\n\n            pivot[j] = jp;\n\n            if (A[jp][j] == 0) return 1;\n\n            if (jp != j) {\n                double[] tA = A[j];\n                A[j] = A[jp];\n                A[jp] = tA;\n            }\n\n            if (j < M - 1) {\n                double recp = 1.0 / A[j][j];\n                for (int k = j + 1; k < M; k++) {\n                    A[k][j] *= recp;\n                }\n            }\n\n            if (j < minMN - 1) {\n                for (int ii = j + 1; ii < M; ii++) {\n                    double[] Aii = A[ii];\n                    double[] Aj = A[j];\n                    double AiiJ = Aii[j];\n                    for (int jj = j + 1; jj < N; jj++) {\n                        Aii[jj] -= AiiJ * Aj[jj];\n                    }\n                }\n            }\n        }\n\n        return 0;\n    }\n\n    public static void solve(double[][] LU, int[] pvt, double[] b) {\n        int M = LU.length;\n        int N = LU[0].length;\n        int ii = 0;\n\n        for (int i = 0; i < M; i++) {\n            int ip = pvt[i];\n            double sum = b[ip];\n\n            b[ip] = b[i];\n            if (ii == 0) {\n                for (int j = ii; j < i; j++) {\n                    sum -= LU[i][j] * b[j];\n                }\n            } else if (sum == 0.0) {\n                ii = i;\n            }\n            b[i] = sum;\n        }\n\n        for (int i = N - 1; i >= 0; i--) {\n            double sum = b[i];\n            for (int j = i + 1; j < N; j++) {\n                sum -= LU[i][j] * b[j];\n            }\n            b[i] = sum / LU[i][i];\n        }\n    }\n\n    public double[][] getLU() {\n        return new_copy(LU_);\n    }\n\n    public double[] solve(double[] b) {\n        double[] x = new_copy(b);\n        solve(LU_, pivot_, x);\n        return x;\n    }\n}\n",
        0.962,
        0.847,
        0.23693322227339267,
        0.918195443296813,
        0.8460561403508772,
        1.2058383958059882,
        251
    ]
}