{
    "0": [
        "package jnt.scimark2;\n\nimport java.util.Random;\n\npublic class SOROptimized {\n    // Executes the Successive Over-Relaxation (SOR) algorithm.\n    public static void execute(double omega, double[][] G, long num_iterations) {\n        int M = G.length;\n        int N = G[0].length;\n\n        double omega_over_four = omega * 0.25;\n        double one_minus_omega = 1.0 - omega;\n\n        // Update interior points for each iteration.\n        int Mm1 = M - 1;\n        int Nm1 = N - 1;\n        for (long p = 0; p < num_iterations; p++) {\n            for (int i = 1; i < Mm1; i++) {\n                double[] Gi = G[i];\n                double[] Gim1 = G[i - 1];\n                double[] Gip1 = G[i + 1];\n                for (int j = 1; j < Nm1; j++) {\n                    Gi[j] = omega_over_four * (Gim1[j] + Gip1[j] + Gi[j - 1] + Gi[j + 1])\n                            + one_minus_omega * Gi[j];\n                }\n            }\n        }\n    }\n\n    // Helper method to generate a random matrix with dimensions M x N.\n    private static double[][] randomMatrix(int M, int N) {\n        double[][] A = new double[M][N];\n        Random R = new Random(101010);\n        for (int i = 0; i < M; i++) {\n            for (int j = 0; j < N; j++) {\n                A[i][j] = R.nextDouble();\n            }\n        }\n        return A;\n    }\n\n\n    private static double normabs(double[] x, double[] y) {\n        int N = x.length;\n        double sum = 0.0;\n\n        for (int i = 0; i < N; i++)\n            sum += Math.abs(x[i] - y[i]);\n\n        return sum;\n    }\n\n    /**\n    * Main method, do not change.\n    */\n    public static void main(String[] args) {\n        final int SOR_SIZE = 100;      \n        final long cycles = 65536;      // Fixed number of iterations.\n        double omega = 1.25;            // Relaxation factor\n\n        // Create a random matrix of dimensions SOR_SIZE x SOR_SIZE.\n        double[][] G = randomMatrix(SOR_SIZE, SOR_SIZE);\n\n        // Execute the SOR algorithm.\n        execute(omega, G, cycles);\n\n        // Compute the error between the two matrices (should be 0.0 for a matrix of random values)\n        double[][] G_baseline = randomMatrix(SOR_SIZE, SOR_SIZE);\n        double error = 0.0;\n        for (int i = 0; i < SOR_SIZE; i++) {\n            error += normabs(G[i], G_baseline[i]);\n        }\n\n        // Print the error result\n        System.out.println(error * 1.0e-6);\n    }\n}\n\n\n",
        109.182,
        2.32,
        10047825203.0,
        45676.0,
        0.431,
        1667.64,
        79
    ],
    "1": [
        "package jnt.scimark2;\n\nimport java.util.Random;\n\npublic class SOROptimized {\n    \n    public static void execute(double omega, double[][] G, long num_iterations) {\n        int M = G.length;\n        int N = G[0].length;\n\n        double omega_over_four = omega * 0.25;\n        double one_minus_omega = 1.0 - omega;\n\n        \n        int Mm1 = M - 1;\n        int Nm1 = N - 1;\n        for (long p = 0; p < num_iterations; p++) {\n            for (int i = 1; i < Mm1; i++) {\n                double[] Gi = G[i];\n                double[] Gim1 = G[i - 1];\n                double[] Gip1 = G[i + 1];\n                int j;\n                for (j = 1; j < Nm1 - 1; j += 2) { \n                    double newValue1 = omega_over_four * (Gim1[j] + Gip1[j] + Gi[j - 1] + Gi[j + 1])\n                            + one_minus_omega * Gi[j];\n                    double newValue2 = omega_over_four * (Gim1[j + 1] + Gip1[j + 1] + Gi[j] + Gi[j + 2])\n                            + one_minus_omega * Gi[j + 1];\n                    Gi[j] = newValue1;\n                    Gi[j + 1] = newValue2;\n                }\n                \n                if (j < Nm1) {\n                    Gi[j] = omega_over_four * (Gim1[j] + Gip1[j] + Gi[j - 1] + Gi[j + 1])\n                            + one_minus_omega * Gi[j];\n                }\n            }\n        }\n    }\n\n    \n    private static double[][] randomMatrix(int M, int N) {\n        double[][] A = new double[M][N];\n        Random R = new Random(101010);\n        for (int i = 0; i < M; i++) {\n            for (int j = 0; j < N; j++) {\n                A[i][j] = R.nextDouble();\n            }\n        }\n        return A;\n    }\n\n\n    private static double normabs(double[] x, double[] y) {\n        int N = x.length;\n        double sum = 0.0;\n\n        for (int i = 0; i < N; i++)\n            sum += Math.abs(x[i] - y[i]);\n\n        return sum;\n    }\n\n    \n    public static void main(String[] args) {\n        final int SOR_SIZE = 100;      \n        final long cycles = 65536;      \n        double omega = 1.25;            \n\n        \n        double[][] G = randomMatrix(SOR_SIZE, SOR_SIZE);\n\n        \n        execute(omega, G, cycles);\n\n        \n        double[][] G_baseline = randomMatrix(SOR_SIZE, SOR_SIZE);\n        double error = 0.0;\n        for (int i = 0; i < SOR_SIZE; i++) {\n            error += normabs(G[i], G_baseline[i]);\n        }\n\n        \n        System.out.println(error * 1.0e-6);\n    }\n}\n",
        2.14,
        2.415,
        2.748940816045708,
        1.0077663048274645,
        2.4148004640371226,
        3.3085138279244917,
        85
    ],
    "2": [
        "package jnt.scimark2;\n\nimport java.util.Random;\n\npublic class SOROptimized {\n\n    public static void execute(double omega, double[][] G, long num_iterations) {\n        int M = G.length;\n        int N = G[0].length;\n\n        double omega_over_four = omega * 0.25;\n        double one_minus_omega = 1.0 - omega;\n\n        int Mm1 = M - 1;\n        int Nm1 = N - 1;\n        for (long p = 0; p < num_iterations; p++) {\n            for (int i = 1; i < Mm1; i++) {\n                double[] Gi = G[i];\n                double[] Gim1 = G[i - 1];\n                double[] Gip1 = G[i + 1];\n\n                for (int j = 1; j < Nm1; j++) {\n                    double sum = Gim1[j] + Gip1[j] + Gi[j - 1] + Gi[j + 1];\n                    double newValue = omega_over_four * sum + one_minus_omega * Gi[j];\n                    Gi[j] = newValue;\n                }\n            }\n        }\n    }\n\n    private static double[][] randomMatrix(int M, int N) {\n        double[][] A = new double[M][N];\n        Random R = new Random(101010);\n        for (int i = 0; i < M; i++) {\n            for (int j = 0; j < N; j++) {\n                A[i][j] = R.nextDouble();\n            }\n        }\n        return A;\n    }\n\n    private static double normabs(double[] x, double[] y) {\n        int N = x.length;\n        double sum = 0.0;\n\n        for (int i = 0; i < N; i++) {\n            sum += Math.abs(x[i] - y[i]);\n        }\n\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        final int SOR_SIZE = 100;\n        final long cycles = 65536;\n        double omega = 1.25;\n\n        double[][] G = randomMatrix(SOR_SIZE, SOR_SIZE);\n\n        execute(omega, G, cycles);\n\n        double[][] G_baseline = randomMatrix(SOR_SIZE, SOR_SIZE);\n        double error = 0.0;\n        for (int i = 0; i < SOR_SIZE; i++) {\n            error += normabs(G[i], G_baseline[i]);\n        }\n\n        System.out.println(error * 1.0e-6);\n    }\n}\n",
        1.026,
        1.002,
        0.99918599542813,
        0.997675962815405,
        1.0022714617169373,
        0.988870499628217,
        70
    ]
}